
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim)
fchdir() to previous dir
sourcing "$VIM/vimrc"
line 1: " System vimrc file for MacVim
line 2: "
line 3: " Maintainer:^IBjorn Winckler <bjorn.winckler@gmail.com>
line 4: " Last Change:^ISat Aug 29 2009
line 5: 
line 6: set nocompatible
line 7: 
line 8: " The default for 'backspace' is very confusing to new users, so change it to a
line 9: " more sensible value.  Add "set backspace&" to your ~/.vimrc to reset it.
line 10: set backspace+=indent,eol,start
line 11: 
line 12: " Disable localized menus for now since only some items are translated (e.g.
line 13: " the entire MacVim menu is set up in a nib file which currently only is
line 14: " translated to English).
line 15: set langmenu=none
line 16: 
line 17: " Python2
line 18: " MacVim uses Homebrew python2 if installed, otherwise configured one
line 19: if exists("&pythondll") && exists("&pythonhome")
line 20:   if filereadable("/usr/local/Frameworks/Python.framework/Versions/2.7/Python")
line 21:     " Homebrew python 2.7
line 22:     set pythondll=/usr/local/Frameworks/Python.framework/Versions/2.7/Python
line 23:     set pythonhome=/usr/local/Frameworks/Python.framework/Versions/2.7
line 24:   endif
line 25: endif
line 26: 
line 27: " Python3
line 28: " MacVim uses Homebrew python3 if installed, next try to use python.org binary
line 30: if exists("&pythonthreedll") && exists("&pythonthreehome") && !filereadable(&pythonthreedll)
line 31:   if filereadable("/Library/Frameworks/Python.framework/Versions/3.6/Python")
line 32:     " https://www.python.org/downloads/mac-osx/
line 33:     set pythonthreedll=/Library/Frameworks/Python.framework/Versions/3.6/Python
line 34:     set pythonthreehome=/Library/Frameworks/Python.framework/Versions/3.6
line 35:   endif
line 36: endif
line 37: 
finished sourcing $VIM/vimrc
chdir(/Users/jmoussa)
fchdir() to previous dir
sourcing "$HOME/.vimrc"
line 1: "JOSEPH MOUSSA VIMRC
line 2: 
line 3: "VISUALS
line 4: syntax enable
line 4: so $VIMRUNTIME/syntax/syntax.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 4: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 04
line 4: 
line 5: " This file is used for ":syntax on".
line 6: " It installs the autocommands and starts highlighting for all buffers.
line 7: 
line 8: if !has("syntax")
line 9:   finish
line 10: endif
line 11: 
line 12: " If Syntax highlighting appears to be on already, turn it off first, so that
line 13: " any leftovers are cleared.
line 14: if exists("syntax_on") || exists("syntax_manual")
line 15:   so <sfile>:p:h/nosyntax.vim
line 16: endif
line 17: 
line 18: " Load the Syntax autocommands and set the default methods for highlighting.
line 19: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/syntax/synload.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/syntax/synload.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 19: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2016 Nov 04
line 4: 
line 5: " This file sets up for syntax highlighting.
line 6: " It is loaded from "syntax.vim" and "manual.vim".
line 7: " 1. Set the default highlight groups.
line 8: " 2. Install Syntax autocommands for all the available syntax files.
line 9: 
line 10: if !has("syntax")
line 11:   finish
line 12: endif
line 13: 
line 14: " let others know that syntax has been switched on
line 15: let syntax_on = 1
line 16: 
line 17: " Set the default highlighting colors.  Use a color scheme if specified.
line 18: if exists("colors_name")
line 19:   exe "colors " . colors_name
line 20: else
line 21:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/syntax/syncolor.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 21: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi def Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi def Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi def Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi def Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi def Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi def PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi def Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi def Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi def Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi def Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi def Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi def link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi def link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi def link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi def link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi def link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi def link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi def link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi def link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi def link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi def link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi def link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi def link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi def link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi def link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi def link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi def link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi def link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi def link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi def link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi def link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi def link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi def link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi def link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi def link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim
continuing in /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/Users/jmoussa/.vim/after/syntax/syncolor.vim"
line 22: endif
line 23: 
line 24: " Line continuation is used here, remove 'C' from 'cpoptions'
line 25: let s:cpo_save = &cpo
line 26: set cpo&vim
line 27: 
line 28: " First remove all old syntax autocommands.
line 29: au! Syntax
line 30: 
line 31: au Syntax *^I^Icall s:SynSet()
line 32: 
line 33: fun! s:SynSet()
line 61: 
line 62: 
line 63: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 68: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 69: 
line 70: 
line 71: " Source the user-specified syntax highlighting file
line 72: if exists("mysyntaxfile")
line 73:   let s:fname = expand(mysyntaxfile)
line 74:   if filereadable(s:fname)
line 75:     execute "source " . fnameescape(s:fname)
line 76:   endif
line 77: endif
line 78: 
line 79: " Restore 'cpoptions'
line 80: let &cpo = s:cpo_save
line 81: unlet s:cpo_save
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim
continuing in /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim
line 20: 
line 21: " Load the FileType autocommands if not done yet.
line 22: if exists("did_load_filetypes")
line 23:   let s:did_ft = 1
line 24: else
line 25:   filetype on
Searching for "filetype.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 25: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2017 Aug 11
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Vim help file
line 52: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 53: 
line 54: " Abaqus or Trasys
line 55: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()
line 56: 
line 57: func! s:Check_inp()
line 76: 
line 77: " A-A-P recipe
line 78: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 79: 
line 80: " A2ps printing utility
line 81: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 82: 
line 83: " ABAB/4
line 84: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 85: 
line 86: " ABC music notation
line 87: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 88: 
line 89: " ABEL
line 90: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 91: 
line 92: " AceDB
line 93: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 94: 
line 95: " Ada (83, 9X, 95)
line 96: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 97: if has("vms")
line 98:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 99: else
line 100:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 101: endif
line 102: 
line 103: " AHDL
line 104: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 105: 
line 106: " AMPL
line 107: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 108: 
line 109: " Ant
line 110: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 111: 
line 112: " Arduino
line 113: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 114: 
line 115: " Apache style config file
line 116: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 117: 
line 118: " Apache config file
line 119: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 120: 
line 121: " XA65 MOS6510 cross assembler
line 122: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 123: 
line 124: " Applescript
line 125: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 126: 
line 127: " Applix ELF
line 129: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 130: 
line 131: " ALSA configuration
line 132: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 133: 
line 134: " Arc Macro Language
line 135: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 136: 
line 137: " APT config file
line 138: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 139: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 140: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 141: 
line 142: " Arch Inventory file
line 143: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 144: 
line 145: " ART*Enterprise (formerly ART-IM)
line 146: au BufNewFile,BufRead *.art^I^I^Isetf art
line 147: 
line 148: " AsciiDoc
line 149: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 150: 
line 151: " ASN.1
line 152: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 153: 
line 154: " Active Server Pages (with Visual Basic Script)
line 160: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 161: 
line 162: " Active Server Pages (with Perl or Visual Basic Script)
line 170: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 171: 
line 172: " Grub (must be before catch *.lst)
line 173: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 174: 
line 175: " Assembly (all kinds)
line 176: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 177: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()
line 178: 
line 179: " This function checks for the kind of assembly that is wanted by the user, or
line 180: " can be detected from the first five lines of the file.
line 181: func! s:FTasm()
line 202: 
line 203: func! s:FTasmsyntax()
line 215: 
line 216: " Macro (VAX)
line 217: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 218: 
line 219: " Atlas
line 220: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 221: 
line 222: " Autoit v3
line 223: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 224: 
line 225: " Autohotkey
line 226: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 227: 
line 228: " Automake
line 229: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 230: 
line 231: " Autotest .at files are actually m4
line 232: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 233: 
line 234: " Avenue
line 235: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 236: 
line 237: " Awk
line 238: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 239: 
line 240: " B
line 241: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 242: 
line 243: " BASIC or Visual Basic
line 244: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")
line 245: 
line 246: " Check if one of the first five lines contains "VB_Name".  In that case it is
line 247: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
line 248: func! s:FTVB(alt)
line 255: 
line 256: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 257: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 258: 
line 259: " IBasic file (similar to QBasic)
line 260: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 261: 
line 262: " FreeBasic file (similar to QBasic)
line 263: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 264: 
line 265: " Batch file for MSDOS.
line 266: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 267: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 269: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 270: 
line 271: " Batch file for 4DOS
line 272: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()
line 273: func! s:FTbtm()
line 280: 
line 281: " BC calculator
line 282: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 283: 
line 284: " BDF font
line 285: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 286: 
line 287: " BibTeX bibliography database file
line 288: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 289: 
line 290: " BibTeX Bibliography Style
line 291: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 292: 
line 293: " BIND configuration
line 294: " sudoedit uses namedXXXX.conf
line 295: au BufNewFile,BufRead named*.conf,rndc*.conf^Isetf named
line 296: 
line 297: " BIND zone
line 298: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 299: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')
line 300: 
line 301: func! s:BindzoneCheck(default)
line 308: 
line 309: " Blank
line 310: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 311: 
line 312: " Blkid cache file
line 313: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 314: 
line 315: " Bazel (http://bazel.io)
line 316: autocmd BufRead,BufNewFile *.bzl,WORKSPACE ^Isetf bzl
line 317: if has("fname_case")
line 318:   " There is another check for BUILD further below.
line 319:   autocmd BufRead,BufNewFile BUILD^I^Isetf bzl
line 320: endif
line 321: 
line 322: " C or lpc
line 323: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()
line 324: 
line 325: func! s:FTlpc()
line 338: 
line 339: " Calendar
line 340: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 341: 
line 342: " C#
line 343: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 344: 
line 345: " CSDL
line 346: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 347: 
line 348: " Cabal
line 349: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 350: 
line 351: " Cdrdao TOC
line 352: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 353: 
line 354: " Cdrdao config
line 355: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 356: 
line 357: " Cfengine
line 358: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 359: 
line 360: " ChaiScript
line 361: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 362: 
line 363: " Comshare Dimension Definition Language
line 364: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 365: 
line 366: " Conary Recipe
line 367: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 368: 
line 369: " Controllable Regex Mutilator
line 370: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 371: 
line 372: " Cyn++
line 373: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 374: 
line 375: " Cynlib
line 376: " .cc and .cpp files can be C++ or Cynlib.
line 378: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 380: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 381: 
line 382: " C++
line 383: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 384: if has("fname_case")
line 385:   au BufNewFile,BufRead *.C,*.H setf cpp
line 386: endif
line 387: 
line 388: " .h files can be C, Ch C++, ObjC or ObjC++.
line 389: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 390: " detected automatically.
line 391: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()
line 392: 
line 393: func! s:FTheader()
line 408: 
line 409: " Ch (CHscript)
line 410: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 411: 
line 412: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 413: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 414: 
line 415: " Cascading Style Sheets
line 416: au BufNewFile,BufRead *.css^I^I^Isetf css
line 417: 
line 418: " Century Term Command Scripts (*.cmd too)
line 419: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 420: 
line 421: " Changelog
line 423: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 424: 
line 430: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 431: 
line 435: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 436: 
line 437: " CHILL
line 438: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 439: 
line 440: " Changes for WEB and CWEB or CHILL
line 441: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()
line 442: 
line 443: " This function checks if one of the first ten lines start with a '@'.  In
line 444: " that case it is probably a change file.
line 445: " If the first line starts with # or ! it's probably a ch file.
line 446: " If a line has "main", "include", "//" ir "/*" it's probably ch.
line 447: " Otherwise CHILL is assumed.
line 448: func! s:FTchange()
line 471: 
line 472: " ChordPro
line 473: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 474: 
line 475: " Clean
line 476: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 477: 
line 478: " Clever
line 479: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 480: 
line 481: " Clever or dtd
line 482: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()
line 483: 
line 484: func! s:FTent()
line 503: 
line 504: " Clipper (or FoxPro; could also be eviews)
line 510: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 511: 
line 512: " Clojure
line 513: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 514: 
line 515: " Cmake
line 516: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 517: 
line 518: " Cmusrc
line 519: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 520: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 521: 
line 522: " Cobol
line 523: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 524: "   cobol or zope form controller python script? (heuristic)
line 530: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 531: 
line 532: " Coco/R
line 533: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 534: 
line 535: " Cold Fusion
line 536: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 537: 
line 538: " Configure scripts
line 539: au BufNewFile,BufRead configure.in,configure.ac setf config
line 540: 
line 541: " CUDA  Cumpute Unified Device Architecture
line 542: au BufNewFile,BufRead *.cu^I^I^Isetf cuda
line 543: 
line 544: " Dockerfile
line 545: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile
line 546: 
line 547: " WildPackets EtherPeek Decoder
line 548: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 549: 
line 550: " Enlightenment configuration files
line 551: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 552: 
line 553: " Eterm
line 554: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 555: 
line 556: " Euphoria 3 or 4
line 557: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
line 558: if has("fname_case")
line 559:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
line 560: endif
line 561: 
line 562: func! s:EuphoriaCheck()
line 569: 
line 570: " Lynx config files
line 571: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 572: 
line 573: " Quake
line 574: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 575: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 576: 
line 577: " Quake C
line 578: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 579: 
line 580: " Configure files
line 581: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 582: 
line 583: " Cucumber
line 584: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 585: 
line 586: " Communicating Sequential Processes
line 587: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 588: 
line 589: " CUPL logic description and simulation
line 590: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 591: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 592: 
line 593: " Debian Control
line 594: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 598: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 599: 
line 600: " Debian Sources.list
line 601: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 602: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 603: 
line 604: " Deny hosts
line 605: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 606: 
line 607: " dnsmasq(8) configuration files
line 608: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 609: 
line 610: " ROCKLinux package description
line 611: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 612: 
line 613: " the D language or dtrace
line 614: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()
line 615: 
line 616: func! s:DtraceCheck()
line 627: 
line 628: " Desktop files
line 629: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 630: 
line 631: " Dict config
line 632: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 633: 
line 634: " Dictd config
line 635: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 636: 
line 637: " Diff files
line 638: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 644: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 645: 
line 646: " Dircolors
line 647: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 648: 
line 649: " Diva (with Skill) or InstallShield
line 655: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 656: 
line 657: " DCL (Digital Command Language - vms) or DNS zone file
line 658: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')
line 659: 
line 660: " DOT
line 661: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 662: 
line 663: " Dylan - lid files
line 664: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 665: 
line 666: " Dylan - intr files (melange)
line 667: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 668: 
line 669: " Dylan
line 670: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 671: 
line 672: " Microsoft Module Definition
line 673: au BufNewFile,BufRead *.def^I^I^Isetf def
line 674: 
line 675: " Dracula
line 676: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 677: 
line 678: " Datascript
line 679: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 680: 
line 681: " dsl
line 682: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 683: 
line 684: " DTD (Document Type Definition for XML)
line 685: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 686: 
line 687: " DTS/DSTI (device tree files)
line 688: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 689: 
line 690: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 691: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 697: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 698: 
line 699: " EditorConfig (close enough to dosini)
line 700: au BufNewFile,BufRead .editorconfig^I^Isetf dosini
line 701: 
line 702: " Embedix Component Description
line 703: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 704: 
line 705: " Eiffel or Specman or Euphoria
line 706: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()
line 707: 
line 708: " Elinks configuration
line 709: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 710: 
line 711: func! s:FTe()
line 726: 
line 727: " ERicsson LANGuage; Yaws is erlang too
line 728: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 729: 
line 730: " Elm Filter Rules file
line 731: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 732: 
line 733: " ESMTP rc file
line 734: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 735: 
line 736: " ESQL-C
line 737: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 738: 
line 739: " Esterel
line 740: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 741: 
line 742: " Essbase script
line 743: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 744: 
line 745: " Exim
line 746: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 747: 
line 748: " Expect
line 749: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 750: 
line 751: " Exports
line 752: au BufNewFile,BufRead exports^I^I^Isetf exports
line 753: 
line 754: " Falcon
line 755: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 756: 
line 757: " Fantom
line 758: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 759: 
line 760: " Factor
line 761: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 762: 
line 763: " Fetchmail RC file
line 764: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 765: 
line 766: " FlexWiki - disabled, because it has side effects when a .wiki file
line 767: " is not actually FlexWiki
line 768: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 769: 
line 770: " Focus Executable
line 771: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 772: 
line 773: " Focus Master file (but not for auto.master)
line 774: au BufNewFile,BufRead auto.master^I^Isetf conf
line 775: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 776: 
line 777: " Forth
line 778: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth
line 779: 
line 780: " Reva Forth
line 781: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 782: 
line 783: " Fortran
line 784: if has("fname_case")
line 785:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 786: endif
line 787: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 788: 
line 789: " Framescript
line 790: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 791: 
line 792: " FStab
line 793: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 794: 
line 795: " GDB command files
line 796: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 797: 
line 798: " GDMO
line 799: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 800: 
line 801: " Gedcom
line 802: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 803: 
line 804: " Git
line 805: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit
line 806: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
line 807: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig
line 808: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig
line 809: if !empty($XDG_CONFIG_HOME)
line 810:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^Isetf gitconfig
line 811: endif
line 812: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 813: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail
line 817: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 821: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 822: 
line 823: " Gkrellmrc
line 824: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 825: 
line 826: " GP scripts (2.0 and onward)
line 827: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 828: 
line 829: " GPG
line 830: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 831: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 832: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 833: if !empty($GNUPGHOME)
line 834:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 835:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 836: endif
line 837: 
line 838: " gnash(1) configuration files
line 839: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 840: 
line 841: " Gitolite
line 842: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 843: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 844: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 845: 
line 846: " Gnuplot scripts
line 847: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 848: 
line 849: " Go (Google)
line 850: au BufNewFile,BufRead *.go^I^I^Isetf go
line 851: 
line 852: " GrADS scripts
line 853: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 854: 
line 855: " Gretl
line 856: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 857: 
line 858: " Groovy
line 859: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
line 860: 
line 861: " GNU Server Pages
line 862: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 863: 
line 864: " Group file
line 865: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 866: 
line 867: " GTK RC
line 868: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 869: 
line 870: " Haml
line 871: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 872: 
line 873: " Hamster Classic | Playground files
line 874: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 875: 
line 876: " Haskell
line 877: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 878: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 879: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 880: 
line 881: " Haste
line 882: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 883: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 884: 
line 885: " Hercules
line 886: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 887: 
line 888: " HEX (Intel)
line 889: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 890: 
line 891: " Tilde (must be before HTML)
line 892: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 893: 
line 894: " HTML (.shtml and .stm for server side)
line 895: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
line 896: 
line 897: " Distinguish between HTML, XHTML and Django
line 898: func! s:FThtml()
line 913: 
line 914: " HTML with Ruby - eRuby
line 915: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 916: 
line 917: " HTML with M4
line 918: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 919: 
line 920: " HTML Cheetah template
line 921: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 922: 
line 923: " Host config
line 924: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 925: 
line 926: " Hosts access
line 927: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 928: 
line 929: " Hyper Builder
line 930: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 931: 
line 932: " Httest
line 933: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 934: 
line 935: " Icon
line 936: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 937: 
line 938: " IDL (Interface Description Language)
line 939: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()
line 940: 
line 941: " Distinguish between standard IDL and MS-IDL
line 942: func! s:FTidl()
line 953: 
line 954: " Microsoft IDL (Interface Description Language)  Also *.idl
line 955: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 956: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 957: 
line 958: " Icewm menu
line 959: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 960: 
line 961: " Indent profile (must come before IDL *.pro!)
line 962: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 963: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')
line 964: 
line 965: " IDL (Interactive Data Language)
line 966: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')
line 967: 
line 968: " Distinguish between "default" and Cproto prototype file. */
line 969: func! s:ProtoCheck(default)
line 981: 
line 982: 
line 983: " Indent RC
line 984: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 985: 
line 986: " Inform
line 987: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 988: 
line 989: " Initng
line 990: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 991: 
line 992: " Innovation Data Processing
line 993: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 994: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog
line 995: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 996: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 997: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 998: 
line 999: " Ipfilter
line 1000: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 1001: 
line 1002: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 1003: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 1004: 
line 1005: " .INI file for MSDOS
line 1006: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 1007: 
line 1008: " SysV Inittab
line 1009: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 1010: 
line 1011: " Inno Setup
line 1012: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 1013: 
line 1014: " J
line 1015: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 1016: 
line 1017: " JAL
line 1018: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 1019: 
line 1020: " Jam
line 1021: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 1022: 
line 1023: " Java
line 1024: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 1025: 
line 1026: " JavaCC
line 1027: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 1028: 
line 1029: " JavaScript, ECMAScript
line 1030: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
line 1031: 
line 1032: " Java Server Pages
line 1033: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 1034: 
line 1035: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 1036: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 1037: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 1038: 
line 1039: " Jess
line 1040: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 1041: 
line 1042: " Jgraph
line 1043: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 1044: 
line 1045: " Jovial
line 1046: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 1047: 
line 1048: " JSON
line 1049: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 1050: 
line 1051: " Kixtart
line 1052: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 1053: 
line 1054: " Kimwitu[++]
line 1055: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 1056: 
line 1057: " Kivy
line 1058: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 1059: 
line 1060: " KDE script
line 1061: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 1062: 
line 1063: " Kconfig
line 1064: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1065: 
line 1066: " Lace (ISE)
line 1067: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1068: 
line 1069: " Latte
line 1070: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1071: 
line 1072: " Limits
line 1073: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1074: 
line 1075: " LambdaProlog (*.mod too, see Modsim)
line 1076: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 1077: 
line 1078: " LDAP LDIF
line 1079: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1080: 
line 1081: " Ld loader
line 1082: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1083: 
line 1084: " Less
line 1085: au BufNewFile,BufRead *.less^I^I^Isetf less
line 1086: 
line 1087: " Lex
line 1088: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 1089: 
line 1090: " Libao
line 1091: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1092: 
line 1093: " Libsensors
line 1094: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1095: 
line 1096: " LFTP
line 1097: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1098: 
line 1099: " Lifelines (or Lex for C++!)
line 1100: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1101: 
line 1102: " Lilo: Linux loader
line 1103: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1104: 
line 1105: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 1106: if has("fname_case")
line 1107:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 1108: else
line 1109:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 1110: endif
line 1111: 
line 1112: " SBCL implementation of Common Lisp
line 1113: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1114: 
line 1115: " Liquid
line 1116: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1117: 
line 1118: " Lite
line 1119: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1120: 
line 1121: " LiteStep RC files
line 1122: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1123: 
line 1124: " Login access
line 1125: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1126: 
line 1127: " Login defs
line 1128: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1129: 
line 1130: " Logtalk
line 1131: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1132: 
line 1133: " LOTOS
line 1134: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1135: 
line 1136: " Lout (also: *.lt)
line 1137: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1138: 
line 1139: " Lua
line 1140: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1141: 
line 1142: " Luarocks
line 1143: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 1144: 
line 1145: " Linden Scripting Language (Second Life)
line 1146: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 1147: 
line 1148: " Lynx style file (or LotusScript!)
line 1149: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1150: 
line 1151: " M4
line 1153: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1154: 
line 1155: " MaGic Point
line 1156: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1157: 
line 1158: " Mail (for Elm, trn, mutt, muttng, rn, slrn)
line 1159: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1160: 
line 1161: " Mail aliases
line 1162: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1163: 
line 1164: " Mailcap configuration file
line 1165: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1166: 
line 1167: " Makefile
line 1168: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1169: 
line 1170: " MakeIndex
line 1171: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1172: 
line 1173: " Mallard
line 1174: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1175: 
line 1176: " Manpage
line 1177: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1178: 
line 1179: " Man config
line 1180: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1181: 
line 1182: " Maple V
line 1183: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1184: 
line 1185: " Map (UMN mapserver config file)
line 1186: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1187: 
line 1188: " Markdown
line 1189: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 1190: 
line 1191: " Mason
line 1192: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 1193: 
line 1194: " Mathematica, Matlab, Murphi or Objective C
line 1195: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()
line 1196: 
line 1197: func! s:FTm()
line 1240: 
line 1241: " Mathematica notebook
line 1242: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1243: 
line 1244: " Maya Extension Language
line 1245: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1246: 
line 1247: " Mercurial (hg) commit file
line 1248: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1249: 
line 1250: " Mercurial config (looks like generic config file)
line 1251: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1252: 
line 1253: " Messages (logs mostly)
line 1254: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1255: 
line 1256: " Metafont
line 1257: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1258: 
line 1259: " MetaPost
line 1260: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1261: 
line 1262: " MGL
line 1263: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1264: 
line 1265: " MIX - Knuth assembly
line 1266: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 1267: 
line 1268: " MMIX or VMS makefile
line 1269: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()
line 1270: 
line 1271: " Symbian meta-makefile definition (MMP)
line 1272: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1273: 
line 1274: func! s:FTmms()
line 1290: 
line 1291: 
line 1292: " Modsim III (or LambdaProlog)
line 1298: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1299: 
line 1300: " Modula 2  (.md removed in favor of Markdown)
line 1301: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
line 1302: 
line 1303: " Modula 3 (.m3, .i3, .mg, .ig)
line 1304: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1305: 
line 1306: " Monk
line 1307: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1308: 
line 1309: " MOO
line 1310: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1311: 
line 1312: " Modconf
line 1313: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1314: 
line 1315: " Mplayer config
line 1316: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1317: 
line 1318: " Motorola S record
line 1319: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1320: 
line 1321: " Mrxvtrc
line 1322: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1323: 
line 1324: " Msql
line 1325: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1326: 
line 1327: " Mysql
line 1328: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1329: 
line 1330: " Mutt setup files (must be before catch *.rc)
line 1331: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1332: 
line 1333: " M$ Resource files
line 1334: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1335: 
line 1336: " MuPAD source
line 1337: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1338: 
line 1339: " Mush
line 1340: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1341: 
line 1342: " Mutt setup file (also for Muttng)
line 1343: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1344: 
line 1345: " N1QL
line 1346: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1347: 
line 1348: " Nano
line 1349: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
line 1350: 
line 1351: " Nastran input/DMAP
line 1352: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1353: 
line 1354: " Natural
line 1355: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1356: 
line 1357: " Netrc
line 1358: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1359: 
line 1360: " Ninja file
line 1361: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1362: 
line 1363: " Novell netware batch files
line 1364: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1365: 
line 1366: " Nroff/Troff (*.ms and *.t are checked below)
line 1370: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1371: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1372: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()
line 1373: 
line 1374: " This function checks if one of the first five lines start with a dot.  In
line 1375: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
line 1376: func! s:FTnroff()
line 1383: 
line 1384: " Nroff or Objective C++
line 1385: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()
line 1386: 
line 1387: func! s:FTmm()
line 1399: 
line 1400: " Not Quite C
line 1401: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1402: 
line 1403: " NSE - Nmap Script Engine - uses Lua syntax
line 1404: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1405: 
line 1406: " NSIS
line 1407: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1408: 
line 1409: " OCAML
line 1410: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1411: 
line 1412: " Occam
line 1413: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1414: 
line 1415: " Omnimark
line 1416: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1417: 
line 1418: " OpenROAD
line 1419: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1420: 
line 1421: " OPL
line 1422: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1423: 
line 1424: " Oracle config file
line 1425: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1426: 
line 1427: " Packet filter conf
line 1428: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1429: 
line 1430: " Pam conf
line 1431: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1432: 
line 1433: " PApp
line 1434: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1435: 
line 1436: " Password file
line 1437: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1438: 
line 1439: " Pascal (also *.p)
line 1440: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1441: 
line 1442: " Delphi project file
line 1443: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1444: 
line 1445: " PDF
line 1446: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1447: 
line 1448: " Perl
line 1449: if has("fname_case")
line 1450:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()
line 1451: else
line 1452:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()
line 1453: endif
line 1454: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl
line 1455: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
line 1456: 
line 1457: func! s:FTpl()
line 1471: 
line 1472: " Perl, XPM or XPM2
line 1480: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1481: 
line 1482: " Perl POD
line 1483: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1484: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
line 1485: 
line 1486: " Php, php3, php4, etc.
line 1487: " Also Phtml (was used for PHP 2 in the past)
line 1488: " Also .ctp for Cake template file
line 1489: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1490: 
line 1491: " Pike
line 1492: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
line 1493: 
line 1494: " Pinfo config
line 1495: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1496: 
line 1497: " Palm Resource compiler
line 1498: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1499: 
line 1500: " Pine config
line 1501: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1502: 
line 1503: " PL/1, PL/I
line 1504: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1505: 
line 1506: " PL/M (also: *.inp)
line 1507: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1508: 
line 1509: " PL/SQL
line 1510: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1511: 
line 1512: " PLP
line 1513: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1514: 
line 1515: " PO and PO template (GNU gettext)
line 1516: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1517: 
line 1518: " Postfix main config
line 1519: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1520: 
line 1521: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1522: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1523: 
line 1524: " PostScript Printer Description
line 1525: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1526: 
line 1527: " Povray
line 1528: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1529: 
line 1530: " Povray configuration
line 1531: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1532: 
line 1533: " Povray, PHP or assembly
line 1534: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()
line 1535: 
line 1536: func! s:FTinc()
line 1557: 
line 1558: " Printcap and Termcap
line 1560: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1562: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1563: 
line 1564: " PCCTS / ANTRL
line 1565: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1566: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1567: 
line 1568: " PPWizard
line 1569: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1570: 
line 1571: " Obj 3D file format
line 1572: " TODO: is there a way to avoid MS-Windows Object files?
line 1573: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1574: 
line 1575: " Oracle Pro*C/C++
line 1576: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1577: 
line 1578: " Privoxy actions file
line 1579: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1580: 
line 1581: " Procmail
line 1582: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1583: 
line 1584: " Progress or CWEB
line 1585: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()
line 1586: 
line 1587: func! s:FTprogress_cweb()
line 1598: 
line 1599: " Progress or assembly
line 1600: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()
line 1601: 
line 1602: func! s:FTprogress_asm()
line 1624: 
line 1625: " Progress or Pascal
line 1626: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()
line 1627: 
line 1628: func! s:FTprogress_pascal()
line 1652: 
line 1653: 
line 1654: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1655: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1659: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1660: 
line 1661: " Prolog
line 1662: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1663: 
line 1664: " Promela
line 1665: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1666: 
line 1667: " Google protocol buffers
line 1668: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1669: 
line 1670: " Protocols
line 1671: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1672: 
line 1673: " Pyrex
line 1674: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1675: 
line 1676: " Python, Python Shell Startup Files
line 1677: " Quixote (Python-based web framework)
line 1678: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python
line 1679: 
line 1680: " Radiance
line 1681: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1682: 
line 1683: " Ratpoison config/command files
line 1684: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1685: 
line 1686: " RCS file
line 1687: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1688: 
line 1689: " Readline
line 1690: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1691: 
line 1692: " Registry for MS-Windows
line 1694: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1695: 
line 1696: " Renderman Interface Bytestream
line 1697: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1698: 
line 1699: " Rexx
line 1700: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1701: 
line 1702: " R (Splus)
line 1703: if has("fname_case")
line 1704:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1705: else
line 1706:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1707: endif
line 1708: 
line 1709: " R Help file
line 1710: if has("fname_case")
line 1711:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1712: else
line 1713:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1714: endif
line 1715: 
line 1716: " R noweb file
line 1717: if has("fname_case")
line 1718:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1719: else
line 1720:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1721: endif
line 1722: 
line 1723: " R Markdown file
line 1724: if has("fname_case")
line 1725:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1726: else
line 1727:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1728: endif
line 1729: 
line 1730: " R reStructuredText file
line 1731: if has("fname_case")
line 1732:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1733: else
line 1734:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1735: endif
line 1736: 
line 1737: " Rexx, Rebol or R
line 1738: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()
line 1739: 
line 1740: func! s:FTr()
line 1772: 
line 1773: " Remind
line 1774: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1775: 
line 1776: " Resolv.conf
line 1777: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1778: 
line 1779: " Relax NG Compact
line 1780: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1781: 
line 1782: " Relax NG XML
line 1783: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1784: 
line 1785: " RPL/2
line 1786: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1787: 
line 1788: " Robots.txt
line 1789: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1790: 
line 1791: " Rpcgen
line 1792: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1793: 
line 1794: " reStructuredText Documentation Format
line 1795: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1796: 
line 1797: " RTF
line 1798: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1799: 
line 1800: " Interactive Ruby shell
line 1801: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1802: 
line 1803: " Ruby
line 1804: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1805: 
line 1806: " RubyGems
line 1807: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1808: 
line 1809: " Rust
line 1810: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1811: 
line 1812: " Rackup
line 1813: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1814: 
line 1815: " Bundler
line 1816: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1817: 
line 1818: " Ruby on Rails
line 1819: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1820: 
line 1821: " Rantfile and Rakefile is like Ruby
line 1822: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1823: 
line 1824: " S-lang (or shader language, or SmallLisp)
line 1825: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1826: 
line 1827: " Samba config
line 1828: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1829: 
line 1830: " SAS script
line 1831: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1832: 
line 1833: " Sass
line 1834: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1835: 
line 1836: " Sather
line 1837: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1838: 
line 1839: " Scala
line 1840: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1841: 
line 1842: " SBT - Scala Build Tool
line 1843: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1844: 
line 1845: " Scilab
line 1846: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1847: 
line 1848: " SCSS
line 1849: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1850: 
line 1851: " SD: Streaming Descriptors
line 1852: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1853: 
line 1854: " SDL
line 1855: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1856: 
line 1857: " sed
line 1858: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1859: 
line 1860: " Sieve (RFC 3028)
line 1861: au BufNewFile,BufRead *.siv^I^I^Isetf sieve
line 1862: 
line 1863: " Sendmail
line 1864: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1865: 
line 1866: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1867: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()
line 1868: 
line 1869: func! s:McSetf()
line 1884: 
line 1885: " Services
line 1886: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1887: 
line 1888: " Service Location config
line 1889: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1890: 
line 1891: " Service Location registration
line 1892: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1893: 
line 1894: " Service Location SPI
line 1895: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1896: 
line 1897: " Setserial config
line 1898: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1899: 
line 1900: " SGML
line 1910: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1911: 
line 1912: " SGMLDECL
line 1916: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1917: 
line 1918: " SGML catalog file
line 1919: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1920: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1921: 
line 1922: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1923: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
line 1924: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call SetFileTypeSH("bash")
line 1925: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
line 1926: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
line 1927: 
line 1928: " Shell script (Arch Linux) or PHP file (Drupal)
line 1934: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call SetFileTypeSH("bash") | endif
line 1935: 
line 1936: " Also called from scripts.vim.
line 1937: func! SetFileTypeSH(name)
line 1980: 
line 1981: " For shell-like file types, check for an "exec" command hidden in a comment,
line 1982: " as used for Tcl.
line 1983: " Also called from scripts.vim, thus can't be local to this script.
line 1984: func! SetFileTypeShell(name)
line 2003: 
line 2004: " tcsh scripts
line 2005: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")
line 2006: 
line 2007: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 2008: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
line 2009: 
line 2010: func! s:CSH()
line 2019: 
line 2020: " Z-Shell script
line 2021: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 2022: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 2023: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 2024: 
line 2025: " Scheme
line 2026: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 2027: 
line 2028: " Screen RC
line 2029: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 2030: 
line 2031: " Simula
line 2032: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 2033: 
line 2034: " SINDA
line 2035: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 2036: 
line 2037: " SiSU
line 2038: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 2039: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 2040: 
line 2041: " SKILL
line 2042: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 2043: 
line 2044: " SLRN
line 2045: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 2046: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 2047: 
line 2048: " Smalltalk (and TeX)
line 2049: au BufNewFile,BufRead *.st^I^I^Isetf st
line 2057: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 2058: 
line 2059: " Smarty templates
line 2060: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 2061: 
line 2062: " SMIL or XML
line 2068: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 2069: 
line 2070: " SMIL or SNMP MIB file
line 2076: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 2077: 
line 2078: " SMITH
line 2079: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 2080: 
line 2081: " Snobol4 and spitbol
line 2082: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 2083: 
line 2084: " SNMP MIB files
line 2085: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 2086: 
line 2087: " Snort Configuration
line 2088: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 2089: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()
line 2090: 
line 2091: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
line 2092: func! s:FTRules()
line 2124: 
line 2125: 
line 2126: " Spec (Linux RPM)
line 2127: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 2128: 
line 2129: " Speedup (AspenTech plant simulator)
line 2130: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 2131: 
line 2132: " Slice
line 2133: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2134: 
line 2135: " Spice
line 2136: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2137: 
line 2138: " Spyce
line 2139: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2140: 
line 2141: " Squid
line 2142: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2143: 
line 2144: " SQL for Oracle Designer
line 2145: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 2146: 
line 2147: " SQL
line 2148: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()
line 2149: 
line 2150: func! s:SQL()
line 2157: 
line 2158: " SQLJ
line 2159: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2160: 
line 2161: " SQR
line 2162: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2163: 
line 2164: " OpenSSH configuration
line 2165: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 2166: 
line 2167: " OpenSSH server configuration
line 2168: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 2169: 
line 2170: " Stata
line 2171: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 2172: " Also *.class, but not when it's a Java bytecode file
line 2174: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 2175: 
line 2176: " SMCL
line 2177: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2178: 
line 2179: " Stored Procedures
line 2180: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2181: 
line 2182: " Standard ML
line 2183: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2184: 
line 2185: " Sratus VOS command macro
line 2186: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2187: 
line 2188: " Sysctl
line 2189: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2190: 
line 2191: " Systemd unit files
line 2192: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
line 2193: 
line 2194: " Synopsys Design Constraints
line 2195: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2196: 
line 2197: " Sudoers
line 2198: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2199: 
line 2200: " SVG (Scalable Vector Graphics)
line 2201: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2202: 
line 2203: " If the file has an extension of 't' and is in a directory 't' or 'xt' then
line 2204: " it is almost certainly a Perl test file.
line 2205: " If the first line starts with '#' and contains 'perl' it's probably a Perl
line 2206: " file.
line 2207: " (Slow test) If a file contains a 'use' statement then it is almost certainly
line 2208: " a Perl file.
line 2209: func! s:FTperl()
line 2225: 
line 2226: " Tads (or Nroff or Perl test file)
line 2228: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif
line 2229: 
line 2230: " Tags
line 2231: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2232: 
line 2233: " TAK
line 2234: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2235: 
line 2236: " Task
line 2237: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2238: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2239: 
line 2240: " Tcl (JACL too)
line 2241: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 2242: 
line 2243: " TealInfo
line 2244: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2245: 
line 2246: " Telix Salt
line 2247: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2248: 
line 2249: " Tera Term Language
line 2250: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
line 2251: 
line 2252: " Terminfo
line 2253: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2254: 
line 2255: " TeX
line 2256: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2257: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()
line 2258: 
line 2259: " Choose context, plaintex, or tex (LaTeX) based on these rules:
line 2260: " 1. Check the first line of the file for "%&<format>".
line 2261: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
line 2262: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
line 2263: func! s:FTtex()
line 2314: 
line 2315: " ConTeXt
line 2316: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
line 2317: 
line 2318: " Texinfo
line 2319: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2320: 
line 2321: " TeX configuration
line 2322: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2323: 
line 2324: " Tidy config
line 2325: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 2326: 
line 2327: " TF mud client
line 2328: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 2329: 
line 2330: " tmux configuration
line 2331: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 2332: 
line 2333: " TPP - Text Presentation Program
line 2334: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 2335: 
line 2336: " Treetop
line 2337: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2338: 
line 2339: " Trustees
line 2340: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2341: 
line 2342: " TSS - Geometry
line 2343: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2344: 
line 2345: " TSS - Optics
line 2346: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2347: 
line 2348: " TSS - Command Line (temporary)
line 2349: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2350: 
line 2351: " TWIG files
line 2352: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2353: 
line 2354: " Motif UIT/UIL files
line 2355: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2356: 
line 2357: " Udev conf
line 2358: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2359: 
line 2360: " Udev permissions
line 2361: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2362: "
line 2363: " Udev symlinks config
line 2364: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2365: 
line 2366: " UnrealScript
line 2367: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2368: 
line 2369: " Updatedb
line 2370: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2371: 
line 2372: " Upstart (init(8)) config files
line 2373: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2374: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2375: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2376: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 2377: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2378: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2379: 
line 2380: " Vera
line 2381: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2382: 
line 2383: " Verilog HDL
line 2384: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 2385: 
line 2386: " Verilog-AMS HDL
line 2387: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2388: 
line 2389: " SystemVerilog
line 2390: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 2391: 
line 2392: " VHDL
line 2393: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 2394: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2395: 
line 2396: " Vim script
line 2397: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 2398: 
line 2399: " Viminfo file
line 2400: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2401: 
line 2402: " Virata Config Script File or Drupal module
line 2408: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2409: 
line 2410: " Visual Basic (also uses *.bas) or FORM
line 2411: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")
line 2412: 
line 2413: " SaxBasic is close to Visual Basic
line 2414: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2415: 
line 2416: " Vgrindefs file
line 2417: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2418: 
line 2419: " VRML V1.0c
line 2420: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2421: 
line 2422: " Vroom (vim testing and executable documentation)
line 2423: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 2424: 
line 2425: " Webmacro
line 2426: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2427: 
line 2428: " Wget config
line 2429: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2430: 
line 2431: " Website MetaLanguage
line 2432: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2433: 
line 2434: " Winbatch
line 2435: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2436: 
line 2437: " WSML
line 2438: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2439: 
line 2440: " WvDial
line 2441: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2442: 
line 2443: " CVS RC file
line 2444: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2445: 
line 2446: " CVS commit file
line 2447: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2448: 
line 2449: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2450: " lines in a WEB file).
line 2456: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2457: 
line 2458: " Windows Scripting Host and Windows Script Component
line 2459: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2460: 
line 2461: " XHTML
line 2462: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2463: 
line 2464: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 2470: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2471: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 2472: 
line 2473: " XFree86 config
line 2478: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2481: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2482: 
line 2483: " Xorg config
line 2484: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2485: 
line 2486: " Xinetd conf
line 2487: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2488: 
line 2489: " XS Perl extension interface language
line 2490: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2491: 
line 2492: " X resources file
line 2493: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2494: 
line 2495: " Xmath
line 2496: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2498: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif
line 2499: 
line 2500: " XML  specific variants: docbk and xbl
line 2501: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()
line 2502: 
line 2503: func! s:FTxml()
line 2528: 
line 2529: " XMI (holding UML models) is also XML
line 2530: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2531: 
line 2532: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 2533: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2534: 
line 2535: " Qt Linguist translation source and Qt User Interface Files are XML
line 2536: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 2537: 
line 2538: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2539: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2540: 
line 2541: " Xdg menus
line 2542: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2543: 
line 2544: " ATI graphics driver configuration
line 2545: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2546: 
line 2547: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2548: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2549: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2550: 
line 2551: " XML User Interface Language
line 2552: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2553: 
line 2554: " X11 xmodmap (also see below)
line 2555: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2556: 
line 2557: " Xquery
line 2558: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2559: 
line 2560: " XSD
line 2561: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2562: 
line 2563: " Xslt
line 2564: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2565: 
line 2566: " Yacc
line 2567: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 2568: 
line 2569: " Yacc or racc
line 2570: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()
line 2571: 
line 2572: func! s:FTy()
line 2588: 
line 2589: 
line 2590: " Yaml
line 2591: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 2592: 
line 2593: " yum conf (close enough to dosini)
line 2594: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2595: 
line 2596: " Zimbu
line 2597: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2598: " Zimbu Templates
line 2599: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 2600: 
line 2601: " Zope
line 2602: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2603: "   cpt (zope form controller page template)
line 2604: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()
line 2605: "   zsql (zope sql method)
line 2606: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()
line 2607: 
line 2608: " Z80 assembler asz80
line 2609: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2610: 
line 2611: augroup END
line 2612: 
line 2613: 
line 2614: " Source the user-specified filetype file, for backwards compatibility with
line 2615: " Vim 5.x.
line 2616: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2617:   execute "source " . myfiletypefile
line 2618: endif
line 2619: 
line 2620: 
line 2621: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2622: " when there are no matching file name extensions.
line 2623: " Don't do this for compressed files.
line 2624: augroup filetypedetect
line 2627: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2628: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2629: 
line 2630: 
line 2631: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2632: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2633: " script file.
line 2634: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2635: " like are used.
line 2636: 
line 2637: " More Apache config files
line 2638: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2639: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2640: 
line 2641: " Asterisk config file
line 2642: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2643: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2644: 
line 2645: " Bazaar version control
line 2646: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2647: 
line 2648: " Bazel build file
line 2649: if !has("fname_case")
line 2650:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl
line 2651: endif
line 2652: 
line 2653: " BIND zone
line 2654: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2655: 
line 2656: " Calendar
line 2659: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2660: 
line 2661: " Changelog
line 2667: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2668: 
line 2669: " Crontab
line 2670: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2671: 
line 2672: " dnsmasq(8) configuration
line 2673: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2674: 
line 2675: " Dracula
line 2676: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2677: 
line 2678: " Fvwm
line 2679: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2681: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2687: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2688: 
line 2689: " Gedcom
line 2690: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2691: 
line 2692: " GTK RC
line 2693: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2694: 
line 2695: " Jam
line 2696: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2697: 
line 2698: " Jargon
line 2702: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2703: 
line 2704: " Kconfig
line 2705: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2706: 
line 2707: " Lilo: Linux loader
line 2708: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2709: 
line 2710: " Logcheck
line 2711: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2712: 
line 2713: " Makefile
line 2714: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2715: 
line 2716: " Ruby Makefile
line 2717: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2718: 
line 2719: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2720: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2721: 
line 2722: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2723: 
line 2724: " Modconf
line 2728: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2729: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2730: 
line 2731: " Mutt setup file
line 2732: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2733: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2734: 
line 2735: " Nroff macros
line 2736: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2737: 
line 2738: " OpenBSD hostname.if
line 2739: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')
line 2740: 
line 2741: " Pam conf
line 2742: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2743: 
line 2744: " Printcap and Termcap
line 2748: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2752: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2753: 
line 2754: " ReDIF
line 2755: " Only used when the .rdf file was not detected to be XML.
line 2756: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()
line 2757: func! s:Redif()
line 2767: 
line 2768: " Remind
line 2769: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2770: 
line 2771: " Vim script
line 2772: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2773: 
line 2774: " Subversion commit file
line 2775: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2776: 
line 2777: " X resources file
line 2778: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2779: 
line 2780: " XFree86 config
line 2782: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2787: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2788: 
line 2789: " X11 xmodmap
line 2790: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2791: 
line 2792: " Xinetd conf
line 2793: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2794: 
line 2795: " yum conf (close enough to dosini)
line 2796: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2797: 
line 2798: " Z-Shell script
line 2799: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2800: 
line 2801: 
line 2802: " Plain text files, needs to be far down to not override others.  This avoids
line 2803: " the "conf" type being used if there is a line starting with '#'.
line 2804: au BufNewFile,BufRead *.text,README^I^Isetf text
line 2805: 
line 2806: " Help files match *.txt but should have a last line that is a modeline.
line 2810: au BufNewFile,BufRead *.txt^I  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2811: 
line 2812: 
line 2813: " Use the filetype detect plugins.  They may overrule any of the previously
line 2814: " detected filetypes.
line 2815: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/ftdetect/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftdetect/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/after/ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2816: 
line 2817: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2818: " and started another one. Let's make sure it has ended to get to a consistent
line 2819: " state.
line 2820: augroup END
line 2821: 
line 2822: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2828: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2829: 
line 2830: 
line 2831: " If the GUI is already running, may still need to install the Syntax menu.
line 2832: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2834: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2835:   source <sfile>:p:h/menu.vim
line 2836: endif
line 2837: 
line 2838: " Function called for testing all functions defined here.  These are
line 2839: " script-local, thus need to be executed here.
line 2840: " Returns a string with error messages (hopefully empty).
line 2841: func! TestFiletypeFuncs(testlist)
line 2852: 
line 2853: " Restore 'cpoptions'
line 2854: let &cpo = s:cpo_save
line 2855: unlet s:cpo_save
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
continuing in /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/filetype.vim"
Searching for "/Users/jmoussa/.vim/after/filetype.vim"
line 26:   let s:did_ft = 0
line 27: endif
line 28: 
line 29: " Set up the connection between FileType and Syntax autocommands.
line 30: " This makes the syntax automatically set when the file type is detected.
line 31: augroup syntaxset
line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")
line 33: augroup END
line 34: 
line 35: 
line 36: " Execute the syntax autocommands for the each buffer.
line 37: " If the filetype wasn't detected yet, do that now.
line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 39: " already was set manually (e.g., help buffers).
line 40: doautoall syntaxset FileType
line 41: if !s:did_ft
line 42:   doautoall filetypedetect BufRead
line 43: endif
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim
continuing in /Users/jmoussa/.vimrc
line 5: set background=dark
Searching for "syntax/syncolor.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/syntax/syncolor.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 5: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim
continuing in /Users/jmoussa/.vimrc
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/Users/jmoussa/.vim/after/syntax/syncolor.vim"
line 6: colorscheme solarized
Searching for "colors/solarized.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/colors/solarized.vim"
chdir(/Users/jmoussa/.vim/colors)
fchdir() to previous dir
line 6: sourcing "/Users/jmoussa/.vim/colors/solarized.vim"
line 1: " Name:     Solarized vim colorscheme
line 2: " Author:   Ethan Schoonover <es@ethanschoonover.com>
line 3: " URL:      http://ethanschoonover.com/solarized
line 4: "           (see this url for latest release & screenshots)
line 5: " License:  OSI approved MIT license (see end of this file)
line 6: " Created:  In the middle of the night
line 7: " Modified: 2011 Apr 14
line 8: "
line 9: " Usage "{{{
line 10: "
line 11: " ---------------------------------------------------------------------
line 12: " ABOUT:
line 13: " ---------------------------------------------------------------------
line 14: " Solarized is a carefully designed selective contrast colorscheme with dual
line 15: " light and dark modes that runs in both GUI, 256 and 16 color modes.
line 16: "
line 17: " See the homepage above for screenshots and details.
line 18: "
line 19: " ---------------------------------------------------------------------
line 20: " INSTALLATION:
line 21: " ---------------------------------------------------------------------
line 22: "
line 23: " Two options for installation: manual or pathogen
line 24: "
line 25: " MANUAL INSTALLATION OPTION:
line 26: " ---------------------------------------------------------------------
line 27: "
line 28: " 1.  Put the files in the right place!
line 29: " 2.  Move `solarized.vim` to your `.vim/colors` directory.
line 30: "
line 31: " RECOMMENDED PATHOGEN INSTALLATION OPTION:
line 32: " ---------------------------------------------------------------------
line 33: "
line 34: " 1.  Download and install Tim Pope's Pathogen from:
line 35: "     https://github.com/tpope/vim-pathogen
line 36: "
line 37: " 2.  Next, move or clone the `vim-colors-solarized` directory so that it is
line 38: "     a subdirectory of the `.vim/bundle` directory.
line 39: "
line 40: "     a. **clone with git:**
line 41: "
line 42: "       $ cd ~/.vim/bundle
line 43: "       $ git clone git://github.com/altercation/vim-colors-solarized.git
line 44: "
line 45: "     b. **or move manually into the pathogen bundle directory:**
line 46: "         In the parent directory of vim-colors-solarized:
line 47: "
line 48: "         $ mv vim-colors-solarized ~/.vim/bundle/
line 49: "
line 50: " MODIFY VIMRC:
line 51: "
line 52: " After either Option 1 or Option 2 above, put the following two lines in your
line 53: " .vimrc:
line 54: "
line 55: "     syntax enable
line 56: "     set background=dark
line 57: "     colorscheme solarized
line 58: "
line 59: " or, for the light background mode of Solarized:
line 60: "
line 61: "     syntax enable
line 62: "     set background=light
line 63: "     colorscheme solarized
line 64: "
line 65: " I like to have a different background in GUI and terminal modes, so I can use
line 66: " the following if-then. However, I find vim's background autodetection to be
line 67: " pretty good and, at least with MacVim, I can leave this background value
line 68: " assignment out entirely and get the same results.
line 69: "
line 70: "     if has('gui_running')
line 71: "       set background=light
line 72: "     else
line 73: "       set background=dark
line 74: "     endif
line 75: "
line 76: " See the Solarized homepage at http://ethanschoonover.com/solarized for
line 77: " screenshots which will help you select either the light or dark background.
line 78: "
line 79: " Other options are detailed below.
line 80: "
line 81: " IMPORTANT NOTE FOR TERMINAL USERS:
line 82: " 
line 83: " If you are going to use Solarized in Terminal mode (i.e. not in a GUI version 
line 84: " like gvim or macvim), **please please please** consider setting your terminal 
line 85: " emulator's colorscheme to used the Solarized palette. I've included palettes 
line 86: " for some popular terminal emulator as well as Xdefaults in the official 
line 87: " Solarized download available from [Solarized homepage]. If you use 
line 88: " Solarized *without* these colors, Solarized will need to be told to degrade
line 89: " its colorscheme to a set compatible with the limited 256 terminal palette 
line 90: " (whereas by using the terminal's 16 ansi color values, you can set the 
line 91: " correct, specific values for the Solarized palette).
line 92: " 
line 93: " If you do use the custom terminal colors, solarized.vim should work out of 
line 94: " the box for you. If you are using a terminal emulator that supports 256 
line 95: " colors and don't want to use the custom Solarized terminal colors, you will 
line 96: " need to use the degraded 256 colorscheme. To do so, simply add the following 
line 97: " line *before* the `colorschem solarized` line:
line 98: " 
line 99: "     let g:solarized_termcolors=256
line 100: " 
line 101: " Again, I recommend just changing your terminal colors to Solarized values 
line 102: " either manually or via one of the many terminal schemes available for import.
line 103: "
line 104: " ---------------------------------------------------------------------
line 105: " TOGGLE BACKGROUND FUNCTION:
line 106: " ---------------------------------------------------------------------
line 107: " 
line 108: " Solarized comes with a Toggle Background plugin that by default will map to 
line 109: " <F5> if that mapping is available. If it is not available you will need to 
line 110: " either map the function manually or change your current <F5> mapping to 
line 111: " something else. If you wish to map the function manually, enter the following 
line 112: " lines in your .vimrc:
line 113: " 
line 114: "     nmap <unique> <F5> <Plug>ToggleBackground
line 115: "     imap <unique> <F5> <Plug>ToggleBackground
line 116: "     vmap <unique> <F5> <Plug>ToggleBackground
line 117: " 
line 118: " Note that it is important to *not* use the noremap map variants. The plugin 
line 119: " uses noremap internally. You may run `:help togglebg` for more information.
line 120: "
line 121: " ---------------------------------------------------------------------
line 122: " OPTIONS
line 123: " ---------------------------------------------------------------------
line 124: "
line 125: " Set these in your vimrc file prior to calling the colorscheme.
line 126: "
line 127: " option name               default     optional
line 128: " ------------------------------------------------
line 129: " g:solarized_termcolors=   16      |   256
line 130: " g:solarized_termtrans =   0       |   1
line 131: " g:solarized_degrade   =   0       |   1
line 132: " g:solarized_bold      =   1       |   0
line 133: " g:solarized_underline =   1       |   0
line 134: " g:solarized_italic    =   1       |   0
line 135: " g:solarized_contrast  =   "normal"|   "high" or "low"
line 136: " g:solarized_visibility=   "normal"|   "high" or "low"
line 137: " ------------------------------------------------
line 138: "
line 139: " OPTION DETAILS
line 140: "
line 141: " ------------------------------------------------
line 142: " g:solarized_termcolors=   256     |   16
line 143: " ------------------------------------------------
line 144: " The most important option if you are using vim in terminal (non gui) mode!
line 145: " This tells Solarized to use the 256 degraded color mode if running in a 256
line 146: " color capable terminal.  Otherwise, if set to `16` it will use the terminal
line 147: " emulators colorscheme (best option as long as you've set the emulators colors
line 148: " to the Solarized palette).
line 149: "
line 150: " If you are going to use Solarized in Terminal mode (i.e. not in a GUI
line 151: " version like gvim or macvim), **please please please** consider setting your
line 152: " terminal emulator's colorscheme to used the Solarized palette. I've included
line 153: " palettes for some popular terminal emulator as well as Xdefaults in the
line 154: " official Solarized download available from:
line 155: " http://ethanschoonover.com/solarized . If you use Solarized without these
line 156: " colors, Solarized will by default use an approximate set of 256 colors.  It
line 157: " isn't bad looking and has been extensively tweaked, but it's still not quite
line 158: " the real thing.
line 159: "
line 160: " ------------------------------------------------
line 161: " g:solarized_termtrans =   0       |   1
line 162: " ------------------------------------------------
line 163: " If you use a terminal emulator with a transparent background and Solarized
line 164: " isn't displaying the background color transparently, set this to 1 and
line 165: " Solarized will use the default (transparent) background of the terminal
line 166: " emulator. *urxvt* required this in my testing; iTerm2 did not.
line 167: "
line 168: " Note that on Mac OS X Terminal.app, solarized_termtrans is set to 1 by 
line 169: " default as this is almost always the best option. The only exception to this 
line 170: " is if the working terminfo file supports 256 colors (xterm-256color).
line 171: "
line 172: " ------------------------------------------------
line 173: " g:solarized_degrade   =   0       |   1
line 174: " ------------------------------------------------
line 175: " For test purposes only; forces Solarized to use the 256 degraded color mode
line 176: " to test the approximate color values for accuracy.
line 177: "
line 178: " ------------------------------------------------
line 179: " g:solarized_bold      =   1       |   0
line 180: " ------------------------------------------------
line 181: " ------------------------------------------------
line 182: " g:solarized_underline =   1       |   0
line 183: " ------------------------------------------------
line 184: " ------------------------------------------------
line 185: " g:solarized_italic    =   1       |   0
line 186: " ------------------------------------------------
line 187: " If you wish to stop Solarized from displaying bold, underlined or
line 188: " italicized typefaces, simply assign a zero value to the appropriate
line 189: " variable, for example: `let g:solarized_italic=0`
line 190: "
line 191: " ------------------------------------------------
line 192: " g:solarized_contrast  =   "normal"|   "high" or "low"
line 193: " ------------------------------------------------
line 194: " Stick with normal! It's been carefully tested. Setting this option to high
line 195: " or low does use the same Solarized palette but simply shifts some values up
line 196: " or down in order to expand or compress the tonal range displayed.
line 197: "
line 198: " ------------------------------------------------
line 199: " g:solarized_visibility =  "normal"|   "high" or "low"
line 200: " ------------------------------------------------
line 201: " Special characters such as trailing whitespace, tabs, newlines, when 
line 202: " displayed using ":set list" can be set to one of three levels depending on 
line 203: " your needs.
line 204: "
line 205: " ---------------------------------------------------------------------
line 206: " COLOR VALUES
line 207: " ---------------------------------------------------------------------
line 208: " Download palettes and files from: http://ethanschoonover.com/solarized
line 209: "
line 210: " L\*a\*b values are canonical (White D65, Reference D50), other values are
line 211: " matched in sRGB space.
line 212: "
line 213: " SOLARIZED HEX     16/8 TERMCOL  XTERM/HEX   L*A*B      sRGB        HSB
line 214: " --------- ------- ---- -------  ----------- ---------- ----------- -----------
line 215: " base03    #002b36  8/4 brblack  234 #1c1c1c 15 -12 -12   0  43  54 193 100  21
line 216: " base02    #073642  0/4 black    235 #262626 20 -12 -12   7  54  66 192  90  26
line 217: " base01    #586e75 10/7 brgreen  240 #4e4e4e 45 -07 -07  88 110 117 194  25  46
line 218: " base00    #657b83 11/7 bryellow 241 #585858 50 -07 -07 101 123 131 195  23  51
line 219: " base0     #839496 12/6 brblue   244 #808080 60 -06 -03 131 148 150 186  13  59
line 220: " base1     #93a1a1 14/4 brcyan   245 #8a8a8a 65 -05 -02 147 161 161 180   9  63
line 221: " base2     #eee8d5  7/7 white    254 #d7d7af 92 -00  10 238 232 213  44  11  93
line 222: " base3     #fdf6e3 15/7 brwhite  230 #ffffd7 97  00  10 253 246 227  44  10  99
line 223: " yellow    #b58900  3/3 yellow   136 #af8700 60  10  65 181 137   0  45 100  71
line 224: " orange    #cb4b16  9/3 brred    166 #d75f00 50  50  55 203  75  22  18  89  80
line 225: " red       #dc322f  1/1 red      160 #d70000 50  65  45 220  50  47   1  79  86
line 226: " magenta   #d33682  5/5 magenta  125 #af005f 50  65 -05 211  54 130 331  74  83
line 227: " violet    #6c71c4 13/5 brmagenta 61 #5f5faf 50  15 -45 108 113 196 237  45  77
line 228: " blue      #268bd2  4/4 blue      33 #0087ff 55 -10 -45  38 139 210 205  82  82
line 229: " cyan      #2aa198  6/6 cyan      37 #00afaf 60 -35 -05  42 161 152 175  74  63
line 230: " green     #859900  2/2 green     64 #5f8700 60 -20  65 133 153   0  68 100  60
line 231: "
line 232: " ---------------------------------------------------------------------
line 233: " COLORSCHEME HACKING
line 234: " ---------------------------------------------------------------------
line 235: "
line 236: " Useful commands for testing colorschemes:
line 237: " :source $VIMRUNTIME/syntax/hitest.vim
line 238: " :help highlight-groups
line 239: " :help cterm-colors
line 240: " :help group-name
line 241: "
line 242: " Useful links for developing colorschemes:
line 243: " http://www.vim.org/scripts/script.php?script_id=2937
line 244: " http://vimcasts.org/episodes/creating-colorschemes-for-vim/
line 245: " http://www.frexx.de/xterm-256-notes/"
line 246: "
line 247: "
line 248: " }}}
line 249: " Default option values"{{{
line 250: " ---------------------------------------------------------------------
line 251: if !exists("g:solarized_termtrans")
line 252:     if ($TERM_PROGRAM ==? "apple_terminal" && &t_Co < 256)
line 253:         let g:solarized_termtrans = 1
line 254:     else
line 255:         let g:solarized_termtrans = 0
line 256:     endif
line 257: endif
line 258: if !exists("g:solarized_degrade")
line 259:     let g:solarized_degrade = 0
line 260: endif
line 261: if !exists("g:solarized_bold")
line 262:     let g:solarized_bold = 1
line 263: endif
line 264: if !exists("g:solarized_underline")
line 265:     let g:solarized_underline = 1
line 266: endif
line 267: if !exists("g:solarized_italic")
line 268:     let g:solarized_italic = 1
line 269: endif
line 270: if !exists("g:solarized_termcolors")
line 271:     let g:solarized_termcolors = 16
line 272: endif
line 273: if !exists("g:solarized_contrast")
line 274:     let g:solarized_contrast = "normal"
line 275: endif
line 276: if !exists("g:solarized_visibility")
line 277:     let g:solarized_visibility = "normal"
line 278: endif
line 279: "}}}
line 280: " Colorscheme initialization "{{{
line 281: " ---------------------------------------------------------------------
line 282: hi clear
Searching for "syntax/syncolor.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/syntax/syncolor.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 282: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim
continuing in /Users/jmoussa/.vim/colors/solarized.vim
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/Users/jmoussa/.vim/after/syntax/syncolor.vim"
line 283: if exists("syntax_on")
line 284:   syntax reset
line 284: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/syntax/syncolor.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/syntax/syncolor.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax)
fchdir() to previous dir
line 284: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 3: " Last Change:^I2001 Sep 12
line 4: 
line 5: " This file sets up the default methods for highlighting.
line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 7: " Also used from init_highlight().
line 8: 
line 9: if !exists("syntax_cmd") || syntax_cmd == "on"
line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 11:   command -nargs=* SynColor hi <args>
line 12:   command -nargs=* SynLink hi link <args>
line 13: else
line 14:   if syntax_cmd == "enable"
line 15:     " ":syntax enable" keeps any existing colors
line 16:     command -nargs=* SynColor hi def <args>
line 17:     command -nargs=* SynLink hi def link <args>
line 18:   elseif syntax_cmd == "reset"
line 19:     " ":syntax reset" resets all colors to the default
line 20:     command -nargs=* SynColor hi <args>
line 21:     command -nargs=* SynLink hi! link <args>
line 22:   else
line 23:     " User defined syncolor file has already set the colors.
line 24:     finish
line 25:   endif
line 26: endif
line 27: 
line 28: " Many terminals can only use six different colors (plus black and white).
line 29: " Therefore the number of colors used is kept low. It doesn't look nice with
line 30: " too many colors anyway.
line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 32: " There are two sets of defaults: for a dark and a light background.
line 33: if &background == "dark"
line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 34: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 35: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 36: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 37: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 38: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 39: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 40: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 41: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 42: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: else
line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 53: endif
line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 54: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 55: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 56: 
line 57: " Common groups that link to default highlighting.
line 58: " You can specify other highlighting easily.
line 59: SynLink String^I^IConstant
line 59: hi! link String^I^IConstant
line 60: SynLink Character^IConstant
line 60: hi! link Character^IConstant
line 61: SynLink Number^I^IConstant
line 61: hi! link Number^I^IConstant
line 62: SynLink Boolean^I^IConstant
line 62: hi! link Boolean^I^IConstant
line 63: SynLink Float^I^INumber
line 63: hi! link Float^I^INumber
line 64: SynLink Function^IIdentifier
line 64: hi! link Function^IIdentifier
line 65: SynLink Conditional^IStatement
line 65: hi! link Conditional^IStatement
line 66: SynLink Repeat^I^IStatement
line 66: hi! link Repeat^I^IStatement
line 67: SynLink Label^I^IStatement
line 67: hi! link Label^I^IStatement
line 68: SynLink Operator^IStatement
line 68: hi! link Operator^IStatement
line 69: SynLink Keyword^I^IStatement
line 69: hi! link Keyword^I^IStatement
line 70: SynLink Exception^IStatement
line 70: hi! link Exception^IStatement
line 71: SynLink Include^I^IPreProc
line 71: hi! link Include^I^IPreProc
line 72: SynLink Define^I^IPreProc
line 72: hi! link Define^I^IPreProc
line 73: SynLink Macro^I^IPreProc
line 73: hi! link Macro^I^IPreProc
line 74: SynLink PreCondit^IPreProc
line 74: hi! link PreCondit^IPreProc
line 75: SynLink StorageClass^IType
line 75: hi! link StorageClass^IType
line 76: SynLink Structure^IType
line 76: hi! link Structure^IType
line 77: SynLink Typedef^I^IType
line 77: hi! link Typedef^I^IType
line 78: SynLink Tag^I^ISpecial
line 78: hi! link Tag^I^ISpecial
line 79: SynLink SpecialChar^ISpecial
line 79: hi! link SpecialChar^ISpecial
line 80: SynLink Delimiter^ISpecial
line 80: hi! link Delimiter^ISpecial
line 81: SynLink SpecialComment^ISpecial
line 81: hi! link SpecialComment^ISpecial
line 82: SynLink Debug^I^ISpecial
line 82: hi! link Debug^I^ISpecial
line 83: 
line 84: delcommand SynColor
line 85: delcommand SynLink
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim
continuing in /Users/jmoussa/.vim/colors/solarized.vim
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/syntax/syncolor.vim"
Searching for "/Users/jmoussa/.vim/after/syntax/syncolor.vim"
line 285: endif
line 286: let colors_name = "solarized"
line 287: 
line 288: "}}}
line 289: " GUI & CSApprox hexadecimal palettes"{{{
line 290: " ---------------------------------------------------------------------
line 291: "
line 292: " Set both gui and terminal color values in separate conditional statements
line 293: " Due to possibility that CSApprox is running (though I suppose we could just
line 294: " leave the hex values out entirely in that case and include only cterm colors)
line 295: " We also check to see if user has set solarized (force use of the
line 296: " neutral gray monotone palette component)
line 297: if (has("gui_running") && g:solarized_degrade == 0)
line 298:     let s:vmode       = "gui"
line 299:     let s:base03      = "#002b36"
line 300:     let s:base02      = "#073642"
line 301:     let s:base01      = "#586e75"
line 302:     let s:base00      = "#657b83"
line 303:     let s:base0       = "#839496"
line 304:     let s:base1       = "#93a1a1"
line 305:     let s:base2       = "#eee8d5"
line 306:     let s:base3       = "#fdf6e3"
line 307:     let s:yellow      = "#b58900"
line 308:     let s:orange      = "#cb4b16"
line 309:     let s:red         = "#dc322f"
line 310:     let s:magenta     = "#d33682"
line 311:     let s:violet      = "#6c71c4"
line 312:     let s:blue        = "#268bd2"
line 313:     let s:cyan        = "#2aa198"
line 314:     let s:green       = "#859900"
line 315: elseif (has("gui_running") && g:solarized_degrade == 1)
line 316:     " These colors are identical to the 256 color mode. They may be viewed
line 317:     " while in gui mode via "let g:solarized_degrade=1", though this is not
line 318:     " recommened and is for testing only.
line 319:     let s:vmode       = "gui"
line 320:     let s:base03      = "#1c1c1c"
line 321:     let s:base02      = "#262626"
line 322:     let s:base01      = "#4e4e4e"
line 323:     let s:base00      = "#585858"
line 324:     let s:base0       = "#808080"
line 325:     let s:base1       = "#8a8a8a"
line 326:     let s:base2       = "#d7d7af"
line 327:     let s:base3       = "#ffffd7"
line 328:     let s:yellow      = "#af8700"
line 329:     let s:orange      = "#d75f00"
line 330:     let s:red         = "#af0000"
line 331:     let s:magenta     = "#af005f"
line 332:     let s:violet      = "#5f5faf"
line 333:     let s:blue        = "#0087ff"
line 334:     let s:cyan        = "#00afaf"
line 335:     let s:green       = "#5f8700"
line 336: elseif g:solarized_termcolors != 256 && &t_Co >= 16
line 337:     let s:vmode       = "cterm"
line 338:     let s:base03      = "8"
line 339:     let s:base02      = "0"
line 340:     let s:base01      = "10"
line 341:     let s:base00      = "11"
line 342:     let s:base0       = "12"
line 343:     let s:base1       = "14"
line 344:     let s:base2       = "7"
line 345:     let s:base3       = "15"
line 346:     let s:yellow      = "3"
line 347:     let s:orange      = "9"
line 348:     let s:red         = "1"
line 349:     let s:magenta     = "5"
line 350:     let s:violet      = "13"
line 351:     let s:blue        = "4"
line 352:     let s:cyan        = "6"
line 353:     let s:green       = "2"
line 354: elseif g:solarized_termcolors == 256
line 355:     let s:vmode       = "cterm"
line 356:     let s:base03      = "234"
line 357:     let s:base02      = "235"
line 358:     let s:base01      = "239"
line 359:     let s:base00      = "240"
line 360:     let s:base0       = "244"
line 361:     let s:base1       = "245"
line 362:     let s:base2       = "187"
line 363:     let s:base3       = "230"
line 364:     let s:yellow      = "136"
line 365:     let s:orange      = "166"
line 366:     let s:red         = "124"
line 367:     let s:magenta     = "125"
line 368:     let s:violet      = "61"
line 369:     let s:blue        = "33"
line 370:     let s:cyan        = "37"
line 371:     let s:green       = "64"
line 372: else
line 373:     let s:vmode       = "cterm"
line 374:     let s:bright      = "* term=bold cterm=bold"
line 375:     let s:base03      = "0".s:bright
line 376:     let s:base02      = "0"
line 377:     let s:base01      = "2".s:bright
line 378:     let s:base00      = "3".s:bright
line 379:     let s:base0       = "4".s:bright
line 380:     let s:base1       = "6".s:bright
line 381:     let s:base2       = "7"
line 382:     let s:base3       = "7".s:bright
line 383:     let s:yellow      = "3"
line 384:     let s:orange      = "1".s:bright
line 385:     let s:red         = "1"
line 386:     let s:magenta     = "5"
line 387:     let s:violet      = "13"
line 388:     let s:blue        = "4"
line 389:     let s:cyan        = "6"
line 390:     let s:green       = "2"
line 391: endif
line 392: "}}}
line 393: " Formatting options and null values for passthrough effect "{{{
line 394: " ---------------------------------------------------------------------
line 395:     let s:none            = "NONE"
line 396:     let s:none            = "NONE"
line 397:     let s:t_none          = "NONE"
line 398:     let s:n               = "NONE"
line 399:     let s:c               = ",undercurl"
line 400:     let s:r               = ",reverse"
line 401:     let s:s               = ",standout"
line 402:     let s:ou              = ""
line 403:     let s:ob              = ""
line 404: "}}}
line 405: " Background value based on termtrans setting "{{{
line 406: " ---------------------------------------------------------------------
line 407: if (has("gui_running") || g:solarized_termtrans == 0)
line 408:     let s:back        = s:base03
line 409: else
line 410:     let s:back        = "NONE"
line 411: endif
line 412: "}}}
line 413: " Alternate light scheme "{{{
line 414: " ---------------------------------------------------------------------
line 415: if &background == "light"
line 416:     let s:temp03      = s:base03
line 417:     let s:temp02      = s:base02
line 418:     let s:temp01      = s:base01
line 419:     let s:temp00      = s:base00
line 420:     let s:base03      = s:base3
line 421:     let s:base02      = s:base2
line 422:     let s:base01      = s:base1
line 423:     let s:base00      = s:base0
line 424:     let s:base0       = s:temp00
line 425:     let s:base1       = s:temp01
line 426:     let s:base2       = s:temp02
line 427:     let s:base3       = s:temp03
line 428:     if (s:back != "NONE")
line 429:         let s:back    = s:base03
line 430:     endif
line 431: endif
line 432: "}}}
line 433: " Optional contrast schemes "{{{
line 434: " ---------------------------------------------------------------------
line 435: if g:solarized_contrast == "high"
line 436:     let s:base01      = s:base00
line 437:     let s:base00      = s:base0
line 438:     let s:base0       = s:base1
line 439:     let s:base1       = s:base2
line 440:     let s:base2       = s:base3
line 441:     let s:back        = s:back
line 442: endif
line 443: if g:solarized_contrast == "low"
line 444:     let s:back        = s:base02
line 445:     let s:ou          = ",underline"
line 446: endif
line 447: "}}}
line 448: " Overrides dependent on user specified values"{{{
line 449: " ---------------------------------------------------------------------
line 450: if g:solarized_bold == 1
line 451:     let s:b           = ",bold"
line 452: else
line 453:     let s:b           = ""
line 454: endif
line 455: 
line 456: if g:solarized_underline == 1
line 457:     let s:u           = ",underline"
line 458: else
line 459:     let s:u           = ""
line 460: endif
line 461: 
line 462: if g:solarized_italic == 1
line 463:     let s:i           = ",italic"
line 464: else
line 465:     let s:i           = ""
line 466: endif
line 467: "}}}
line 468: " Highlighting primitives"{{{
line 469: " ---------------------------------------------------------------------
line 470: 
line 471: exe "let s:bg_none      = ' ".s:vmode."bg=".s:none   ."'"
line 471: let s:bg_none      = ' ctermbg=NONE'
line 472: exe "let s:bg_back      = ' ".s:vmode."bg=".s:back   ."'"
line 472: let s:bg_back      = ' ctermbg=8'
line 473: exe "let s:bg_base03    = ' ".s:vmode."bg=".s:base03 ."'"
line 473: let s:bg_base03    = ' ctermbg=8'
line 474: exe "let s:bg_base02    = ' ".s:vmode."bg=".s:base02 ."'"
line 474: let s:bg_base02    = ' ctermbg=0'
line 475: exe "let s:bg_base01    = ' ".s:vmode."bg=".s:base01 ."'"
line 475: let s:bg_base01    = ' ctermbg=10'
line 476: exe "let s:bg_base00    = ' ".s:vmode."bg=".s:base00 ."'"
line 476: let s:bg_base00    = ' ctermbg=11'
line 477: exe "let s:bg_base0     = ' ".s:vmode."bg=".s:base0  ."'"
line 477: let s:bg_base0     = ' ctermbg=12'
line 478: exe "let s:bg_base1     = ' ".s:vmode."bg=".s:base1  ."'"
line 478: let s:bg_base1     = ' ctermbg=14'
line 479: exe "let s:bg_base2     = ' ".s:vmode."bg=".s:base2  ."'"
line 479: let s:bg_base2     = ' ctermbg=7'
line 480: exe "let s:bg_base3     = ' ".s:vmode."bg=".s:base3  ."'"
line 480: let s:bg_base3     = ' ctermbg=15'
line 481: exe "let s:bg_green     = ' ".s:vmode."bg=".s:green  ."'"
line 481: let s:bg_green     = ' ctermbg=2'
line 482: exe "let s:bg_yellow    = ' ".s:vmode."bg=".s:yellow ."'"
line 482: let s:bg_yellow    = ' ctermbg=3'
line 483: exe "let s:bg_orange    = ' ".s:vmode."bg=".s:orange ."'"
line 483: let s:bg_orange    = ' ctermbg=9'
line 484: exe "let s:bg_red       = ' ".s:vmode."bg=".s:red    ."'"
line 484: let s:bg_red       = ' ctermbg=1'
line 485: exe "let s:bg_magenta   = ' ".s:vmode."bg=".s:magenta."'"
line 485: let s:bg_magenta   = ' ctermbg=5'
line 486: exe "let s:bg_violet    = ' ".s:vmode."bg=".s:violet ."'"
line 486: let s:bg_violet    = ' ctermbg=13'
line 487: exe "let s:bg_blue      = ' ".s:vmode."bg=".s:blue   ."'"
line 487: let s:bg_blue      = ' ctermbg=4'
line 488: exe "let s:bg_cyan      = ' ".s:vmode."bg=".s:cyan   ."'"
line 488: let s:bg_cyan      = ' ctermbg=6'
line 489: 
line 490: exe "let s:fg_none      = ' ".s:vmode."fg=".s:none   ."'"
line 490: let s:fg_none      = ' ctermfg=NONE'
line 491: exe "let s:fg_back      = ' ".s:vmode."fg=".s:back   ."'"
line 491: let s:fg_back      = ' ctermfg=8'
line 492: exe "let s:fg_base03    = ' ".s:vmode."fg=".s:base03 ."'"
line 492: let s:fg_base03    = ' ctermfg=8'
line 493: exe "let s:fg_base02    = ' ".s:vmode."fg=".s:base02 ."'"
line 493: let s:fg_base02    = ' ctermfg=0'
line 494: exe "let s:fg_base01    = ' ".s:vmode."fg=".s:base01 ."'"
line 494: let s:fg_base01    = ' ctermfg=10'
line 495: exe "let s:fg_base00    = ' ".s:vmode."fg=".s:base00 ."'"
line 495: let s:fg_base00    = ' ctermfg=11'
line 496: exe "let s:fg_base0     = ' ".s:vmode."fg=".s:base0  ."'"
line 496: let s:fg_base0     = ' ctermfg=12'
line 497: exe "let s:fg_base1     = ' ".s:vmode."fg=".s:base1  ."'"
line 497: let s:fg_base1     = ' ctermfg=14'
line 498: exe "let s:fg_base2     = ' ".s:vmode."fg=".s:base2  ."'"
line 498: let s:fg_base2     = ' ctermfg=7'
line 499: exe "let s:fg_base3     = ' ".s:vmode."fg=".s:base3  ."'"
line 499: let s:fg_base3     = ' ctermfg=15'
line 500: exe "let s:fg_green     = ' ".s:vmode."fg=".s:green  ."'"
line 500: let s:fg_green     = ' ctermfg=2'
line 501: exe "let s:fg_yellow    = ' ".s:vmode."fg=".s:yellow ."'"
line 501: let s:fg_yellow    = ' ctermfg=3'
line 502: exe "let s:fg_orange    = ' ".s:vmode."fg=".s:orange ."'"
line 502: let s:fg_orange    = ' ctermfg=9'
line 503: exe "let s:fg_red       = ' ".s:vmode."fg=".s:red    ."'"
line 503: let s:fg_red       = ' ctermfg=1'
line 504: exe "let s:fg_magenta   = ' ".s:vmode."fg=".s:magenta."'"
line 504: let s:fg_magenta   = ' ctermfg=5'
line 505: exe "let s:fg_violet    = ' ".s:vmode."fg=".s:violet ."'"
line 505: let s:fg_violet    = ' ctermfg=13'
line 506: exe "let s:fg_blue      = ' ".s:vmode."fg=".s:blue   ."'"
line 506: let s:fg_blue      = ' ctermfg=4'
line 507: exe "let s:fg_cyan      = ' ".s:vmode."fg=".s:cyan   ."'"
line 507: let s:fg_cyan      = ' ctermfg=6'
line 508: 
line 509: exe "let s:fmt_none     = ' ".s:vmode."=NONE".          " term=NONE".    "'"
line 509: let s:fmt_none     = ' cterm=NONE term=NONE'
line 510: exe "let s:fmt_bold     = ' ".s:vmode."=NONE".s:b.      " term=NONE".s:b."'"
line 510: let s:fmt_bold     = ' cterm=NONE,bold term=NONE,bold'
line 511: exe "let s:fmt_bldi     = ' ".s:vmode."=NONE".s:b.      " term=NONE".s:b."'"
line 511: let s:fmt_bldi     = ' cterm=NONE,bold term=NONE,bold'
line 512: exe "let s:fmt_undr     = ' ".s:vmode."=NONE".s:u.      " term=NONE".s:u."'"
line 512: let s:fmt_undr     = ' cterm=NONE,underline term=NONE,underline'
line 513: exe "let s:fmt_undb     = ' ".s:vmode."=NONE".s:u.s:b.  " term=NONE".s:u.s:b."'"
line 513: let s:fmt_undb     = ' cterm=NONE,underline,bold term=NONE,underline,bold'
line 514: exe "let s:fmt_undi     = ' ".s:vmode."=NONE".s:u.      " term=NONE".s:u."'"
line 514: let s:fmt_undi     = ' cterm=NONE,underline term=NONE,underline'
line 515: exe "let s:fmt_uopt     = ' ".s:vmode."=NONE".s:ou.     " term=NONE".s:ou."'"
line 515: let s:fmt_uopt     = ' cterm=NONE term=NONE'
line 516: exe "let s:fmt_curl     = ' ".s:vmode."=NONE".s:c.      " term=NONE".s:c."'"
line 516: let s:fmt_curl     = ' cterm=NONE,undercurl term=NONE,undercurl'
line 517: exe "let s:fmt_ital     = ' ".s:vmode."=NONE".          " term=NONE".    "'"
line 517: let s:fmt_ital     = ' cterm=NONE term=NONE'
line 518: exe "let s:fmt_revr     = ' ".s:vmode."=NONE".s:r.      " term=NONE".s:r."'"
line 518: let s:fmt_revr     = ' cterm=NONE,reverse term=NONE,reverse'
line 519: exe "let s:fmt_stnd     = ' ".s:vmode."=NONE".s:s.      " term=NONE".s:s."'"
line 519: let s:fmt_stnd     = ' cterm=NONE,standout term=NONE,standout'
line 520: 
line 521: if has("gui_running")
line 522:     exe "let s:sp_none      = ' guisp=".s:none   ."'"
line 523:     exe "let s:sp_back      = ' guisp=".s:back   ."'"
line 524:     exe "let s:sp_base03    = ' guisp=".s:base03 ."'"
line 525:     exe "let s:sp_base02    = ' guisp=".s:base02 ."'"
line 526:     exe "let s:sp_base01    = ' guisp=".s:base01 ."'"
line 527:     exe "let s:sp_base00    = ' guisp=".s:base00 ."'"
line 528:     exe "let s:sp_base0     = ' guisp=".s:base0  ."'"
line 529:     exe "let s:sp_base1     = ' guisp=".s:base1  ."'"
line 530:     exe "let s:sp_base2     = ' guisp=".s:base2  ."'"
line 531:     exe "let s:sp_base3     = ' guisp=".s:base3  ."'"
line 532:     exe "let s:sp_green     = ' guisp=".s:green  ."'"
line 533:     exe "let s:sp_yellow    = ' guisp=".s:yellow ."'"
line 534:     exe "let s:sp_orange    = ' guisp=".s:orange ."'"
line 535:     exe "let s:sp_red       = ' guisp=".s:red    ."'"
line 536:     exe "let s:sp_magenta   = ' guisp=".s:magenta."'"
line 537:     exe "let s:sp_violet    = ' guisp=".s:violet ."'"
line 538:     exe "let s:sp_blue      = ' guisp=".s:blue   ."'"
line 539:     exe "let s:sp_cyan      = ' guisp=".s:cyan   ."'"
line 540: else
line 541:     let s:sp_none      = ""
line 542:     let s:sp_back      = ""
line 543:     let s:sp_base03    = ""
line 544:     let s:sp_base02    = ""
line 545:     let s:sp_base01    = ""
line 546:     let s:sp_base00    = ""
line 547:     let s:sp_base0     = ""
line 548:     let s:sp_base1     = ""
line 549:     let s:sp_base2     = ""
line 550:     let s:sp_base3     = ""
line 551:     let s:sp_green     = ""
line 552:     let s:sp_yellow    = ""
line 553:     let s:sp_orange    = ""
line 554:     let s:sp_red       = ""
line 555:     let s:sp_magenta   = ""
line 556:     let s:sp_violet    = ""
line 557:     let s:sp_blue      = ""
line 558:     let s:sp_cyan      = ""
line 559: endif
line 560: 
line 561: "}}}
line 562: " Basic highlighting"{{{
line 563: " ---------------------------------------------------------------------
line 564: " note that link syntax to avoid duplicate configuration doesn't work with the
line 565: " exe compiled formats
line 566: 
line 567: exe "hi! Normal"         .s:fmt_none   .s:fg_base0  .s:bg_back
line 567: hi! Normal cterm=NONE term=NONE ctermfg=12 ctermbg=8
line 568: 
line 569: exe "hi! Comment"        .s:fmt_ital   .s:fg_base01 .s:bg_none
line 569: hi! Comment cterm=NONE term=NONE ctermfg=10 ctermbg=NONE
line 570: "       *Comment         any comment
line 571: 
line 572: exe "hi! Constant"       .s:fmt_none   .s:fg_cyan   .s:bg_none
line 572: hi! Constant cterm=NONE term=NONE ctermfg=6 ctermbg=NONE
line 573: "       *Constant        any constant
line 574: "        String          a string constant: "this is a string"
line 575: "        Character       a character constant: 'c', '\n'
line 576: "        Number          a number constant: 234, 0xff
line 577: "        Boolean         a boolean constant: TRUE, false
line 578: "        Float           a floating point constant: 2.3e10
line 579: 
line 580: exe "hi! Identifier"     .s:fmt_none   .s:fg_blue   .s:bg_none
line 580: hi! Identifier cterm=NONE term=NONE ctermfg=4 ctermbg=NONE
line 581: "       *Identifier      any variable name
line 582: "        Function        function name (also: methods for classes)
line 583: "
line 584: exe "hi! Statement"      .s:fmt_none   .s:fg_green  .s:bg_none
line 584: hi! Statement cterm=NONE term=NONE ctermfg=2 ctermbg=NONE
line 585: "       *Statement       any statement
line 586: "        Conditional     if, then, else, endif, switch, etc.
line 587: "        Repeat          for, do, while, etc.
line 588: "        Label           case, default, etc.
line 589: "        Operator        "sizeof", "+", "*", etc.
line 590: "        Keyword         any other keyword
line 591: "        Exception       try, catch, throw
line 592: 
line 593: exe "hi! PreProc"        .s:fmt_none   .s:fg_orange .s:bg_none
line 593: hi! PreProc cterm=NONE term=NONE ctermfg=9 ctermbg=NONE
line 594: "       *PreProc         generic Preprocessor
line 595: "        Include         preprocessor #include
line 596: "        Define          preprocessor #define
line 597: "        Macro           same as Define
line 598: "        PreCondit       preprocessor #if, #else, #endif, etc.
line 599: 
line 600: exe "hi! Type"           .s:fmt_none   .s:fg_yellow .s:bg_none
line 600: hi! Type cterm=NONE term=NONE ctermfg=3 ctermbg=NONE
line 601: "       *Type            int, long, char, etc.
line 602: "        StorageClass    static, register, volatile, etc.
line 603: "        Structure       struct, union, enum, etc.
line 604: "        Typedef         A typedef
line 605: 
line 606: exe "hi! Special"        .s:fmt_none   .s:fg_red    .s:bg_none
line 606: hi! Special cterm=NONE term=NONE ctermfg=1 ctermbg=NONE
line 607: "       *Special         any special symbol
line 608: "        SpecialChar     special character in a constant
line 609: "        Tag             you can use CTRL-] on this
line 610: "        Delimiter       character that needs attention
line 611: "        SpecialComment  special things inside a comment
line 612: "        Debug           debugging statements
line 613: 
line 614: exe "hi! Underlined"     .s:fmt_none   .s:fg_violet .s:bg_none
line 614: hi! Underlined cterm=NONE term=NONE ctermfg=13 ctermbg=NONE
line 615: "       *Underlined      text that stands out, HTML links
line 616: 
line 617: exe "hi! Ignore"         .s:fmt_none   .s:fg_none   .s:bg_none
line 617: hi! Ignore cterm=NONE term=NONE ctermfg=NONE ctermbg=NONE
line 618: "       *Ignore          left blank, hidden  |hl-Ignore|
line 619: 
line 620: exe "hi! Error"          .s:fmt_bold   .s:fg_red    .s:bg_none
line 620: hi! Error cterm=NONE,bold term=NONE,bold ctermfg=1 ctermbg=NONE
line 621: "       *Error           any erroneous construct
line 622: 
line 623: exe "hi! Todo"           .s:fmt_bold   .s:fg_magenta.s:bg_none
line 623: hi! Todo cterm=NONE,bold term=NONE,bold ctermfg=5 ctermbg=NONE
line 624: "       *Todo            anything that needs extra attention; mostly the
line 625: "                        keywords TODO FIXME and XXX
line 626: "
line 627: "}}}
line 628: " Extended highlighting "{{{
line 629: " ---------------------------------------------------------------------
line 630: if      (g:solarized_visibility=="high")
line 631:     exe "hi! SpecialKey"     .s:fmt_revr   .s:fg_red    .s:bg_none
line 632:     exe "hi! NonText"        .s:fmt_bold   .s:fg_base1  .s:bg_none
line 633: elseif  (g:solarized_visibility=="low")
line 634:     exe "hi! SpecialKey"     .s:fmt_bold   .s:fg_base02 .s:bg_none
line 635:     exe "hi! NonText"        .s:fmt_bold   .s:fg_base02 .s:bg_none
line 636: else
line 637:     exe "hi! SpecialKey"     .s:fmt_bold   .s:fg_red    .s:bg_none
line 637: hi! SpecialKey cterm=NONE,bold term=NONE,bold ctermfg=1 ctermbg=NONE
line 638:     exe "hi! NonText"        .s:fmt_bold   .s:fg_base01 .s:bg_none
line 638: hi! NonText cterm=NONE,bold term=NONE,bold ctermfg=10 ctermbg=NONE
line 639: endif
line 640: if (has("gui_running")) || &t_Co > 8
line 641:     exe "hi! StatusLine"     .s:fmt_none   .s:fg_base02 .s:bg_base1
line 641: hi! StatusLine cterm=NONE term=NONE ctermfg=0 ctermbg=14
line 642:     exe "hi! StatusLineNC"   .s:fmt_none   .s:fg_base02 .s:bg_base00
line 642: hi! StatusLineNC cterm=NONE term=NONE ctermfg=0 ctermbg=11
line 643:     "exe "hi! Visual"         .s:fmt_stnd   .s:fg_none   .s:bg_base02
line 644:     exe "hi! Visual"         .s:fmt_none   .s:fg_base03 .s:bg_base01
line 644: hi! Visual cterm=NONE term=NONE ctermfg=8 ctermbg=10
line 645: else
line 646:     exe "hi! StatusLine"     .s:fmt_none   .s:fg_base02 .s:bg_base2
line 647:     exe "hi! StatusLineNC"   .s:fmt_none   .s:fg_base02 .s:bg_base2
line 648:     exe "hi! Visual"         .s:fmt_none   .s:fg_none   .s:bg_base2
line 649: endif
line 650: exe "hi! Directory"      .s:fmt_none   .s:fg_blue   .s:bg_none
line 650: hi! Directory cterm=NONE term=NONE ctermfg=4 ctermbg=NONE
line 651: exe "hi! ErrorMsg"       .s:fmt_revr   .s:fg_red    .s:bg_none
line 651: hi! ErrorMsg cterm=NONE,reverse term=NONE,reverse ctermfg=1 ctermbg=NONE
line 652: exe "hi! IncSearch"      .s:fmt_stnd   .s:fg_orange .s:bg_none
line 652: hi! IncSearch cterm=NONE,standout term=NONE,standout ctermfg=9 ctermbg=NONE
line 653: exe "hi! Search"         .s:fmt_revr   .s:fg_yellow .s:bg_none
line 653: hi! Search cterm=NONE,reverse term=NONE,reverse ctermfg=3 ctermbg=NONE
line 654: exe "hi! MoreMsg"        .s:fmt_none   .s:fg_blue   .s:bg_none
line 654: hi! MoreMsg cterm=NONE term=NONE ctermfg=4 ctermbg=NONE
line 655: exe "hi! ModeMsg"        .s:fmt_none   .s:fg_blue   .s:bg_none
line 655: hi! ModeMsg cterm=NONE term=NONE ctermfg=4 ctermbg=NONE
line 656: exe "hi! LineNr"         .s:fmt_none   .s:fg_base01 .s:bg_base02
line 656: hi! LineNr cterm=NONE term=NONE ctermfg=10 ctermbg=0
line 657: exe "hi! Question"       .s:fmt_bold   .s:fg_cyan   .s:bg_none
line 657: hi! Question cterm=NONE,bold term=NONE,bold ctermfg=6 ctermbg=NONE
line 658: exe "hi! VertSplit"      .s:fmt_bold   .s:fg_base00 .s:bg_base00
line 658: hi! VertSplit cterm=NONE,bold term=NONE,bold ctermfg=11 ctermbg=11
line 659: exe "hi! Title"          .s:fmt_bold   .s:fg_orange .s:bg_none
line 659: hi! Title cterm=NONE,bold term=NONE,bold ctermfg=9 ctermbg=NONE
line 660: exe "hi! VisualNOS"      .s:fmt_stnd   .s:fg_none   .s:bg_base02
line 660: hi! VisualNOS cterm=NONE,standout term=NONE,standout ctermfg=NONE ctermbg=0
line 661: exe "hi! WarningMsg"     .s:fmt_bold   .s:fg_red    .s:bg_none
line 661: hi! WarningMsg cterm=NONE,bold term=NONE,bold ctermfg=1 ctermbg=NONE
line 662: exe "hi! WildMenu"       .s:fmt_none   .s:fg_base2  .s:bg_base02
line 662: hi! WildMenu cterm=NONE term=NONE ctermfg=7 ctermbg=0
line 663: exe "hi! Folded"         .s:fmt_undb   .s:fg_base0  .s:bg_base02  .s:sp_base03
line 663: hi! Folded cterm=NONE,underline,bold term=NONE,underline,bold ctermfg=12 ctermbg=0
line 664: exe "hi! FoldColumn"     .s:fmt_bold   .s:fg_base0  .s:bg_base02
line 664: hi! FoldColumn cterm=NONE,bold term=NONE,bold ctermfg=12 ctermbg=0
line 665: exe "hi! DiffAdd"        .s:fmt_revr   .s:fg_green  .s:bg_none
line 665: hi! DiffAdd cterm=NONE,reverse term=NONE,reverse ctermfg=2 ctermbg=NONE
line 666: exe "hi! DiffChange"     .s:fmt_revr   .s:fg_yellow .s:bg_none
line 666: hi! DiffChange cterm=NONE,reverse term=NONE,reverse ctermfg=3 ctermbg=NONE
line 667: exe "hi! DiffDelete"     .s:fmt_revr   .s:fg_red    .s:bg_none
line 667: hi! DiffDelete cterm=NONE,reverse term=NONE,reverse ctermfg=1 ctermbg=NONE
line 668: exe "hi! DiffText"       .s:fmt_revr   .s:fg_blue   .s:bg_none
line 668: hi! DiffText cterm=NONE,reverse term=NONE,reverse ctermfg=4 ctermbg=NONE
line 669: exe "hi! SignColumn"     .s:fmt_none   .s:fg_base0  .s:bg_base02
line 669: hi! SignColumn cterm=NONE term=NONE ctermfg=12 ctermbg=0
line 670: exe "hi! Conceal"        .s:fmt_none   .s:fg_blue   .s:bg_none
line 670: hi! Conceal cterm=NONE term=NONE ctermfg=4 ctermbg=NONE
line 671: exe "hi! SpellBad"       .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_red
line 671: hi! SpellBad cterm=NONE,undercurl term=NONE,undercurl ctermfg=NONE ctermbg=NONE
line 672: exe "hi! SpellCap"       .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_violet
line 672: hi! SpellCap cterm=NONE,undercurl term=NONE,undercurl ctermfg=NONE ctermbg=NONE
line 673: exe "hi! SpellRare"      .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_cyan
line 673: hi! SpellRare cterm=NONE,undercurl term=NONE,undercurl ctermfg=NONE ctermbg=NONE
line 674: exe "hi! SpellLocal"     .s:fmt_curl   .s:fg_none   .s:bg_none    .s:sp_yellow
line 674: hi! SpellLocal cterm=NONE,undercurl term=NONE,undercurl ctermfg=NONE ctermbg=NONE
line 675: exe "hi! Pmenu"          .s:fmt_none   .s:fg_base0  .s:bg_base02
line 675: hi! Pmenu cterm=NONE term=NONE ctermfg=12 ctermbg=0
line 676: exe "hi! PmenuSel"       .s:fmt_none   .s:fg_base2  .s:bg_base01
line 676: hi! PmenuSel cterm=NONE term=NONE ctermfg=7 ctermbg=10
line 677: exe "hi! PmenuSbar"      .s:fmt_none   .s:fg_base0  .s:bg_base2
line 677: hi! PmenuSbar cterm=NONE term=NONE ctermfg=12 ctermbg=7
line 678: exe "hi! PmenuThumb"     .s:fmt_none   .s:fg_base03 .s:bg_base0
line 678: hi! PmenuThumb cterm=NONE term=NONE ctermfg=8 ctermbg=12
line 679: exe "hi! TabLine"        .s:fmt_undr   .s:fg_base0  .s:bg_base02  .s:sp_base0
line 679: hi! TabLine cterm=NONE,underline term=NONE,underline ctermfg=12 ctermbg=0
line 680: exe "hi! TabLineSel"     .s:fmt_undr   .s:fg_base2  .s:bg_base01  .s:sp_base0
line 680: hi! TabLineSel cterm=NONE,underline term=NONE,underline ctermfg=7 ctermbg=10
line 681: exe "hi! TabLineFill"    .s:fmt_undr   .s:fg_base0  .s:bg_base02  .s:sp_base0
line 681: hi! TabLineFill cterm=NONE,underline term=NONE,underline ctermfg=12 ctermbg=0
line 682: exe "hi! CursorColumn"   .s:fmt_none   .s:fg_none   .s:bg_base02
line 682: hi! CursorColumn cterm=NONE term=NONE ctermfg=NONE ctermbg=0
line 683: exe "hi! CursorLine"     .s:fmt_uopt   .s:fg_none   .s:bg_base02  .s:sp_base1
line 683: hi! CursorLine cterm=NONE term=NONE ctermfg=NONE ctermbg=0
line 684: exe "hi! ColorColumn"    .s:fmt_none   .s:fg_none   .s:bg_base02
line 684: hi! ColorColumn cterm=NONE term=NONE ctermfg=NONE ctermbg=0
line 685: exe "hi! Cursor"         .s:fmt_none   .s:fg_base03 .s:bg_base0
line 685: hi! Cursor cterm=NONE term=NONE ctermfg=8 ctermbg=12
line 686: hi! link lCursor Cursor
line 687: exe "hi! MatchParen"     .s:fmt_bold   .s:fg_red    .s:bg_base01
line 687: hi! MatchParen cterm=NONE,bold term=NONE,bold ctermfg=1 ctermbg=10
line 688: 
line 689: "}}}
line 690: " vim syntax highlighting "{{{
line 691: " ---------------------------------------------------------------------
line 692: exe "hi! vimLineComment" . s:fg_base01 .s:bg_none   .s:fmt_ital
line 692: hi! vimLineComment ctermfg=10 ctermbg=NONE cterm=NONE term=NONE
line 693: exe "hi! vimCommentString".s:fg_violet .s:bg_none   .s:fmt_none
line 693: hi! vimCommentString ctermfg=13 ctermbg=NONE cterm=NONE term=NONE
line 694: hi! link vimVar Identifier
line 695: hi! link vimFunc Function
line 696: hi! link vimUserFunc Function
line 697: exe "hi! vimCommand"     . s:fg_yellow .s:bg_none   .s:fmt_none
line 697: hi! vimCommand ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 698: exe "hi! vimCmdSep"      . s:fg_blue   .s:bg_none   .s:fmt_bold
line 698: hi! vimCmdSep ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 699: exe "hi! helpExample"    . s:fg_base1  .s:bg_none   .s:fmt_none
line 699: hi! helpExample ctermfg=14 ctermbg=NONE cterm=NONE term=NONE
line 700: hi! link helpSpecial Special
line 701: exe "hi! helpOption"     . s:fg_cyan   .s:bg_none   .s:fmt_none
line 701: hi! helpOption ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 702: exe "hi! helpNote"       . s:fg_magenta.s:bg_none   .s:fmt_none
line 702: hi! helpNote ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 703: exe "hi! helpVim"        . s:fg_magenta.s:bg_none   .s:fmt_none
line 703: hi! helpVim ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 704: exe "hi! helpHyperTextJump" .s:fg_blue  .s:bg_none   .s:fmt_undr
line 704: hi! helpHyperTextJump ctermfg=4 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 705: exe "hi! helpHyperTextEntry".s:fg_green .s:bg_none   .s:fmt_none
line 705: hi! helpHyperTextEntry ctermfg=2 ctermbg=NONE cterm=NONE term=NONE
line 706: exe "hi! vimIsCommand"   . s:fg_base00 .s:bg_none   .s:fmt_none
line 706: hi! vimIsCommand ctermfg=11 ctermbg=NONE cterm=NONE term=NONE
line 707: exe "hi! vimSynMtchOpt"  . s:fg_yellow .s:bg_none   .s:fmt_none
line 707: hi! vimSynMtchOpt ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 708: exe "hi! vimSynType"     . s:fg_cyan   .s:bg_none   .s:fmt_none
line 708: hi! vimSynType ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 709: exe "hi! vimHiLink"      . s:fg_blue   .s:bg_none   .s:fmt_none
line 709: hi! vimHiLink ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 710: exe "hi! vimHiGroup"     . s:fg_blue   .s:bg_none   .s:fmt_none
line 710: hi! vimHiGroup ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 711: exe "hi! vimGroup"       . s:fg_blue   .s:bg_none   .s:fmt_undb
line 711: hi! vimGroup ctermfg=4 ctermbg=NONE cterm=NONE,underline,bold term=NONE,underline,bold
line 712: "}}}
line 713: " html highlighting "{{{
line 714: " ---------------------------------------------------------------------
line 715: exe "hi! htmlTag"        . s:fg_base01 .s:bg_none   .s:fmt_none
line 715: hi! htmlTag ctermfg=10 ctermbg=NONE cterm=NONE term=NONE
line 716: exe "hi! htmlEndTag"     . s:fg_base01 .s:bg_none   .s:fmt_none
line 716: hi! htmlEndTag ctermfg=10 ctermbg=NONE cterm=NONE term=NONE
line 717: exe "hi! htmlTagN"       . s:fg_base1  .s:bg_none   .s:fmt_bold
line 717: hi! htmlTagN ctermfg=14 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 718: exe "hi! htmlTagName"    . s:fg_blue   .s:bg_none   .s:fmt_bold
line 718: hi! htmlTagName ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 719: exe "hi! htmlSpecialTagName". s:fg_blue  .s:bg_none .s:fmt_ital
line 719: hi! htmlSpecialTagName ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 720: exe "hi! htmlArg"        . s:fg_base00 .s:bg_none   .s:fmt_none
line 720: hi! htmlArg ctermfg=11 ctermbg=NONE cterm=NONE term=NONE
line 721: exe "hi! javaScript"     . s:fg_yellow .s:bg_none   .s:fmt_none
line 721: hi! javaScript ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 722: "}}}
line 723: " perl highlighting "{{{
line 724: " ---------------------------------------------------------------------
line 725: exe "hi! perlHereDoc"    . s:fg_base1  .s:bg_back   .s:fmt_none
line 725: hi! perlHereDoc ctermfg=14 ctermbg=8 cterm=NONE term=NONE
line 726: exe "hi! perlVarPlain"   . s:fg_yellow .s:bg_back   .s:fmt_none
line 726: hi! perlVarPlain ctermfg=3 ctermbg=8 cterm=NONE term=NONE
line 727: exe "hi! perlStatementFileDesc". s:fg_cyan.s:bg_back.s:fmt_none
line 727: hi! perlStatementFileDesc ctermfg=6 ctermbg=8 cterm=NONE term=NONE
line 728: 
line 729: "}}}
line 730: " tex highlighting "{{{
line 731: " ---------------------------------------------------------------------
line 732: exe "hi! texStatement"   . s:fg_cyan   .s:bg_back   .s:fmt_none
line 732: hi! texStatement ctermfg=6 ctermbg=8 cterm=NONE term=NONE
line 733: exe "hi! texMathZoneX"   . s:fg_yellow .s:bg_back   .s:fmt_none
line 733: hi! texMathZoneX ctermfg=3 ctermbg=8 cterm=NONE term=NONE
line 734: exe "hi! texMathMatcher" . s:fg_yellow .s:bg_back   .s:fmt_none
line 734: hi! texMathMatcher ctermfg=3 ctermbg=8 cterm=NONE term=NONE
line 735: exe "hi! texMathMatcher" . s:fg_yellow .s:bg_back   .s:fmt_none
line 735: hi! texMathMatcher ctermfg=3 ctermbg=8 cterm=NONE term=NONE
line 736: exe "hi! texRefLabel"    . s:fg_yellow .s:bg_back   .s:fmt_none
line 736: hi! texRefLabel ctermfg=3 ctermbg=8 cterm=NONE term=NONE
line 737: "}}}
line 738: " ruby highlighting "{{{
line 739: " ---------------------------------------------------------------------
line 740: exe "hi! rubyDefine"     . s:fg_base1  .s:bg_back   .s:fmt_bold
line 740: hi! rubyDefine ctermfg=14 ctermbg=8 cterm=NONE,bold term=NONE,bold
line 741: "rubyInclude
line 742: "rubySharpBang
line 743: "rubyAccess
line 744: "rubyPredefinedVariable
line 745: "rubyBoolean
line 746: "rubyClassVariable
line 747: "rubyBeginEnd
line 748: "rubyRepeatModifier
line 749: "hi! link rubyArrayDelimiter    Special  " [ , , ]
line 750: "rubyCurlyBlock  { , , }
line 751: 
line 752: "hi! link rubyClass             Keyword
line 753: "hi! link rubyModule            Keyword
line 754: "hi! link rubyKeyword           Keyword
line 755: "hi! link rubyOperator          Operator
line 756: "hi! link rubyIdentifier        Identifier
line 757: "hi! link rubyInstanceVariable  Identifier
line 758: "hi! link rubyGlobalVariable    Identifier
line 759: "hi! link rubyClassVariable     Identifier
line 760: "hi! link rubyConstant          Type
line 761: "}}}
line 762: " haskell syntax highlighting"{{{
line 763: " ---------------------------------------------------------------------
line 764: " For use with syntax/haskell.vim : Haskell Syntax File
line 765: " http://www.vim.org/scripts/script.php?script_id=3034
line 766: " See also Steffen Siering's github repository:
line 767: " http://github.com/urso/dotrc/blob/master/vim/syntax/haskell.vim
line 768: " ---------------------------------------------------------------------
line 769: "
line 770: " Treat True and False specially, see the plugin referenced above
line 771: let hs_highlight_boolean=1
line 772: " highlight delims, see the plugin referenced above
line 773: let hs_highlight_delimiters=1
line 774: 
line 775: exe "hi! cPreCondit". s:fg_orange.s:bg_none   .s:fmt_none
line 775: hi! cPreCondit ctermfg=9 ctermbg=NONE cterm=NONE term=NONE
line 776: 
line 777: exe "hi! VarId"    . s:fg_blue   .s:bg_none   .s:fmt_none
line 777: hi! VarId ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 778: exe "hi! ConId"    . s:fg_yellow .s:bg_none   .s:fmt_none
line 778: hi! ConId ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 779: exe "hi! hsImport" . s:fg_magenta.s:bg_none   .s:fmt_none
line 779: hi! hsImport ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 780: exe "hi! hsString" . s:fg_base00 .s:bg_none   .s:fmt_none
line 780: hi! hsString ctermfg=11 ctermbg=NONE cterm=NONE term=NONE
line 781: 
line 782: exe "hi! hsStructure"        . s:fg_cyan   .s:bg_none   .s:fmt_none
line 782: hi! hsStructure ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 783: exe "hi! hs_hlFunctionName"  . s:fg_blue   .s:bg_none
line 783: hi! hs_hlFunctionName ctermfg=4 ctermbg=NONE
line 784: exe "hi! hsStatement"        . s:fg_cyan   .s:bg_none   .s:fmt_none
line 784: hi! hsStatement ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 785: exe "hi! hsImportLabel"      . s:fg_cyan   .s:bg_none   .s:fmt_none
line 785: hi! hsImportLabel ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 786: exe "hi! hs_OpFunctionName"  . s:fg_yellow .s:bg_none   .s:fmt_none
line 786: hi! hs_OpFunctionName ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 787: exe "hi! hs_DeclareFunction" . s:fg_orange .s:bg_none   .s:fmt_none
line 787: hi! hs_DeclareFunction ctermfg=9 ctermbg=NONE cterm=NONE term=NONE
line 788: exe "hi! hsVarSym"           . s:fg_cyan   .s:bg_none   .s:fmt_none
line 788: hi! hsVarSym ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 789: exe "hi! hsType"             . s:fg_yellow .s:bg_none   .s:fmt_none
line 789: hi! hsType ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 790: exe "hi! hsTypedef"          . s:fg_cyan   .s:bg_none   .s:fmt_none
line 790: hi! hsTypedef ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 791: exe "hi! hsModuleName"       . s:fg_green  .s:bg_none   .s:fmt_undr
line 791: hi! hsModuleName ctermfg=2 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 792: exe "hi! hsModuleStartLabel" . s:fg_magenta.s:bg_none   .s:fmt_none
line 792: hi! hsModuleStartLabel ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 793: hi! link hsImportParams      Delimiter
line 794: hi! link hsDelimTypeExport   Delimiter
line 795: hi! link hsModuleStartLabel  hsStructure
line 796: hi! link hsModuleWhereLabel  hsModuleStartLabel
line 797: 
line 798: " following is for the haskell-conceal plugin
line 799: " the first two items don't have an impact, but better safe
line 800: exe "hi! hsNiceOperator"     . s:fg_cyan   .s:bg_none   .s:fmt_none
line 800: hi! hsNiceOperator ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 801: exe "hi! hsniceoperator"     . s:fg_cyan   .s:bg_none   .s:fmt_none
line 801: hi! hsniceoperator ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 802: 
line 803: "}}}
line 804: " pandoc markdown syntax highlighting "{{{
line 805: " ---------------------------------------------------------------------
line 806: 
line 807: "PandocHiLink pandocNormalBlock
line 808: exe "hi! pandocTitleBlock"               .s:fg_blue   .s:bg_none   .s:fmt_none
line 808: hi! pandocTitleBlock ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 809: exe "hi! pandocTitleBlockTitle"          .s:fg_blue   .s:bg_none   .s:fmt_bold
line 809: hi! pandocTitleBlockTitle ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 810: exe "hi! pandocTitleComment"             .s:fg_blue   .s:bg_none   .s:fmt_bold
line 810: hi! pandocTitleComment ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 811: exe "hi! pandocComment"                  .s:fg_base01 .s:bg_none   .s:fmt_ital
line 811: hi! pandocComment ctermfg=10 ctermbg=NONE cterm=NONE term=NONE
line 812: exe "hi! pandocVerbatimBlock"            .s:fg_yellow .s:bg_none   .s:fmt_none
line 812: hi! pandocVerbatimBlock ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 813: hi! link pandocVerbatimBlockDeep         pandocVerbatimBlock
line 814: hi! link pandocCodeBlock                 pandocVerbatimBlock
line 815: hi! link pandocCodeBlockDelim            pandocVerbatimBlock
line 816: exe "hi! pandocBlockQuote"               .s:fg_blue   .s:bg_none   .s:fmt_none
line 816: hi! pandocBlockQuote ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 817: exe "hi! pandocBlockQuoteLeader1"        .s:fg_blue   .s:bg_none   .s:fmt_none
line 817: hi! pandocBlockQuoteLeader1 ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 818: exe "hi! pandocBlockQuoteLeader2"        .s:fg_cyan   .s:bg_none   .s:fmt_none
line 818: hi! pandocBlockQuoteLeader2 ctermfg=6 ctermbg=NONE cterm=NONE term=NONE
line 819: exe "hi! pandocBlockQuoteLeader3"        .s:fg_yellow .s:bg_none   .s:fmt_none
line 819: hi! pandocBlockQuoteLeader3 ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 820: exe "hi! pandocBlockQuoteLeader4"        .s:fg_red    .s:bg_none   .s:fmt_none
line 820: hi! pandocBlockQuoteLeader4 ctermfg=1 ctermbg=NONE cterm=NONE term=NONE
line 821: exe "hi! pandocBlockQuoteLeader5"        .s:fg_base0  .s:bg_none   .s:fmt_none
line 821: hi! pandocBlockQuoteLeader5 ctermfg=12 ctermbg=NONE cterm=NONE term=NONE
line 822: exe "hi! pandocBlockQuoteLeader6"        .s:fg_base01 .s:bg_none   .s:fmt_none
line 822: hi! pandocBlockQuoteLeader6 ctermfg=10 ctermbg=NONE cterm=NONE term=NONE
line 823: exe "hi! pandocListMarker"               .s:fg_magenta.s:bg_none   .s:fmt_none
line 823: hi! pandocListMarker ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 824: exe "hi! pandocListReference"            .s:fg_magenta.s:bg_none   .s:fmt_undr
line 824: hi! pandocListReference ctermfg=5 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 825: 
line 826: " Definitions
line 827: " ---------------------------------------------------------------------
line 828: let s:fg_pdef = s:fg_violet
line 829: exe "hi! pandocDefinitionBlock"              .s:fg_pdef  .s:bg_none  .s:fmt_none
line 829: hi! pandocDefinitionBlock ctermfg=13 ctermbg=NONE cterm=NONE term=NONE
line 830: exe "hi! pandocDefinitionTerm"               .s:fg_pdef  .s:bg_none  .s:fmt_stnd
line 830: hi! pandocDefinitionTerm ctermfg=13 ctermbg=NONE cterm=NONE,standout term=NONE,standout
line 831: exe "hi! pandocDefinitionIndctr"             .s:fg_pdef  .s:bg_none  .s:fmt_bold
line 831: hi! pandocDefinitionIndctr ctermfg=13 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 832: exe "hi! pandocEmphasisDefinition"           .s:fg_pdef  .s:bg_none  .s:fmt_ital
line 832: hi! pandocEmphasisDefinition ctermfg=13 ctermbg=NONE cterm=NONE term=NONE
line 833: exe "hi! pandocEmphasisNestedDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_bldi
line 833: hi! pandocEmphasisNestedDefinition ctermfg=13 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 834: exe "hi! pandocStrongEmphasisDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_bold
line 834: hi! pandocStrongEmphasisDefinition ctermfg=13 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 835: exe "hi! pandocStrongEmphasisNestedDefinition"   .s:fg_pdef.s:bg_none.s:fmt_bldi
line 835: hi! pandocStrongEmphasisNestedDefinition ctermfg=13 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 836: exe "hi! pandocStrongEmphasisEmphasisDefinition" .s:fg_pdef.s:bg_none.s:fmt_bldi
line 836: hi! pandocStrongEmphasisEmphasisDefinition ctermfg=13 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 837: exe "hi! pandocStrikeoutDefinition"          .s:fg_pdef  .s:bg_none  .s:fmt_revr
line 837: hi! pandocStrikeoutDefinition ctermfg=13 ctermbg=NONE cterm=NONE,reverse term=NONE,reverse
line 838: exe "hi! pandocVerbatimInlineDefinition"     .s:fg_pdef  .s:bg_none  .s:fmt_none
line 838: hi! pandocVerbatimInlineDefinition ctermfg=13 ctermbg=NONE cterm=NONE term=NONE
line 839: exe "hi! pandocSuperscriptDefinition"        .s:fg_pdef  .s:bg_none  .s:fmt_none
line 839: hi! pandocSuperscriptDefinition ctermfg=13 ctermbg=NONE cterm=NONE term=NONE
line 840: exe "hi! pandocSubscriptDefinition"          .s:fg_pdef  .s:bg_none  .s:fmt_none
line 840: hi! pandocSubscriptDefinition ctermfg=13 ctermbg=NONE cterm=NONE term=NONE
line 841: 
line 842: " Tables
line 843: " ---------------------------------------------------------------------
line 844: let s:fg_ptable = s:fg_blue
line 845: exe "hi! pandocTable"                        .s:fg_ptable.s:bg_none  .s:fmt_none
line 845: hi! pandocTable ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 846: exe "hi! pandocTableStructure"               .s:fg_ptable.s:bg_none  .s:fmt_none
line 846: hi! pandocTableStructure ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 847: hi! link pandocTableStructureTop             pandocTableStructre
line 848: hi! link pandocTableStructureEnd             pandocTableStructre
line 849: exe "hi! pandocTableZebraLight"              .s:fg_ptable.s:bg_base03.s:fmt_none
line 849: hi! pandocTableZebraLight ctermfg=4 ctermbg=8 cterm=NONE term=NONE
line 850: exe "hi! pandocTableZebraDark"               .s:fg_ptable.s:bg_base02.s:fmt_none
line 850: hi! pandocTableZebraDark ctermfg=4 ctermbg=0 cterm=NONE term=NONE
line 851: exe "hi! pandocEmphasisTable"                .s:fg_ptable.s:bg_none  .s:fmt_ital
line 851: hi! pandocEmphasisTable ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 852: exe "hi! pandocEmphasisNestedTable"          .s:fg_ptable.s:bg_none  .s:fmt_bldi
line 852: hi! pandocEmphasisNestedTable ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 853: exe "hi! pandocStrongEmphasisTable"          .s:fg_ptable.s:bg_none  .s:fmt_bold
line 853: hi! pandocStrongEmphasisTable ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 854: exe "hi! pandocStrongEmphasisNestedTable"    .s:fg_ptable.s:bg_none  .s:fmt_bldi
line 854: hi! pandocStrongEmphasisNestedTable ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 855: exe "hi! pandocStrongEmphasisEmphasisTable"  .s:fg_ptable.s:bg_none  .s:fmt_bldi
line 855: hi! pandocStrongEmphasisEmphasisTable ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 856: exe "hi! pandocStrikeoutTable"               .s:fg_ptable.s:bg_none  .s:fmt_revr
line 856: hi! pandocStrikeoutTable ctermfg=4 ctermbg=NONE cterm=NONE,reverse term=NONE,reverse
line 857: exe "hi! pandocVerbatimInlineTable"          .s:fg_ptable.s:bg_none  .s:fmt_none
line 857: hi! pandocVerbatimInlineTable ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 858: exe "hi! pandocSuperscriptTable"             .s:fg_ptable.s:bg_none  .s:fmt_none
line 858: hi! pandocSuperscriptTable ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 859: exe "hi! pandocSubscriptTable"               .s:fg_ptable.s:bg_none  .s:fmt_none
line 859: hi! pandocSubscriptTable ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 860: 
line 861: " Headings
line 862: " ---------------------------------------------------------------------
line 863: let s:fg_phead = s:fg_orange
line 864: exe "hi! pandocHeading"                      .s:fg_phead .s:bg_none.s:fmt_bold
line 864: hi! pandocHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 865: exe "hi! pandocHeadingMarker"                .s:fg_yellow.s:bg_none.s:fmt_bold
line 865: hi! pandocHeadingMarker ctermfg=3 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 866: exe "hi! pandocEmphasisHeading"              .s:fg_phead .s:bg_none.s:fmt_bldi
line 866: hi! pandocEmphasisHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 867: exe "hi! pandocEmphasisNestedHeading"        .s:fg_phead .s:bg_none.s:fmt_bldi
line 867: hi! pandocEmphasisNestedHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 868: exe "hi! pandocStrongEmphasisHeading"        .s:fg_phead .s:bg_none.s:fmt_bold
line 868: hi! pandocStrongEmphasisHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 869: exe "hi! pandocStrongEmphasisNestedHeading"  .s:fg_phead .s:bg_none.s:fmt_bldi
line 869: hi! pandocStrongEmphasisNestedHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 870: exe "hi! pandocStrongEmphasisEmphasisHeading".s:fg_phead .s:bg_none.s:fmt_bldi
line 870: hi! pandocStrongEmphasisEmphasisHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 871: exe "hi! pandocStrikeoutHeading"             .s:fg_phead .s:bg_none.s:fmt_revr
line 871: hi! pandocStrikeoutHeading ctermfg=9 ctermbg=NONE cterm=NONE,reverse term=NONE,reverse
line 872: exe "hi! pandocVerbatimInlineHeading"        .s:fg_phead .s:bg_none.s:fmt_bold
line 872: hi! pandocVerbatimInlineHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 873: exe "hi! pandocSuperscriptHeading"           .s:fg_phead .s:bg_none.s:fmt_bold
line 873: hi! pandocSuperscriptHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 874: exe "hi! pandocSubscriptHeading"             .s:fg_phead .s:bg_none.s:fmt_bold
line 874: hi! pandocSubscriptHeading ctermfg=9 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 875: 
line 876: " Links
line 877: " ---------------------------------------------------------------------
line 878: exe "hi! pandocLinkDelim"                .s:fg_base01 .s:bg_none   .s:fmt_none
line 878: hi! pandocLinkDelim ctermfg=10 ctermbg=NONE cterm=NONE term=NONE
line 879: exe "hi! pandocLinkLabel"                .s:fg_blue   .s:bg_none   .s:fmt_undr
line 879: hi! pandocLinkLabel ctermfg=4 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 880: exe "hi! pandocLinkText"                 .s:fg_blue   .s:bg_none   .s:fmt_undb
line 880: hi! pandocLinkText ctermfg=4 ctermbg=NONE cterm=NONE,underline,bold term=NONE,underline,bold
line 881: exe "hi! pandocLinkURL"                  .s:fg_base00 .s:bg_none   .s:fmt_undr
line 881: hi! pandocLinkURL ctermfg=11 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 882: exe "hi! pandocLinkTitle"                .s:fg_base00 .s:bg_none   .s:fmt_undi
line 882: hi! pandocLinkTitle ctermfg=11 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 883: exe "hi! pandocLinkTitleDelim"           .s:fg_base01 .s:bg_none   .s:fmt_undi   .s:sp_base00
line 883: hi! pandocLinkTitleDelim ctermfg=10 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 884: exe "hi! pandocLinkDefinition"           .s:fg_cyan   .s:bg_none   .s:fmt_undr   .s:sp_base00
line 884: hi! pandocLinkDefinition ctermfg=6 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 885: exe "hi! pandocLinkDefinitionID"         .s:fg_blue   .s:bg_none   .s:fmt_bold
line 885: hi! pandocLinkDefinitionID ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 886: exe "hi! pandocImageCaption"             .s:fg_violet .s:bg_none   .s:fmt_undb
line 886: hi! pandocImageCaption ctermfg=13 ctermbg=NONE cterm=NONE,underline,bold term=NONE,underline,bold
line 887: exe "hi! pandocFootnoteLink"             .s:fg_green  .s:bg_none   .s:fmt_undr
line 887: hi! pandocFootnoteLink ctermfg=2 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 888: exe "hi! pandocFootnoteDefLink"          .s:fg_green  .s:bg_none   .s:fmt_bold
line 888: hi! pandocFootnoteDefLink ctermfg=2 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 889: exe "hi! pandocFootnoteInline"           .s:fg_green  .s:bg_none   .s:fmt_undb
line 889: hi! pandocFootnoteInline ctermfg=2 ctermbg=NONE cterm=NONE,underline,bold term=NONE,underline,bold
line 890: exe "hi! pandocFootnote"                 .s:fg_green  .s:bg_none   .s:fmt_none
line 890: hi! pandocFootnote ctermfg=2 ctermbg=NONE cterm=NONE term=NONE
line 891: exe "hi! pandocCitationDelim"            .s:fg_magenta.s:bg_none   .s:fmt_none
line 891: hi! pandocCitationDelim ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 892: exe "hi! pandocCitation"                 .s:fg_magenta.s:bg_none   .s:fmt_none
line 892: hi! pandocCitation ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 893: exe "hi! pandocCitationID"               .s:fg_magenta.s:bg_none   .s:fmt_undr
line 893: hi! pandocCitationID ctermfg=5 ctermbg=NONE cterm=NONE,underline term=NONE,underline
line 894: exe "hi! pandocCitationRef"              .s:fg_magenta.s:bg_none   .s:fmt_none
line 894: hi! pandocCitationRef ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 895: 
line 896: " Main Styles
line 897: " ---------------------------------------------------------------------
line 898: exe "hi! pandocStyleDelim"               .s:fg_base01 .s:bg_none  .s:fmt_none
line 898: hi! pandocStyleDelim ctermfg=10 ctermbg=NONE cterm=NONE term=NONE
line 899: exe "hi! pandocEmphasis"                 .s:fg_base0  .s:bg_none  .s:fmt_ital
line 899: hi! pandocEmphasis ctermfg=12 ctermbg=NONE cterm=NONE term=NONE
line 900: exe "hi! pandocEmphasisNested"           .s:fg_base0  .s:bg_none  .s:fmt_bldi
line 900: hi! pandocEmphasisNested ctermfg=12 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 901: exe "hi! pandocStrongEmphasis"           .s:fg_base0  .s:bg_none  .s:fmt_bold
line 901: hi! pandocStrongEmphasis ctermfg=12 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 902: exe "hi! pandocStrongEmphasisNested"     .s:fg_base0  .s:bg_none  .s:fmt_bldi
line 902: hi! pandocStrongEmphasisNested ctermfg=12 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 903: exe "hi! pandocStrongEmphasisEmphasis"   .s:fg_base0  .s:bg_none  .s:fmt_bldi
line 903: hi! pandocStrongEmphasisEmphasis ctermfg=12 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 904: exe "hi! pandocStrikeout"                .s:fg_base01 .s:bg_none  .s:fmt_revr
line 904: hi! pandocStrikeout ctermfg=10 ctermbg=NONE cterm=NONE,reverse term=NONE,reverse
line 905: exe "hi! pandocVerbatimInline"           .s:fg_yellow .s:bg_none  .s:fmt_none
line 905: hi! pandocVerbatimInline ctermfg=3 ctermbg=NONE cterm=NONE term=NONE
line 906: exe "hi! pandocSuperscript"              .s:fg_violet .s:bg_none  .s:fmt_none
line 906: hi! pandocSuperscript ctermfg=13 ctermbg=NONE cterm=NONE term=NONE
line 907: exe "hi! pandocSubscript"                .s:fg_violet .s:bg_none  .s:fmt_none
line 907: hi! pandocSubscript ctermfg=13 ctermbg=NONE cterm=NONE term=NONE
line 908: 
line 909: exe "hi! pandocRule"                     .s:fg_blue   .s:bg_none  .s:fmt_bold
line 909: hi! pandocRule ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 910: exe "hi! pandocRuleLine"                 .s:fg_blue   .s:bg_none  .s:fmt_bold
line 910: hi! pandocRuleLine ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 911: exe "hi! pandocEscapePair"               .s:fg_red    .s:bg_none  .s:fmt_bold
line 911: hi! pandocEscapePair ctermfg=1 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 912: exe "hi! pandocCitationRef"              .s:fg_magenta.s:bg_none   .s:fmt_none
line 912: hi! pandocCitationRef ctermfg=5 ctermbg=NONE cterm=NONE term=NONE
line 913: exe "hi! pandocNonBreakingSpace"         . s:fg_red   .s:bg_none  .s:fmt_revr
line 913: hi! pandocNonBreakingSpace ctermfg=1 ctermbg=NONE cterm=NONE,reverse term=NONE,reverse
line 914: hi! link pandocEscapedCharacter          pandocEscapePair
line 915: hi! link pandocLineBreak                 pandocEscapePair
line 916: 
line 917: " Embedded Code
line 918: " ---------------------------------------------------------------------
line 919: exe "hi! pandocMetadataDelim"            .s:fg_base01 .s:bg_none   .s:fmt_none
line 919: hi! pandocMetadataDelim ctermfg=10 ctermbg=NONE cterm=NONE term=NONE
line 920: exe "hi! pandocMetadata"                 .s:fg_blue   .s:bg_none   .s:fmt_none
line 920: hi! pandocMetadata ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 921: exe "hi! pandocMetadataKey"              .s:fg_blue   .s:bg_none   .s:fmt_none
line 921: hi! pandocMetadataKey ctermfg=4 ctermbg=NONE cterm=NONE term=NONE
line 922: exe "hi! pandocMetadata"                 .s:fg_blue   .s:bg_none   .s:fmt_bold
line 922: hi! pandocMetadata ctermfg=4 ctermbg=NONE cterm=NONE,bold term=NONE,bold
line 923: hi! link pandocMetadataTitle             pandocMetadata
line 924: 
line 925: "}}}
line 926: " Utility autocommand "{{{
line 927: " ---------------------------------------------------------------------
line 928: " In cases where Solarized is initialized inside a terminal vim session and 
line 929: " then transferred to a gui session via the command `:gui`, the gui vim process 
line 930: " does not re-read the colorscheme (or .vimrc for that matter) so any `has_gui` 
line 931: " related code that sets gui specific values isn't executed.
line 932: "
line 933: " Currently, Solarized sets only the cterm or gui values for the colorscheme 
line 934: " depending on gui or terminal mode. It's possible that, if the following 
line 935: " autocommand method is deemed excessively poor form, that approach will be 
line 936: " used again and the autocommand below will be dropped.
line 937: "
line 938: " However it seems relatively benign in this case to include the autocommand 
line 939: " here. It fires only in cases where vim is transferring from terminal to gui 
line 940: " mode (detected with the script scope s:vmode variable). It also allows for 
line 941: " other potential terminal customizations that might make gui mode suboptimal.
line 942: "
line 943: autocmd GUIEnter * if (s:vmode != "gui") | exe "colorscheme " . g:colors_name | endif
line 944: "}}}
line 945: " License "{{{
line 946: " ---------------------------------------------------------------------
line 947: "
line 948: " Copyright (c) 2011 Ethan Schoonover
line 949: "
line 950: " Permission is hereby granted, free of charge, to any person obtaining a copy
line 951: " of this software and associated documentation files (the "Software"), to deal
line 952: " in the Software without restriction, including without limitation the rights
line 953: " to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
line 954: " copies of the Software, and to permit persons to whom the Software is
line 955: " furnished to do so, subject to the following conditions:
line 956: "
line 957: " The above copyright notice and this permission notice shall be included in
line 958: " all copies or substantial portions of the Software.
line 959: "
line 960: " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
line 961: " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
line 962: " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
line 963: " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
line 964: " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
line 965: " OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
line 966: " THE SOFTWARE.
line 967: "
line 968: " vim:foldmethod=marker:foldlevel=0
line 969: "}}}
finished sourcing /Users/jmoussa/.vim/colors/solarized.vim
continuing in /Users/jmoussa/.vimrc
line 7: set tabstop=4
line 8: set shiftwidth=4
line 9: set smartindent
line 10: set autoindent
line 11: set smarttab
line 12: set number
line 13: set term=screen-256color
line 14: set nocompatible
line 15: set clipboard=unnamed
line 16: set mouse=a
line 17: set hlsearch
line 18: set cindent
line 19: set expandtab
line 20: set cursorline
line 21: filetype on
Searching for "filetype.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 21: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2017 Aug 11
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
continuing in /Users/jmoussa/.vimrc
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/filetype.vim"
Searching for "/Users/jmoussa/.vim/after/filetype.vim"
line 22: filetype plugin indent on
Searching for "filetype.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 22: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2017 Aug 11
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
continuing in /Users/jmoussa/.vimrc
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/filetype.vim"
Searching for "/Users/jmoussa/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/ftplugin.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/ftplugin.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 22: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
line 8: endif
line 9: let did_load_ftplugin = 1
line 10: 
line 11: augroup filetypeplugin
line 12:   au FileType * call s:LoadFTPlugin()
line 13: 
line 14:   func! s:LoadFTPlugin()
line 35: augroup END
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim
continuing in /Users/jmoussa/.vimrc
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/ftplugin.vim"
Searching for "/Users/jmoussa/.vim/after/ftplugin.vim"
Searching for "indent.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/indent.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/indent.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/indent.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 22: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2008 Feb 22
line 5: 
line 6: if exists("did_indent_on")
line 7:   finish
line 8: endif
line 9: let did_indent_on = 1
line 10: 
line 11: augroup filetypeindent
line 12:   au FileType * call s:LoadIndent()
line 13:   func! s:LoadIndent()
line 31: augroup END
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/indent.vim
continuing in /Users/jmoussa/.vimrc
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/indent.vim"
Searching for "/Users/jmoussa/.vim/after/indent.vim"
line 23: filetype plugin on
Searching for "filetype.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 23: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2017 Aug 11
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
continuing in /Users/jmoussa/.vimrc
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/filetype.vim"
Searching for "/Users/jmoussa/.vim/after/filetype.vim"
Searching for "ftplugin.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/ftplugin.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/ftplugin.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 23: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2006 Apr 30
line 5: 
line 6: if exists("did_load_ftplugin")
line 7:   finish
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim
continuing in /Users/jmoussa/.vimrc
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/ftplugin.vim"
Searching for "/Users/jmoussa/.vim/after/ftplugin.vim"
line 24: 
line 25: "Pathogen Plugin Manager
line 26: execute pathogen#infect()
Searching for "autoload/pathogen.vim" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/autoload/pathogen.vim"
chdir(/Users/jmoussa/.vim/autoload)
fchdir() to previous dir
line 26: sourcing "/Users/jmoussa/.vim/autoload/pathogen.vim"
line 1: " pathogen.vim - path option manipulation
line 2: " Maintainer:   Tim Pope <http://tpo.pe/>
line 3: " Version:      2.4
line 4: 
line 5: " Install in ~/.vim/autoload (or ~\vimfiles\autoload).
line 6: "
line 7: " For management of individually installed plugins in ~/.vim/bundle (or
line 8: " ~\vimfiles\bundle), adding `execute pathogen#infect()` to the top of your
line 9: " .vimrc is the only other setup necessary.
line 10: "
line 11: " The API is documented inline below.
line 12: 
line 13: if exists("g:loaded_pathogen") || &cp
line 14:   finish
line 15: endif
line 16: let g:loaded_pathogen = 1
line 17: 
line 18: " Point of entry for basic default usage.  Give a relative path to invoke
line 19: " pathogen#interpose() (defaults to "bundle/{}"), or an absolute path to invoke
line 20: " pathogen#surround().  Curly braces are expanded with pathogen#expand():
line 21: " "bundle/{}" finds all subdirectories inside "bundle" inside all directories
line 22: " in the runtime path.
line 23: function! pathogen#infect(...) abort
line 43: 
line 44: " Split a path into a list.
line 45: function! pathogen#split(path) abort
line 51: 
line 52: " Convert a list to a path.
line 53: function! pathogen#join(...) abort
line 78: 
line 79: " Convert a list to a path with escaped spaces for 'path', 'tag', etc.
line 80: function! pathogen#legacyjoin(...) abort
line 83: 
line 84: " Turn filetype detection off and back on again if it was already enabled.
line 85: function! pathogen#cycle_filetype() abort
line 91: 
line 92: " Check if a bundle is disabled.  A bundle is considered disabled if its
line 93: " basename or full name is included in the list g:pathogen_blacklist or the
line 94: " comma delimited environment variable $VIMBLACKLIST.
line 95: function! pathogen#is_disabled(path) abort
line 108: 
line 109: " Prepend the given directory to the runtime path and append its corresponding
line 110: " after directory.  Curly braces are expanded with pathogen#expand().
line 111: function! pathogen#surround(path) abort
line 121: 
line 122: " For each directory in the runtime path, add a second entry with the given
line 123: " argument appended.  Curly braces are expanded with pathogen#expand().
line 124: function! pathogen#interpose(name) abort
line 142: 
line 143: let s:done_bundles = {}
line 144: 
line 145: " Invoke :helptags on all non-$VIM doc directories in runtimepath.
line 146: function! pathogen#helptags() abort
line 156: 
line 157: command! -bar Helptags :call pathogen#helptags()
line 158: 
line 159: " Execute the given command.  This is basically a backdoor for --remote-expr.
line 160: function! pathogen#execute(...) abort
line 166: 
line 167: " Section: Unofficial
line 168: 
line 169: function! pathogen#is_absolute(path) abort
line 172: 
line 173: " Given a string, returns all possible permutations of comma delimited braced
line 174: " alternatives of that string.  pathogen#expand('/{a,b}/{c,d}') yields
line 175: " ['/a/c', '/a/d', '/b/c', '/b/d'].  Empty braces are treated as a wildcard
line 176: " and globbed.  Actual globs are preserved.
line 177: function! pathogen#expand(pattern, ...) abort
line 197: 
line 198: " \ on Windows unless shellslash is set, / everywhere else.
line 199: function! pathogen#slash() abort
line 202: 
line 203: function! pathogen#separator() abort
line 206: 
line 207: " Convenience wrapper around glob() which returns a list.
line 208: function! pathogen#glob(pattern) abort
line 212: 
line 213: " Like pathogen#glob(), only limit the results to directories.
line 214: function! pathogen#glob_directories(pattern) abort
line 217: 
line 218: " Remove duplicates from a list.
line 219: function! pathogen#uniq(list) abort
line 235: 
line 236: " Backport of fnameescape().
line 237: function! pathogen#fnameescape(string) abort
line 246: 
line 247: " Like findfile(), but hardcoded to use the runtimepath.
line 248: function! pathogen#runtime_findfile(file,count) abort
line 257: 
line 258: " Section: Deprecated
line 259: 
line 260: function! s:warn(msg) abort
line 265: 
line 266: " Prepend all subdirectories of path to the rtp, and append all 'after'
line 267: " directories in those subdirectories.  Deprecated.
line 268: function! pathogen#runtime_prepend_subdirectories(path) abort
line 272: 
line 273: function! pathogen#incubate(...) abort
line 278: 
line 279: " Deprecated alias for pathogen#interpose().
line 280: function! pathogen#runtime_append_all_bundles(...) abort
line 288: 
line 289: if exists(':Vedit')
line 290:   finish
line 291: endif
line 292: 
line 293: let s:vopen_warning = 0
line 294: 
line 295: function! s:find(count,cmd,file,lcd)
line 315: 
line 316: function! s:Findcomplete(A,L,P)
line 343: 
line 344: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Ve       :execute s:find(<count>,'edit<bang>',<q-args>,0)
line 345: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vedit    :execute s:find(<count>,'edit<bang>',<q-args>,0)
line 346: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vopen    :execute s:find(<count>,'edit<bang>',<q-args>,1)
line 347: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vsplit   :execute s:find(<count>,'split',<q-args>,<bang>1)
line 348: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vvsplit  :execute s:find(<count>,'vsplit',<q-args>,<bang>1)
line 349: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vtabedit :execute s:find(<count>,'tabedit',<q-args>,<bang>1)
line 350: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vpedit   :execute s:find(<count>,'pedit',<q-args>,<bang>1)
line 351: command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vread    :execute s:find(<count>,'read',<q-args>,<bang>1)
line 352: 
line 353: " vim:set et sw=2 foldmethod=expr foldexpr=getline(v\:lnum)=~'^\"\ Section\:'?'>1'\:getline(v\:lnum)=~#'^fu'?'a1'\:getline(v\:lnum)=~#'^endf'?'s1'\:'=':
finished sourcing /Users/jmoussa/.vim/autoload/pathogen.vim
continuing in /Users/jmoussa/.vimrc
calling function pathogen#infect()

line 1:   for path in a:0 ? filter(reverse(copy(a:000)), 'type(v:val) == type("")') : ['bundle/{}']
line 2:     if path =~# '^\%({\=[$~\\/]\|{\=\w:[\\/]\).*[{}*]'
line 3:       call pathogen#surround(path)
line 4:     elseif path =~# '^\%([$~\\/]\|\w:[\\/]\)'
line 5:       call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
line 6:       call pathogen#surround(path . '/{}')
line 7:     elseif path =~# '[{}*]'
line 8:       call pathogen#interpose(path)
calling function pathogen#infect[8]..pathogen#interpose('bundle/{}')

line 1:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[1]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[1]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose

line 2:   let name = a:name
line 3:   if has_key(s:done_bundles, name)
line 4:     return ""
line 5:   endif
line 6:   let s:done_bundles[name] = 1
line 7:   let list = []
line 8:   for dir in pathogen#split(&rtp)
calling function pathogen#infect[8]..pathogen#interpose[8]..pathogen#split('/Users/jmoussa/.vim,/usr/local/Cellar...mfiles/after,/Users/jmoussa/.vim/after')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
line 2:  endif
line 3:   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
line 4:   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')
function pathogen#infect[8]..pathogen#interpose[8]..pathogen#split returning ['/Users/jmoussa/.vim', '/usr/local/Ce...es/after', '/Users/jmoussa/.vim/after']

continuing in function pathogen#infect[8]..pathogen#interpose

line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand('/Users/jmoussa/.vim/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand returning ['/Users/jmoussa/.vim/bundle/auto-pair...ers/jmoussa/.vim/bundle/youcompleteme']

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/auto-pairs')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/ctrlp.vim')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/emmet-vim')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/nerdtree')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/syntastic')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/tlib_vim')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/vim-addon-mw-utils')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/vim-snipmate')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/vim-snippets')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/youcompleteme')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand('/usr/local/Cellar/macvim/8.0-140/MacV...tents/Resources/vim/vimfiles/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand('/usr/local/Cellar/macvim/8.0-140/MacV...ntents/Resources/vim/runtime/bundle/{}')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[12]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand('/usr/local/Cellar/macvim/8.0-140/MacV...tents/Resources/vim/vimfiles/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand returning []

continuing in function pathogen#infect[8]..pathogen#interpose

line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand('/Users/jmoussa/.vim/bundle/{}', '/after')

line 1:   let after = a:0 ? a:1 : ''
line 2:   if a:pattern =~# '{[^{}]\+}'
line 3:     let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
line 4:     let found = map(split(pat, ',', 1), 'pre.v:val.post')
line 5:     let results = []
line 6:     for pattern in found
line 7:       call extend(results, pathogen#expand(pattern))
line 8:     endfor
line 9:   elseif a:pattern =~# '{}'
line 10:     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
line 11:     let post = a:pattern[strlen(pat) : -1]
line 12:     let results = map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
line 13:   else
line 14:     let results = [a:pattern]
line 15:   endif
line 16:   let vf = pathogen#slash() . 'vimfiles'
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand[16]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand

line 17:   call map(results, 'v:val =~# "\\*" ? v:val.after : isdirectory(v:val.vf.after) ? v:val.vf.after : isdirectory(v:val.after) ? v:val.after : ""')
line 18:   return filter(results, '!empty(v:val)')
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#expand returning ['/Users/jmoussa/.vim/bundle/vim-snipmate/after']

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#is_disabled('/Users/jmoussa/.vim/bundle/vim-snipmate')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[8]..pathogen#interpose[10]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[8]..pathogen#interpose[10]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[8]..pathogen#interpose[10]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[8]..pathogen#interpose[10]..pathogen#is_disabled returning #0

continuing in function pathogen#infect[8]..pathogen#interpose

line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 8:   for dir in pathogen#split(&rtp)
line 9:     if dir =~# '\<after$'
line 10:       let list += reverse(filter(pathogen#expand(dir[0:-6].name, sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
line 11:     else
line 12:       let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
line 13:     endif
line 14:   endfor
line 15:   let &rtp = pathogen#join(pathogen#uniq(list))
calling function pathogen#infect[8]..pathogen#interpose[15]..pathogen#uniq(['/Users/jmoussa/.vim', '/Users/jmouss...te/after', '/Users/jmoussa/.vim/after'])

line 1:   let i = 0
line 2:   let seen = {}
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 3:   while i < len(a:list)
line 4:     if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
line 5:       call remove(a:list,i)
line 6:     elseif a:list[i] ==# ''
line 7:       let i += 1
line 8:       let empty = 1
line 9:     else
line 10:       let seen[a:list[i]] = 1
line 11:       let i += 1
line 12:     endif
line 13:   endwhile
line 14:   return a:list
function pathogen#infect[8]..pathogen#interpose[15]..pathogen#uniq returning ['/Users/jmoussa/.vim', '/Users/jmouss...te/after', '/Users/jmoussa/.vim/after']

continuing in function pathogen#infect[8]..pathogen#interpose

calling function pathogen#infect[8]..pathogen#interpose[15]..pathogen#join(['/Users/jmoussa/.vim', '/Users/jmouss...te/after', '/Users/jmoussa/.vim/after'])

line 1:   if type(a:1) == type(1) && a:1
line 2:     let i = 1
line 3:     let space = ' '
line 4:   else
line 5:     let i = 0
line 6:     let space = ''
line 7:   endif
line 8:   let path = ""
line 9:   while i < a:0
line 10:     if type(a:000[i]) == type([])
line 11:       let list = a:000[i]
line 12:       let j = 0
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 18:     else
line 19:       let path .= "," . a:000[i]
line 20:     endif
line 21:     let i += 1
line 22:   endwhile
line 9:   while i < a:0
line 10:     if type(a:000[i]) == type([])
line 11:       let list = a:000[i]
line 12:       let j = 0
line 13:       while j < len(list)
line 14:         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
line 15:         let path .= ',' . escaped
line 16:         let j += 1
line 17:       endwhile
line 18:     else
line 19:       let path .= "," . a:000[i]
line 20:     endif
line 21:     let i += 1
line 22:   endwhile
line 23:   return substitute(path,'^,','','')
function pathogen#infect[8]..pathogen#interpose[15]..pathogen#join returning '/Users/jmoussa/.vim,/Users/jmoussa/.v...ipmate/after,/Users/jmoussa/.vim/after'

continuing in function pathogen#infect[8]..pathogen#interpose

line 16:   return 1
function pathogen#infect[8]..pathogen#interpose returning #1

continuing in function pathogen#infect

line 9:     else
line 10:       call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
line 11:       call pathogen#interpose(path . '/{}')
line 12:     endif
line 13:   endfor
line 1:   for path in a:0 ? filter(reverse(copy(a:000)), 'type(v:val) == type("")') : ['bundle/{}']
line 2:     if path =~# '^\%({\=[$~\\/]\|{\=\w:[\\/]\).*[{}*]'
line 3:       call pathogen#surround(path)
line 4:     elseif path =~# '^\%([$~\\/]\|\w:[\\/]\)'
line 5:       call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
line 6:       call pathogen#surround(path . '/{}')
line 7:     elseif path =~# '[{}*]'
line 8:       call pathogen#interpose(path)
line 9:     else
line 10:       call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
line 11:       call pathogen#interpose(path . '/{}')
line 12:     endif
line 13:   endfor
line 14:   call pathogen#cycle_filetype()
calling function pathogen#infect[14]..pathogen#cycle_filetype()

line 1:   if exists('g:did_load_filetypes')
line 2:     filetype off
Searching for "ftoff.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/syntastic/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/tlib_vim/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snippets/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/youcompleteme/ftoff.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/ftoff.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 2: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim"
line 1: " Vim support file to switch off detection of file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last change:^I2001 Jun 11
line 5: 
line 6: if exists("did_load_filetypes")
line 7:   unlet did_load_filetypes
line 8: endif
line 9: 
line 10: " Remove all autocommands in the filetypedetect group
line 11: silent! au! filetypedetect *
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim
continuing in function pathogen#infect[14]..pathogen#cycle_filetype
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/ftoff.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/after/ftoff.vim"
Searching for "/Users/jmoussa/.vim/after/ftoff.vim"
line 3:     filetype on
Searching for "filetype.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/syntastic/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/tlib_vim/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snippets/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/youcompleteme/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/filetype.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime)
fchdir() to previous dir
line 3: sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>
line 4: " Last Change:^I2017 Aug 11
line 5: 
line 6: " Listen very carefully, I will say this only once
line 7: if exists("did_load_filetypes")
line 8:   finish
line 9: endif
line 10: let did_load_filetypes = 1
line 11: 
line 12: " Line continuation is used here, remove 'C' from 'cpoptions'
line 13: let s:cpo_save = &cpo
line 14: set cpo&vim
line 15: 
line 16: augroup filetypedetect
line 17: 
line 18: " Ignored extensions
line 19: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 33: elseif &verbose > 0
line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 35: endif
line 36: 
line 37: " Pattern used to match file names which should not be inspected.
line 38: " Currently finds compressed files.
line 39: if !exists("g:ft_ignore_pat")
line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 41: endif
line 42: 
line 43: " Function used for patterns that end in a star: don't set the filetype if the
line 44: " file name matches ft_ignore_pat.
line 45: func! s:StarSetf(ft)
line 50: 
line 51: " Vim help file
line 52: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 53: 
line 54: " Abaqus or Trasys
line 55: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()
line 56: 
line 57: func! s:Check_inp()
line 76: 
line 77: " A-A-P recipe
line 78: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 79: 
line 80: " A2ps printing utility
line 81: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 82: 
line 83: " ABAB/4
line 84: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 85: 
line 86: " ABC music notation
line 87: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 88: 
line 89: " ABEL
line 90: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 91: 
line 92: " AceDB
line 93: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 94: 
line 95: " Ada (83, 9X, 95)
line 96: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 97: if has("vms")
line 98:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 99: else
line 100:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 101: endif
line 102: 
line 103: " AHDL
line 104: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 105: 
line 106: " AMPL
line 107: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 108: 
line 109: " Ant
line 110: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 111: 
line 112: " Arduino
line 113: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 114: 
line 115: " Apache style config file
line 116: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')
line 117: 
line 118: " Apache config file
line 119: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 120: 
line 121: " XA65 MOS6510 cross assembler
line 122: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 123: 
line 124: " Applescript
line 125: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 126: 
line 127: " Applix ELF
line 129: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
line 130: 
line 131: " ALSA configuration
line 132: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 133: 
line 134: " Arc Macro Language
line 135: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 136: 
line 137: " APT config file
line 138: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 139: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 140: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
line 141: 
line 142: " Arch Inventory file
line 143: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 144: 
line 145: " ART*Enterprise (formerly ART-IM)
line 146: au BufNewFile,BufRead *.art^I^I^Isetf art
line 147: 
line 148: " AsciiDoc
line 149: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 150: 
line 151: " ASN.1
line 152: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 153: 
line 154: " Active Server Pages (with Visual Basic Script)
line 160: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 161: 
line 162: " Active Server Pages (with Perl or Visual Basic Script)
line 170: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 171: 
line 172: " Grub (must be before catch *.lst)
line 173: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 174: 
line 175: " Assembly (all kinds)
line 176: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 177: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()
line 178: 
line 179: " This function checks for the kind of assembly that is wanted by the user, or
line 180: " can be detected from the first five lines of the file.
line 181: func! s:FTasm()
line 202: 
line 203: func! s:FTasmsyntax()
line 215: 
line 216: " Macro (VAX)
line 217: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 218: 
line 219: " Atlas
line 220: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 221: 
line 222: " Autoit v3
line 223: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 224: 
line 225: " Autohotkey
line 226: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 227: 
line 228: " Automake
line 229: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 230: 
line 231: " Autotest .at files are actually m4
line 232: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 233: 
line 234: " Avenue
line 235: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 236: 
line 237: " Awk
line 238: au BufNewFile,BufRead *.awk^I^I^Isetf awk
line 239: 
line 240: " B
line 241: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 242: 
line 243: " BASIC or Visual Basic
line 244: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")
line 245: 
line 246: " Check if one of the first five lines contains "VB_Name".  In that case it is
line 247: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
line 248: func! s:FTVB(alt)
line 255: 
line 256: " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
line 257: au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl^Isetf vb
line 258: 
line 259: " IBasic file (similar to QBasic)
line 260: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 261: 
line 262: " FreeBasic file (similar to QBasic)
line 263: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic
line 264: 
line 265: " Batch file for MSDOS.
line 266: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch
line 267: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 269: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 270: 
line 271: " Batch file for 4DOS
line 272: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()
line 273: func! s:FTbtm()
line 280: 
line 281: " BC calculator
line 282: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 283: 
line 284: " BDF font
line 285: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 286: 
line 287: " BibTeX bibliography database file
line 288: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 289: 
line 290: " BibTeX Bibliography Style
line 291: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 292: 
line 293: " BIND configuration
line 294: " sudoedit uses namedXXXX.conf
line 295: au BufNewFile,BufRead named*.conf,rndc*.conf^Isetf named
line 296: 
line 297: " BIND zone
line 298: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 299: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')
line 300: 
line 301: func! s:BindzoneCheck(default)
line 308: 
line 309: " Blank
line 310: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 311: 
line 312: " Blkid cache file
line 313: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 314: 
line 315: " Bazel (http://bazel.io)
line 316: autocmd BufRead,BufNewFile *.bzl,WORKSPACE ^Isetf bzl
line 317: if has("fname_case")
line 318:   " There is another check for BUILD further below.
line 319:   autocmd BufRead,BufNewFile BUILD^I^Isetf bzl
line 320: endif
line 321: 
line 322: " C or lpc
line 323: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()
line 324: 
line 325: func! s:FTlpc()
line 338: 
line 339: " Calendar
line 340: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 341: 
line 342: " C#
line 343: au BufNewFile,BufRead *.cs^I^I^Isetf cs
line 344: 
line 345: " CSDL
line 346: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 347: 
line 348: " Cabal
line 349: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 350: 
line 351: " Cdrdao TOC
line 352: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 353: 
line 354: " Cdrdao config
line 355: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 356: 
line 357: " Cfengine
line 358: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 359: 
line 360: " ChaiScript
line 361: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 362: 
line 363: " Comshare Dimension Definition Language
line 364: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 365: 
line 366: " Conary Recipe
line 367: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 368: 
line 369: " Controllable Regex Mutilator
line 370: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 371: 
line 372: " Cyn++
line 373: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 374: 
line 375: " Cynlib
line 376: " .cc and .cpp files can be C++ or Cynlib.
line 378: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 380: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 381: 
line 382: " C++
line 383: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 384: if has("fname_case")
line 385:   au BufNewFile,BufRead *.C,*.H setf cpp
line 386: endif
line 387: 
line 388: " .h files can be C, Ch C++, ObjC or ObjC++.
line 389: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 390: " detected automatically.
line 391: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()
line 392: 
line 393: func! s:FTheader()
line 408: 
line 409: " Ch (CHscript)
line 410: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 411: 
line 412: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 413: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 414: 
line 415: " Cascading Style Sheets
line 416: au BufNewFile,BufRead *.css^I^I^Isetf css
line 417: 
line 418: " Century Term Command Scripts (*.cmd too)
line 419: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 420: 
line 421: " Changelog
line 423: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog
line 424: 
line 430: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 431: 
line 435: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 436: 
line 437: " CHILL
line 438: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 439: 
line 440: " Changes for WEB and CWEB or CHILL
line 441: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()
line 442: 
line 443: " This function checks if one of the first ten lines start with a '@'.  In
line 444: " that case it is probably a change file.
line 445: " If the first line starts with # or ! it's probably a ch file.
line 446: " If a line has "main", "include", "//" ir "/*" it's probably ch.
line 447: " Otherwise CHILL is assumed.
line 448: func! s:FTchange()
line 471: 
line 472: " ChordPro
line 473: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 474: 
line 475: " Clean
line 476: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 477: 
line 478: " Clever
line 479: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 480: 
line 481: " Clever or dtd
line 482: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()
line 483: 
line 484: func! s:FTent()
line 503: 
line 504: " Clipper (or FoxPro; could also be eviews)
line 510: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif
line 511: 
line 512: " Clojure
line 513: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 514: 
line 515: " Cmake
line 516: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 517: 
line 518: " Cmusrc
line 519: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 520: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 521: 
line 522: " Cobol
line 523: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 524: "   cobol or zope form controller python script? (heuristic)
line 530: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 531: 
line 532: " Coco/R
line 533: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 534: 
line 535: " Cold Fusion
line 536: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 537: 
line 538: " Configure scripts
line 539: au BufNewFile,BufRead configure.in,configure.ac setf config
line 540: 
line 541: " CUDA  Cumpute Unified Device Architecture
line 542: au BufNewFile,BufRead *.cu^I^I^Isetf cuda
line 543: 
line 544: " Dockerfile
line 545: au BufNewFile,BufRead Dockerfile,*.Dockerfile^Isetf dockerfile
line 546: 
line 547: " WildPackets EtherPeek Decoder
line 548: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 549: 
line 550: " Enlightenment configuration files
line 551: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 552: 
line 553: " Eterm
line 554: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 555: 
line 556: " Euphoria 3 or 4
line 557: au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
line 558: if has("fname_case")
line 559:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
line 560: endif
line 561: 
line 562: func! s:EuphoriaCheck()
line 569: 
line 570: " Lynx config files
line 571: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 572: 
line 573: " Quake
line 574: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 575: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 576: 
line 577: " Quake C
line 578: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 579: 
line 580: " Configure files
line 581: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg
line 582: 
line 583: " Cucumber
line 584: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 585: 
line 586: " Communicating Sequential Processes
line 587: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 588: 
line 589: " CUPL logic description and simulation
line 590: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 591: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 592: 
line 593: " Debian Control
line 594: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 598: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 599: 
line 600: " Debian Sources.list
line 601: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 602: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 603: 
line 604: " Deny hosts
line 605: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 606: 
line 607: " dnsmasq(8) configuration files
line 608: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 609: 
line 610: " ROCKLinux package description
line 611: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 612: 
line 613: " the D language or dtrace
line 614: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()
line 615: 
line 616: func! s:DtraceCheck()
line 627: 
line 628: " Desktop files
line 629: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop
line 630: 
line 631: " Dict config
line 632: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 633: 
line 634: " Dictd config
line 635: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf
line 636: 
line 637: " Diff files
line 638: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 644: au BufNewFile,BufRead *.patch if getline(1) =~ '^From [0-9a-f]\{40\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 645: 
line 646: " Dircolors
line 647: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 648: 
line 649: " Diva (with Skill) or InstallShield
line 655: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 656: 
line 657: " DCL (Digital Command Language - vms) or DNS zone file
line 658: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')
line 659: 
line 660: " DOT
line 661: au BufNewFile,BufRead *.dot^I^I^Isetf dot
line 662: 
line 663: " Dylan - lid files
line 664: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 665: 
line 666: " Dylan - intr files (melange)
line 667: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 668: 
line 669: " Dylan
line 670: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 671: 
line 672: " Microsoft Module Definition
line 673: au BufNewFile,BufRead *.def^I^I^Isetf def
line 674: 
line 675: " Dracula
line 676: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 677: 
line 678: " Datascript
line 679: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 680: 
line 681: " dsl
line 682: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl
line 683: 
line 684: " DTD (Document Type Definition for XML)
line 685: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 686: 
line 687: " DTS/DSTI (device tree files)
line 688: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 689: 
line 690: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 691: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 697: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 698: 
line 699: " EditorConfig (close enough to dosini)
line 700: au BufNewFile,BufRead .editorconfig^I^Isetf dosini
line 701: 
line 702: " Embedix Component Description
line 703: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 704: 
line 705: " Eiffel or Specman or Euphoria
line 706: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()
line 707: 
line 708: " Elinks configuration
line 709: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks
line 710: 
line 711: func! s:FTe()
line 726: 
line 727: " ERicsson LANGuage; Yaws is erlang too
line 728: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 729: 
line 730: " Elm Filter Rules file
line 731: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 732: 
line 733: " ESMTP rc file
line 734: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 735: 
line 736: " ESQL-C
line 737: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 738: 
line 739: " Esterel
line 740: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 741: 
line 742: " Essbase script
line 743: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 744: 
line 745: " Exim
line 746: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 747: 
line 748: " Expect
line 749: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 750: 
line 751: " Exports
line 752: au BufNewFile,BufRead exports^I^I^Isetf exports
line 753: 
line 754: " Falcon
line 755: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 756: 
line 757: " Fantom
line 758: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 759: 
line 760: " Factor
line 761: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 762: 
line 763: " Fetchmail RC file
line 764: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 765: 
line 766: " FlexWiki - disabled, because it has side effects when a .wiki file
line 767: " is not actually FlexWiki
line 768: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 769: 
line 770: " Focus Executable
line 771: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 772: 
line 773: " Focus Master file (but not for auto.master)
line 774: au BufNewFile,BufRead auto.master^I^Isetf conf
line 775: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 776: 
line 777: " Forth
line 778: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth
line 779: 
line 780: " Reva Forth
line 781: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 782: 
line 783: " Fortran
line 784: if has("fname_case")
line 785:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran
line 786: endif
line 787: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
line 788: 
line 789: " Framescript
line 790: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 791: 
line 792: " FStab
line 793: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 794: 
line 795: " GDB command files
line 796: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb
line 797: 
line 798: " GDMO
line 799: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 800: 
line 801: " Gedcom
line 802: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 803: 
line 804: " Git
line 805: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG setf gitcommit
line 806: au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
line 807: au BufNewFile,BufRead *.git/modules/*/config^Isetf gitconfig
line 808: au BufNewFile,BufRead */.config/git/config^Isetf gitconfig
line 809: if !empty($XDG_CONFIG_HOME)
line 810:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^Isetf gitconfig
line 811: endif
line 812: au BufNewFile,BufRead git-rebase-todo^I^Isetf gitrebase
line 813: au BufRead,BufNewFile .gitsendemail.msg.??????^Isetf gitsendemail
line 817: au BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif
line 821: au BufNewFile,BufRead *.git/* if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif
line 822: 
line 823: " Gkrellmrc
line 824: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 825: 
line 826: " GP scripts (2.0 and onward)
line 827: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 828: 
line 829: " GPG
line 830: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 831: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 832: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 833: if !empty($GNUPGHOME)
line 834:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 835:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 836: endif
line 837: 
line 838: " gnash(1) configuration files
line 839: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 840: 
line 841: " Gitolite
line 842: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 843: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 844: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 845: 
line 846: " Gnuplot scripts
line 847: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot
line 848: 
line 849: " Go (Google)
line 850: au BufNewFile,BufRead *.go^I^I^Isetf go
line 851: 
line 852: " GrADS scripts
line 853: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 854: 
line 855: " Gretl
line 856: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 857: 
line 858: " Groovy
line 859: au BufNewFile,BufRead *.gradle,*.groovy^I^Isetf groovy
line 860: 
line 861: " GNU Server Pages
line 862: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 863: 
line 864: " Group file
line 865: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 866: 
line 867: " GTK RC
line 868: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 869: 
line 870: " Haml
line 871: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 872: 
line 873: " Hamster Classic | Playground files
line 874: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster
line 875: 
line 876: " Haskell
line 877: au BufNewFile,BufRead *.hs,*.hs-boot^I^Isetf haskell
line 878: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 879: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 880: 
line 881: " Haste
line 882: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 883: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 884: 
line 885: " Hercules
line 886: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 887: 
line 888: " HEX (Intel)
line 889: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 890: 
line 891: " Tilde (must be before HTML)
line 892: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 893: 
line 894: " HTML (.shtml and .stm for server side)
line 895: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
line 896: 
line 897: " Distinguish between HTML, XHTML and Django
line 898: func! s:FThtml()
line 913: 
line 914: " HTML with Ruby - eRuby
line 915: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 916: 
line 917: " HTML with M4
line 918: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 919: 
line 920: " HTML Cheetah template
line 921: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah
line 922: 
line 923: " Host config
line 924: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 925: 
line 926: " Hosts access
line 927: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 928: 
line 929: " Hyper Builder
line 930: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 931: 
line 932: " Httest
line 933: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 934: 
line 935: " Icon
line 936: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 937: 
line 938: " IDL (Interface Description Language)
line 939: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()
line 940: 
line 941: " Distinguish between standard IDL and MS-IDL
line 942: func! s:FTidl()
line 953: 
line 954: " Microsoft IDL (Interface Description Language)  Also *.idl
line 955: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 956: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 957: 
line 958: " Icewm menu
line 959: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 960: 
line 961: " Indent profile (must come before IDL *.pro!)
line 962: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 963: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')
line 964: 
line 965: " IDL (Interactive Data Language)
line 966: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')
line 967: 
line 968: " Distinguish between "default" and Cproto prototype file. */
line 969: func! s:ProtoCheck(default)
line 981: 
line 982: 
line 983: " Indent RC
line 984: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 985: 
line 986: " Inform
line 987: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 988: 
line 989: " Initng
line 990: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 991: 
line 992: " Innovation Data Processing
line 993: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c ^Isetf upstreamdat
line 994: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c ^Isetf upstreamlog
line 995: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 996: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c ^Isetf usserverlog
line 997: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c ^Isetf usw2kagtlog
line 998: 
line 999: " Ipfilter
line 1000: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 1001: 
line 1002: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 1003: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 1004: 
line 1005: " .INI file for MSDOS
line 1006: au BufNewFile,BufRead *.ini^I^I^Isetf dosini
line 1007: 
line 1008: " SysV Inittab
line 1009: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 1010: 
line 1011: " Inno Setup
line 1012: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 1013: 
line 1014: " J
line 1015: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 1016: 
line 1017: " JAL
line 1018: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 1019: 
line 1020: " Jam
line 1021: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 1022: 
line 1023: " Java
line 1024: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 1025: 
line 1026: " JavaCC
line 1027: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 1028: 
line 1029: " JavaScript, ECMAScript
line 1030: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx,*.mjs   setf javascript
line 1031: 
line 1032: " Java Server Pages
line 1033: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 1034: 
line 1035: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 1036: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 1037: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 1038: 
line 1039: " Jess
line 1040: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 1041: 
line 1042: " Jgraph
line 1043: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 1044: 
line 1045: " Jovial
line 1046: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 1047: 
line 1048: " JSON
line 1049: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 1050: 
line 1051: " Kixtart
line 1052: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 1053: 
line 1054: " Kimwitu[++]
line 1055: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 1056: 
line 1057: " Kivy
line 1058: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 1059: 
line 1060: " KDE script
line 1061: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 1062: 
line 1063: " Kconfig
line 1064: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1065: 
line 1066: " Lace (ISE)
line 1067: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1068: 
line 1069: " Latte
line 1070: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1071: 
line 1072: " Limits
line 1073: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1074: 
line 1075: " LambdaProlog (*.mod too, see Modsim)
line 1076: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog
line 1077: 
line 1078: " LDAP LDIF
line 1079: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1080: 
line 1081: " Ld loader
line 1082: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1083: 
line 1084: " Less
line 1085: au BufNewFile,BufRead *.less^I^I^Isetf less
line 1086: 
line 1087: " Lex
line 1088: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 1089: 
line 1090: " Libao
line 1091: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1092: 
line 1093: " Libsensors
line 1094: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1095: 
line 1096: " LFTP
line 1097: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1098: 
line 1099: " Lifelines (or Lex for C++!)
line 1100: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1101: 
line 1102: " Lilo: Linux loader
line 1103: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1104: 
line 1105: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
line 1106: if has("fname_case")
line 1107:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
line 1108: else
line 1109:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
line 1110: endif
line 1111: 
line 1112: " SBCL implementation of Common Lisp
line 1113: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1114: 
line 1115: " Liquid
line 1116: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1117: 
line 1118: " Lite
line 1119: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1120: 
line 1121: " LiteStep RC files
line 1122: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1123: 
line 1124: " Login access
line 1125: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1126: 
line 1127: " Login defs
line 1128: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1129: 
line 1130: " Logtalk
line 1131: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1132: 
line 1133: " LOTOS
line 1134: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1135: 
line 1136: " Lout (also: *.lt)
line 1137: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1138: 
line 1139: " Lua
line 1140: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1141: 
line 1142: " Luarocks
line 1143: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 1144: 
line 1145: " Linden Scripting Language (Second Life)
line 1146: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl
line 1147: 
line 1148: " Lynx style file (or LotusScript!)
line 1149: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1150: 
line 1151: " M4
line 1153: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1154: 
line 1155: " MaGic Point
line 1156: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1157: 
line 1158: " Mail (for Elm, trn, mutt, muttng, rn, slrn)
line 1159: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1160: 
line 1161: " Mail aliases
line 1162: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1163: 
line 1164: " Mailcap configuration file
line 1165: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1166: 
line 1167: " Makefile
line 1168: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1169: 
line 1170: " MakeIndex
line 1171: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1172: 
line 1173: " Mallard
line 1174: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1175: 
line 1176: " Manpage
line 1177: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1178: 
line 1179: " Man config
line 1180: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1181: 
line 1182: " Maple V
line 1183: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1184: 
line 1185: " Map (UMN mapserver config file)
line 1186: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1187: 
line 1188: " Markdown
line 1189: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 1190: 
line 1191: " Mason
line 1192: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 1193: 
line 1194: " Mathematica, Matlab, Murphi or Objective C
line 1195: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()
line 1196: 
line 1197: func! s:FTm()
line 1240: 
line 1241: " Mathematica notebook
line 1242: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1243: 
line 1244: " Maya Extension Language
line 1245: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1246: 
line 1247: " Mercurial (hg) commit file
line 1248: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1249: 
line 1250: " Mercurial config (looks like generic config file)
line 1251: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1252: 
line 1253: " Messages (logs mostly)
line 1254: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1255: 
line 1256: " Metafont
line 1257: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1258: 
line 1259: " MetaPost
line 1260: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1261: 
line 1262: " MGL
line 1263: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1264: 
line 1265: " MIX - Knuth assembly
line 1266: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 1267: 
line 1268: " MMIX or VMS makefile
line 1269: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()
line 1270: 
line 1271: " Symbian meta-makefile definition (MMP)
line 1272: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1273: 
line 1274: func! s:FTmms()
line 1290: 
line 1291: 
line 1292: " Modsim III (or LambdaProlog)
line 1298: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif
line 1299: 
line 1300: " Modula 2  (.md removed in favor of Markdown)
line 1301: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi^Isetf modula2
line 1302: 
line 1303: " Modula 3 (.m3, .i3, .mg, .ig)
line 1304: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1305: 
line 1306: " Monk
line 1307: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1308: 
line 1309: " MOO
line 1310: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1311: 
line 1312: " Modconf
line 1313: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1314: 
line 1315: " Mplayer config
line 1316: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1317: 
line 1318: " Motorola S record
line 1319: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1320: 
line 1321: " Mrxvtrc
line 1322: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1323: 
line 1324: " Msql
line 1325: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1326: 
line 1327: " Mysql
line 1328: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1329: 
line 1330: " Mutt setup files (must be before catch *.rc)
line 1331: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 1332: 
line 1333: " M$ Resource files
line 1334: au BufNewFile,BufRead *.rc,*.rch^I^Isetf rc
line 1335: 
line 1336: " MuPAD source
line 1337: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1338: 
line 1339: " Mush
line 1340: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1341: 
line 1342: " Mutt setup file (also for Muttng)
line 1343: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1344: 
line 1345: " N1QL
line 1346: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1347: 
line 1348: " Nano
line 1349: au BufNewFile,BufRead */etc/nanorc,*.nanorc  ^Isetf nanorc
line 1350: 
line 1351: " Nastran input/DMAP
line 1352: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1353: 
line 1354: " Natural
line 1355: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1356: 
line 1357: " Netrc
line 1358: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1359: 
line 1360: " Ninja file
line 1361: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1362: 
line 1363: " Novell netware batch files
line 1364: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1365: 
line 1366: " Nroff/Troff (*.ms and *.t are checked below)
line 1370: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1371: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1372: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()
line 1373: 
line 1374: " This function checks if one of the first five lines start with a dot.  In
line 1375: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
line 1376: func! s:FTnroff()
line 1383: 
line 1384: " Nroff or Objective C++
line 1385: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()
line 1386: 
line 1387: func! s:FTmm()
line 1399: 
line 1400: " Not Quite C
line 1401: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1402: 
line 1403: " NSE - Nmap Script Engine - uses Lua syntax
line 1404: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1405: 
line 1406: " NSIS
line 1407: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1408: 
line 1409: " OCAML
line 1410: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit^Isetf ocaml
line 1411: 
line 1412: " Occam
line 1413: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1414: 
line 1415: " Omnimark
line 1416: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1417: 
line 1418: " OpenROAD
line 1419: au BufNewFile,BufRead *.or^I^I^Isetf openroad
line 1420: 
line 1421: " OPL
line 1422: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl
line 1423: 
line 1424: " Oracle config file
line 1425: au BufNewFile,BufRead *.ora^I^I^Isetf ora
line 1426: 
line 1427: " Packet filter conf
line 1428: au BufNewFile,BufRead pf.conf^I^I^Isetf pf
line 1429: 
line 1430: " Pam conf
line 1431: au BufNewFile,BufRead */etc/pam.conf^I^Isetf pamconf
line 1432: 
line 1433: " PApp
line 1434: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp
line 1435: 
line 1436: " Password file
line 1437: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1438: 
line 1439: " Pascal (also *.p)
line 1440: au BufNewFile,BufRead *.pas^I^I^Isetf pascal
line 1441: 
line 1442: " Delphi project file
line 1443: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal
line 1444: 
line 1445: " PDF
line 1446: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf
line 1447: 
line 1448: " Perl
line 1449: if has("fname_case")
line 1450:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()
line 1451: else
line 1452:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()
line 1453: endif
line 1454: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^Isetf perl
line 1455: au BufNewFile,BufRead *.p6,*.pm6,*.pl6^I^Isetf perl6
line 1456: 
line 1457: func! s:FTpl()
line 1471: 
line 1472: " Perl, XPM or XPM2
line 1480: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1481: 
line 1482: " Perl POD
line 1483: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1484: au BufNewFile,BufRead *.pod6^I^I^Isetf pod6
line 1485: 
line 1486: " Php, php3, php4, etc.
line 1487: " Also Phtml (was used for PHP 2 in the past)
line 1488: " Also .ctp for Cake template file
line 1489: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php
line 1490: 
line 1491: " Pike
line 1492: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
line 1493: 
line 1494: " Pinfo config
line 1495: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1496: 
line 1497: " Palm Resource compiler
line 1498: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1499: 
line 1500: " Pine config
line 1501: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1502: 
line 1503: " PL/1, PL/I
line 1504: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1505: 
line 1506: " PL/M (also: *.inp)
line 1507: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1508: 
line 1509: " PL/SQL
line 1510: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1511: 
line 1512: " PLP
line 1513: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1514: 
line 1515: " PO and PO template (GNU gettext)
line 1516: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1517: 
line 1518: " Postfix main config
line 1519: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain
line 1520: 
line 1521: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1522: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1523: 
line 1524: " PostScript Printer Description
line 1525: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1526: 
line 1527: " Povray
line 1528: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1529: 
line 1530: " Povray configuration
line 1531: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1532: 
line 1533: " Povray, PHP or assembly
line 1534: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()
line 1535: 
line 1536: func! s:FTinc()
line 1557: 
line 1558: " Printcap and Termcap
line 1560: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1562: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1563: 
line 1564: " PCCTS / ANTRL
line 1565: "au BufNewFile,BufRead *.g^I^I^Isetf antrl
line 1566: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1567: 
line 1568: " PPWizard
line 1569: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1570: 
line 1571: " Obj 3D file format
line 1572: " TODO: is there a way to avoid MS-Windows Object files?
line 1573: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1574: 
line 1575: " Oracle Pro*C/C++
line 1576: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1577: 
line 1578: " Privoxy actions file
line 1579: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1580: 
line 1581: " Procmail
line 1582: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1583: 
line 1584: " Progress or CWEB
line 1585: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()
line 1586: 
line 1587: func! s:FTprogress_cweb()
line 1598: 
line 1599: " Progress or assembly
line 1600: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()
line 1601: 
line 1602: func! s:FTprogress_asm()
line 1624: 
line 1625: " Progress or Pascal
line 1626: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()
line 1627: 
line 1628: func! s:FTprogress_pascal()
line 1652: 
line 1653: 
line 1654: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1655: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1659: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1660: 
line 1661: " Prolog
line 1662: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1663: 
line 1664: " Promela
line 1665: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1666: 
line 1667: " Google protocol buffers
line 1668: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1669: 
line 1670: " Protocols
line 1671: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1672: 
line 1673: " Pyrex
line 1674: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1675: 
line 1676: " Python, Python Shell Startup Files
line 1677: " Quixote (Python-based web framework)
line 1678: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc,*.ptl  setf python
line 1679: 
line 1680: " Radiance
line 1681: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1682: 
line 1683: " Ratpoison config/command files
line 1684: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1685: 
line 1686: " RCS file
line 1687: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1688: 
line 1689: " Readline
line 1690: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1691: 
line 1692: " Registry for MS-Windows
line 1694: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1695: 
line 1696: " Renderman Interface Bytestream
line 1697: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1698: 
line 1699: " Rexx
line 1700: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1701: 
line 1702: " R (Splus)
line 1703: if has("fname_case")
line 1704:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r
line 1705: else
line 1706:   au BufNewFile,BufRead *.s^I^I^Isetf r
line 1707: endif
line 1708: 
line 1709: " R Help file
line 1710: if has("fname_case")
line 1711:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1712: else
line 1713:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1714: endif
line 1715: 
line 1716: " R noweb file
line 1717: if has("fname_case")
line 1718:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1719: else
line 1720:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1721: endif
line 1722: 
line 1723: " R Markdown file
line 1724: if has("fname_case")
line 1725:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1726: else
line 1727:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1728: endif
line 1729: 
line 1730: " R reStructuredText file
line 1731: if has("fname_case")
line 1732:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1733: else
line 1734:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1735: endif
line 1736: 
line 1737: " Rexx, Rebol or R
line 1738: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()
line 1739: 
line 1740: func! s:FTr()
line 1772: 
line 1773: " Remind
line 1774: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1775: 
line 1776: " Resolv.conf
line 1777: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1778: 
line 1779: " Relax NG Compact
line 1780: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1781: 
line 1782: " Relax NG XML
line 1783: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1784: 
line 1785: " RPL/2
line 1786: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1787: 
line 1788: " Robots.txt
line 1789: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1790: 
line 1791: " Rpcgen
line 1792: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1793: 
line 1794: " reStructuredText Documentation Format
line 1795: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1796: 
line 1797: " RTF
line 1798: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1799: 
line 1800: " Interactive Ruby shell
line 1801: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1802: 
line 1803: " Ruby
line 1804: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1805: 
line 1806: " RubyGems
line 1807: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1808: 
line 1809: " Rust
line 1810: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1811: 
line 1812: " Rackup
line 1813: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1814: 
line 1815: " Bundler
line 1816: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1817: 
line 1818: " Ruby on Rails
line 1819: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1820: 
line 1821: " Rantfile and Rakefile is like Ruby
line 1822: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1823: 
line 1824: " S-lang (or shader language, or SmallLisp)
line 1825: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1826: 
line 1827: " Samba config
line 1828: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1829: 
line 1830: " SAS script
line 1831: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1832: 
line 1833: " Sass
line 1834: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1835: 
line 1836: " Sather
line 1837: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1838: 
line 1839: " Scala
line 1840: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1841: 
line 1842: " SBT - Scala Build Tool
line 1843: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1844: 
line 1845: " Scilab
line 1846: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1847: 
line 1848: " SCSS
line 1849: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1850: 
line 1851: " SD: Streaming Descriptors
line 1852: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1853: 
line 1854: " SDL
line 1855: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1856: 
line 1857: " sed
line 1858: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1859: 
line 1860: " Sieve (RFC 3028)
line 1861: au BufNewFile,BufRead *.siv^I^I^Isetf sieve
line 1862: 
line 1863: " Sendmail
line 1864: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1865: 
line 1866: " Sendmail .mc files are actually m4.  Could also be MS Message text file.
line 1867: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()
line 1868: 
line 1869: func! s:McSetf()
line 1884: 
line 1885: " Services
line 1886: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1887: 
line 1888: " Service Location config
line 1889: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1890: 
line 1891: " Service Location registration
line 1892: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1893: 
line 1894: " Service Location SPI
line 1895: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1896: 
line 1897: " Setserial config
line 1898: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1899: 
line 1900: " SGML
line 1910: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1911: 
line 1912: " SGMLDECL
line 1916: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1917: 
line 1918: " SGML catalog file
line 1919: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1920: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 1921: 
line 1922: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1923: " Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts
line 1924: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,*.bash,*/{,.}bash[_-]completion{,.d,.sh}{,/*},*.ebuild,*.eclass,PKGBUILD* call SetFileTypeSH("bash")
line 1925: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
line 1926: au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
line 1927: 
line 1928: " Shell script (Arch Linux) or PHP file (Drupal)
line 1934: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call SetFileTypeSH("bash") | endif
line 1935: 
line 1936: " Also called from scripts.vim.
line 1937: func! SetFileTypeSH(name)
line 1980: 
line 1981: " For shell-like file types, check for an "exec" command hidden in a comment,
line 1982: " as used for Tcl.
line 1983: " Also called from scripts.vim, thus can't be local to this script.
line 1984: func! SetFileTypeShell(name)
line 2003: 
line 2004: " tcsh scripts
line 2005: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")
line 2006: 
line 2007: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 2008: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
line 2009: 
line 2010: func! s:CSH()
line 2019: 
line 2020: " Z-Shell script
line 2021: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 2022: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 2023: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 2024: 
line 2025: " Scheme
line 2026: au BufNewFile,BufRead *.scm,*.ss,*.rkt^I^Isetf scheme
line 2027: 
line 2028: " Screen RC
line 2029: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 2030: 
line 2031: " Simula
line 2032: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 2033: 
line 2034: " SINDA
line 2035: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 2036: 
line 2037: " SiSU
line 2038: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 2039: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 2040: 
line 2041: " SKILL
line 2042: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 2043: 
line 2044: " SLRN
line 2045: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 2046: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 2047: 
line 2048: " Smalltalk (and TeX)
line 2049: au BufNewFile,BufRead *.st^I^I^Isetf st
line 2057: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |  setf rexx | else |  setf st | endif
line 2058: 
line 2059: " Smarty templates
line 2060: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 2061: 
line 2062: " SMIL or XML
line 2068: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 2069: 
line 2070: " SMIL or SNMP MIB file
line 2076: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 2077: 
line 2078: " SMITH
line 2079: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 2080: 
line 2081: " Snobol4 and spitbol
line 2082: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 2083: 
line 2084: " SNMP MIB files
line 2085: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 2086: 
line 2087: " Snort Configuration
line 2088: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 2089: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()
line 2090: 
line 2091: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
line 2092: func! s:FTRules()
line 2124: 
line 2125: 
line 2126: " Spec (Linux RPM)
line 2127: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 2128: 
line 2129: " Speedup (AspenTech plant simulator)
line 2130: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 2131: 
line 2132: " Slice
line 2133: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2134: 
line 2135: " Spice
line 2136: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2137: 
line 2138: " Spyce
line 2139: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2140: 
line 2141: " Squid
line 2142: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2143: 
line 2144: " SQL for Oracle Designer
line 2145: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql
line 2146: 
line 2147: " SQL
line 2148: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()
line 2149: 
line 2150: func! s:SQL()
line 2157: 
line 2158: " SQLJ
line 2159: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2160: 
line 2161: " SQR
line 2162: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2163: 
line 2164: " OpenSSH configuration
line 2165: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig
line 2166: 
line 2167: " OpenSSH server configuration
line 2168: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig
line 2169: 
line 2170: " Stata
line 2171: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 2172: " Also *.class, but not when it's a Java bytecode file
line 2174: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 2175: 
line 2176: " SMCL
line 2177: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2178: 
line 2179: " Stored Procedures
line 2180: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2181: 
line 2182: " Standard ML
line 2183: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2184: 
line 2185: " Sratus VOS command macro
line 2186: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2187: 
line 2188: " Sysctl
line 2189: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2190: 
line 2191: " Systemd unit files
line 2192: au BufNewFile,BufRead */systemd/*.{automount,mount,path,service,socket,swap,target,timer}^Isetf systemd
line 2193: 
line 2194: " Synopsys Design Constraints
line 2195: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2196: 
line 2197: " Sudoers
line 2198: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2199: 
line 2200: " SVG (Scalable Vector Graphics)
line 2201: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2202: 
line 2203: " If the file has an extension of 't' and is in a directory 't' or 'xt' then
line 2204: " it is almost certainly a Perl test file.
line 2205: " If the first line starts with '#' and contains 'perl' it's probably a Perl
line 2206: " file.
line 2207: " (Slow test) If a file contains a 'use' statement then it is almost certainly
line 2208: " a Perl file.
line 2209: func! s:FTperl()
line 2225: 
line 2226: " Tads (or Nroff or Perl test file)
line 2228: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif
line 2229: 
line 2230: " Tags
line 2231: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2232: 
line 2233: " TAK
line 2234: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2235: 
line 2236: " Task
line 2237: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2238: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2239: 
line 2240: " Tcl (JACL too)
line 2241: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl
line 2242: 
line 2243: " TealInfo
line 2244: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2245: 
line 2246: " Telix Salt
line 2247: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2248: 
line 2249: " Tera Term Language
line 2250: au BufRead,BufNewFile *.ttl^I^I^Isetf teraterm
line 2251: 
line 2252: " Terminfo
line 2253: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2254: 
line 2255: " TeX
line 2256: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2257: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()
line 2258: 
line 2259: " Choose context, plaintex, or tex (LaTeX) based on these rules:
line 2260: " 1. Check the first line of the file for "%&<format>".
line 2261: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
line 2262: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
line 2263: func! s:FTtex()
line 2314: 
line 2315: " ConTeXt
line 2316: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi   setf context
line 2317: 
line 2318: " Texinfo
line 2319: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2320: 
line 2321: " TeX configuration
line 2322: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2323: 
line 2324: " Tidy config
line 2325: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy
line 2326: 
line 2327: " TF mud client
line 2328: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf
line 2329: 
line 2330: " tmux configuration
line 2331: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 2332: 
line 2333: " TPP - Text Presentation Program
line 2334: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp
line 2335: 
line 2336: " Treetop
line 2337: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2338: 
line 2339: " Trustees
line 2340: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2341: 
line 2342: " TSS - Geometry
line 2343: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2344: 
line 2345: " TSS - Optics
line 2346: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2347: 
line 2348: " TSS - Command Line (temporary)
line 2349: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2350: 
line 2351: " TWIG files
line 2352: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2353: 
line 2354: " Motif UIT/UIL files
line 2355: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2356: 
line 2357: " Udev conf
line 2358: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2359: 
line 2360: " Udev permissions
line 2361: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2362: "
line 2363: " Udev symlinks config
line 2364: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2365: 
line 2366: " UnrealScript
line 2367: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2368: 
line 2369: " Updatedb
line 2370: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2371: 
line 2372: " Upstart (init(8)) config files
line 2373: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2374: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2375: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2376: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 2377: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2378: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2379: 
line 2380: " Vera
line 2381: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2382: 
line 2383: " Verilog HDL
line 2384: au BufNewFile,BufRead *.v^I^I^Isetf verilog
line 2385: 
line 2386: " Verilog-AMS HDL
line 2387: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2388: 
line 2389: " SystemVerilog
line 2390: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 2391: 
line 2392: " VHDL
line 2393: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
line 2394: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2395: 
line 2396: " Vim script
line 2397: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim
line 2398: 
line 2399: " Viminfo file
line 2400: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2401: 
line 2402: " Virata Config Script File or Drupal module
line 2408: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2409: 
line 2410: " Visual Basic (also uses *.bas) or FORM
line 2411: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")
line 2412: 
line 2413: " SaxBasic is close to Visual Basic
line 2414: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2415: 
line 2416: " Vgrindefs file
line 2417: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2418: 
line 2419: " VRML V1.0c
line 2420: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2421: 
line 2422: " Vroom (vim testing and executable documentation)
line 2423: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 2424: 
line 2425: " Webmacro
line 2426: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2427: 
line 2428: " Wget config
line 2429: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2430: 
line 2431: " Website MetaLanguage
line 2432: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2433: 
line 2434: " Winbatch
line 2435: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2436: 
line 2437: " WSML
line 2438: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2439: 
line 2440: " WvDial
line 2441: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2442: 
line 2443: " CVS RC file
line 2444: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2445: 
line 2446: " CVS commit file
line 2447: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2448: 
line 2449: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2450: " lines in a WEB file).
line 2456: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2457: 
line 2458: " Windows Scripting Host and Windows Script Component
line 2459: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2460: 
line 2461: " XHTML
line 2462: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2463: 
line 2464: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
line 2470: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2471: au BufEnter *.xpm2^I^I^I^Isetf xpm2
line 2472: 
line 2473: " XFree86 config
line 2478: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2481: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2482: 
line 2483: " Xorg config
line 2484: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2485: 
line 2486: " Xinetd conf
line 2487: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2488: 
line 2489: " XS Perl extension interface language
line 2490: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2491: 
line 2492: " X resources file
line 2493: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2494: 
line 2495: " Xmath
line 2496: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2498: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif
line 2499: 
line 2500: " XML  specific variants: docbk and xbl
line 2501: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()
line 2502: 
line 2503: func! s:FTxml()
line 2528: 
line 2529: " XMI (holding UML models) is also XML
line 2530: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2531: 
line 2532: " CSPROJ files are Visual Studio.NET's XML-based project config files
line 2533: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2534: 
line 2535: " Qt Linguist translation source and Qt User Interface Files are XML
line 2536: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml
line 2537: 
line 2538: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2539: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2540: 
line 2541: " Xdg menus
line 2542: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2543: 
line 2544: " ATI graphics driver configuration
line 2545: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2546: 
line 2547: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2548: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2549: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2550: 
line 2551: " XML User Interface Language
line 2552: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2553: 
line 2554: " X11 xmodmap (also see below)
line 2555: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2556: 
line 2557: " Xquery
line 2558: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2559: 
line 2560: " XSD
line 2561: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2562: 
line 2563: " Xslt
line 2564: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2565: 
line 2566: " Yacc
line 2567: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 2568: 
line 2569: " Yacc or racc
line 2570: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()
line 2571: 
line 2572: func! s:FTy()
line 2588: 
line 2589: 
line 2590: " Yaml
line 2591: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml
line 2592: 
line 2593: " yum conf (close enough to dosini)
line 2594: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2595: 
line 2596: " Zimbu
line 2597: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2598: " Zimbu Templates
line 2599: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 2600: 
line 2601: " Zope
line 2602: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2603: "   cpt (zope form controller page template)
line 2604: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()
line 2605: "   zsql (zope sql method)
line 2606: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()
line 2607: 
line 2608: " Z80 assembler asz80
line 2609: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2610: 
line 2611: augroup END
line 2612: 
line 2613: 
line 2614: " Source the user-specified filetype file, for backwards compatibility with
line 2615: " Vim 5.x.
line 2616: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2617:   execute "source " . myfiletypefile
line 2618: endif
line 2619: 
line 2620: 
line 2621: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2622: " when there are no matching file name extensions.
line 2623: " Don't do this for compressed files.
line 2624: augroup filetypedetect
line 2627: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2628: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2629: 
line 2630: 
line 2631: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2632: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2633: " script file.
line 2634: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2635: " like are used.
line 2636: 
line 2637: " More Apache config files
line 2638: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2639: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2640: 
line 2641: " Asterisk config file
line 2642: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2643: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2644: 
line 2645: " Bazaar version control
line 2646: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2647: 
line 2648: " Bazel build file
line 2649: if !has("fname_case")
line 2650:   au BufNewFile,BufRead BUILD^I^I^Isetf bzl
line 2651: endif
line 2652: 
line 2653: " BIND zone
line 2654: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2655: 
line 2656: " Calendar
line 2659: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2660: 
line 2661: " Changelog
line 2667: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2668: 
line 2669: " Crontab
line 2670: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2671: 
line 2672: " dnsmasq(8) configuration
line 2673: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2674: 
line 2675: " Dracula
line 2676: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2677: 
line 2678: " Fvwm
line 2679: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2681: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2687: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2688: 
line 2689: " Gedcom
line 2690: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2691: 
line 2692: " GTK RC
line 2693: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2694: 
line 2695: " Jam
line 2696: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2697: 
line 2698: " Jargon
line 2702: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2703: 
line 2704: " Kconfig
line 2705: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2706: 
line 2707: " Lilo: Linux loader
line 2708: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2709: 
line 2710: " Logcheck
line 2711: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2712: 
line 2713: " Makefile
line 2714: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2715: 
line 2716: " Ruby Makefile
line 2717: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2718: 
line 2719: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2720: au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2721: 
line 2722: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2723: 
line 2724: " Modconf
line 2728: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2729: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2730: 
line 2731: " Mutt setup file
line 2732: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2733: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2734: 
line 2735: " Nroff macros
line 2736: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2737: 
line 2738: " OpenBSD hostname.if
line 2739: au BufNewFile,BufRead /etc/hostname.*^I^Icall s:StarSetf('config')
line 2740: 
line 2741: " Pam conf
line 2742: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2743: 
line 2744: " Printcap and Termcap
line 2748: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2752: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2753: 
line 2754: " ReDIF
line 2755: " Only used when the .rdf file was not detected to be XML.
line 2756: au BufRead,BufNewFile *.rdf^I^I^Icall s:Redif()
line 2757: func! s:Redif()
line 2767: 
line 2768: " Remind
line 2769: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2770: 
line 2771: " Vim script
line 2772: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2773: 
line 2774: " Subversion commit file
line 2775: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2776: 
line 2777: " X resources file
line 2778: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2779: 
line 2780: " XFree86 config
line 2782: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2787: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2788: 
line 2789: " X11 xmodmap
line 2790: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2791: 
line 2792: " Xinetd conf
line 2793: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2794: 
line 2795: " yum conf (close enough to dosini)
line 2796: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2797: 
line 2798: " Z-Shell script
line 2799: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2800: 
line 2801: 
line 2802: " Plain text files, needs to be far down to not override others.  This avoids
line 2803: " the "conf" type being used if there is a line starting with '#'.
line 2804: au BufNewFile,BufRead *.text,README^I^Isetf text
line 2805: 
line 2806: " Help files match *.txt but should have a last line that is a modeline.
line 2810: au BufNewFile,BufRead *.txt^I  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2811: 
line 2812: 
line 2813: " Use the filetype detect plugins.  They may overrule any of the previously
line 2814: " detected filetypes.
line 2815: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/syntastic/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/tlib_vim/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snippets/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/youcompleteme/ftdetect/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/ftdetect/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/ftdetect/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/after/ftdetect/*.vim"
Searching for "/Users/jmoussa/.vim/after/ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2816: 
line 2817: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2818: " and started another one. Let's make sure it has ended to get to a consistent
line 2819: " state.
line 2820: augroup END
line 2821: 
line 2822: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2828: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2829: 
line 2830: 
line 2831: " If the GUI is already running, may still need to install the Syntax menu.
line 2832: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2834: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2835:   source <sfile>:p:h/menu.vim
line 2836: endif
line 2837: 
line 2838: " Function called for testing all functions defined here.  These are
line 2839: " script-local, thus need to be executed here.
line 2840: " Returns a string with error messages (hopefully empty).
line 2841: func! TestFiletypeFuncs(testlist)
line 2852: 
line 2853: " Restore 'cpoptions'
line 2854: let &cpo = s:cpo_save
line 2855: unlet s:cpo_save
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
continuing in function pathogen#infect[14]..pathogen#cycle_filetype
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/filetype.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/after/filetype.vim"
Searching for "/Users/jmoussa/.vim/after/filetype.vim"
line 4:   endif
function pathogen#infect[14]..pathogen#cycle_filetype returning #0

continuing in function pathogen#infect

line 15:   if pathogen#is_disabled($MYVIMRC)
calling function pathogen#infect[15]..pathogen#is_disabled('/Users/jmoussa/.vimrc')

line 1:   if a:path =~# '\~$'
line 2:     return 1
line 3:   endif
line 4:   let sep = pathogen#slash()
calling function pathogen#infect[15]..pathogen#is_disabled[4]..pathogen#slash()

line 1:   return !exists("+shellslash") || &shellslash ? '/' : '\'
function pathogen#infect[15]..pathogen#is_disabled[4]..pathogen#slash returning '/'

continuing in function pathogen#infect[15]..pathogen#is_disabled

line 5:   let blacklist = get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST)
calling function pathogen#infect[15]..pathogen#is_disabled[5]..pathogen#split('')

line 1:   if type(a:path) == type([]) | return a:path | endif
line 1:  return a:path | endif
line 1:  endif
line 2:   if empty(a:path) | return [] | endif
line 2:  return [] | endif
function pathogen#infect[15]..pathogen#is_disabled[5]..pathogen#split returning []

continuing in function pathogen#infect[15]..pathogen#is_disabled

line 8:   if !empty(blacklist)
line 9:     call map(blacklist, 'substitute(v:val, "[\\/]$", "", "")')
line 10:   endif
line 11:   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
function pathogen#infect[15]..pathogen#is_disabled returning #0

continuing in function pathogen#infect

line 16:     return 'finish'
line 17:   endif
line 18:   return ''
function pathogen#infect returning ''

continuing in /Users/jmoussa/.vimrc

line 26: 
line 27: 
line 28: "NERDTREE TOGGLE Ctrl+n
line 29: map <C-n> :NERDTreeToggle<CR>
line 30: set runtimepath^=~/.vim/bundle/ctrlp.vim
line 31: 
line 32: let g:syntastic_always_populate_loc_list = 0
line 33: let g:syntastic_auto_loc_list = 0
line 34: let g:syntastic_check_on_open = 0
line 35: let g:syntastic_check_on_wq = 1
line 36: 
line 37: au BufReadPost,BufNewFile *.twig colorscheme koehler 
line 38: au BufReadPost,BufNewFile *.css colorscheme slate
line 39: au BufReadPost,BufNewFile *.js colorscheme slate2
line 40: au BufReadPost,BufNewFile *.py colorscheme slate 
line 41: au BufReadPost,BufNewFile *.html colorscheme monokai
line 42: au BufReadPost,BufNewFile *.java colorscheme monokai  
line 43: au BufReadPost,BufNewFile *.php colorscheme monokai
line 44: 
line 45: au BufReadPost,BufNewFile *.py set syntax=python 
line 46: au BufReadPost,BufNewFile *.html set syntax=html
line 47: au BufReadPost,BufNewFile *.java set syntax=java
line 48: au BufReadPost,BufNewFile *.php set syntax=php
line 49: 
line 50: 
line 51: " Default line highlighting for unknown filetypes
line 52: hi String ctermfg=140
line 53: hi CursorLine ctermbg=235
line 54: hi CursorLine guibg=#D3D3D3 cterm=none
line 55: 
line 56: "What follows are optional things, I like them
line 57: 
line 58: "au BufNewFile,BufRead *.py 
line 59: "        \ set tabstop=4 
line 60: "        \ set shiftwidth=4     "aand fedora doesn't like this parameter, remove this line.
line 61: "        \ set textwidth=79 
line 62: "        \ set expandtab 
line 63: "        \ set autoindent 
line 64: "        \ set fileformat=unix
line 65: 
line 66: "This mission critical workaround hack tells vim to restore cursor to the last line.
line 67: "Be sure to set: "Thip, crinkle, sploit" to "stopit, just be right".  lolz
line 68: "Also it could be the functionality is disabled in your /etc/vim/vimrc or 
line 69: "your ~/.viminfo is owned by root.  
line 70: "http://askubuntu.com/questions/223018/vim-is-not-remembering-last-position
line 74: autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") |   exe "normal! g`\"" | endif
line 75: 
line 76: "These extra commands tell syntastic to ignore the following kinds of warnings                                                               
line 77: "let g:syntastic_quiet_messages = { "regex": 'superfluous' }
line 78: "let g:syntastic_quiet_messages = { "regex": 'superfluous-parens\|too-many-instance-attributes\|too-few-public-methods' }
line 79: 
line 80: "I like the vertical bar on insert mode, others do not like.  You decide.
line 81: "let &t_SI = "\<Esc>]50;CursorShape=1\x7" " Vertical bar in insert mode
line 82: "let &t_EI = "\<Esc>]50;CursorShape=0\x7" " Block in normal mode
line 83: 
line 84: "Powerline
line 85: set  rtp+=/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/
line 86: set laststatus=2
line 87: set t_Co=256
finished sourcing $HOME/.vimrc
Searching for "pack/*/start/*" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/pack/*/start/*"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/pack/*/start/*"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/pack/*/start/*"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/pack/*/start/*"
Searching for "/Users/jmoussa/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/auto-pairs/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/auto-pairs/plugin/auto-pairs.vim"
line 1: " Insert or delete brackets, parens, quotes in pairs.
line 2: " Maintainer:^IJiangMiao <jiangfriend@gmail.com>
line 3: " Contributor: camthompson
line 4: " Last Change:  2013-07-13
line 5: " Version: 1.3.2
line 6: " Homepage: http://www.vim.org/scripts/script.php?script_id=3599
line 7: " Repository: https://github.com/jiangmiao/auto-pairs
line 8: " License: MIT
line 9: 
line 10: if exists('g:AutoPairsLoaded') || &cp
line 11:   finish
line 12: end
line 13: let g:AutoPairsLoaded = 1
line 14: 
line 15: if !exists('g:AutoPairs')
line 16:   let g:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
line 17: end
line 18: 
line 19: if !exists('g:AutoPairsParens')
line 20:   let g:AutoPairsParens = {'(':')', '[':']', '{':'}'}
line 21: end
line 22: 
line 23: if !exists('g:AutoPairsMapBS')
line 24:   let g:AutoPairsMapBS = 1
line 25: end
line 26: 
line 27: " Map <C-h> as the same BS
line 28: if !exists('g:AutoPairsMapCh')
line 29:   let g:AutoPairsMapCh = 1
line 30: end
line 31: 
line 32: if !exists('g:AutoPairsMapCR')
line 33:   let g:AutoPairsMapCR = 1
line 34: end
line 35: 
line 36: if !exists('g:AutoPairsMapSpace')
line 37:   let g:AutoPairsMapSpace = 1
line 38: end
line 39: 
line 40: if !exists('g:AutoPairsCenterLine')
line 41:   let g:AutoPairsCenterLine = 1
line 42: end
line 43: 
line 44: if !exists('g:AutoPairsShortcutToggle')
line 45:   let g:AutoPairsShortcutToggle = '<M-p>'
line 46: end
line 47: 
line 48: if !exists('g:AutoPairsShortcutFastWrap')
line 49:   let g:AutoPairsShortcutFastWrap = '<M-e>'
line 50: end
line 51: 
line 52: if !exists('g:AutoPairsShortcutJump')
line 53:   let g:AutoPairsShortcutJump = '<M-n>'
line 54: endif
line 55: 
line 56: " Fly mode will for closed pair to jump to closed pair instead of insert.
line 57: " also support AutoPairsBackInsert to insert pairs where jumped.
line 58: if !exists('g:AutoPairsFlyMode')
line 59:   let g:AutoPairsFlyMode = 0
line 60: endif
line 61: 
line 62: " When skipping the closed pair, look at the current and
line 63: " next line as well.
line 64: if !exists('g:AutoPairsMultilineClose')
line 65:   let g:AutoPairsMultilineClose = 1
line 66: endif
line 67: 
line 68: " Work with Fly Mode, insert pair where jumped
line 69: if !exists('g:AutoPairsShortcutBackInsert')
line 70:   let g:AutoPairsShortcutBackInsert = '<M-b>'
line 71: endif
line 72: 
line 73: if !exists('g:AutoPairsSmartQuotes')
line 74:   let g:AutoPairsSmartQuotes = 1
line 75: endif
line 76: 
line 77: " 7.4.849 support <C-G>U to avoid breaking '.'
line 78: " Issue talk: https://github.com/jiangmiao/auto-pairs/issues/3
line 79: " Vim note: https://github.com/vim/vim/releases/tag/v7.4.849
line 80: if v:version > 704 || v:version == 704 && has("patch849")
line 81:   let s:Go = "\<C-G>U"
line 82: else
line 83:   let s:Go = ""
line 84: endif
line 85: 
line 86: let s:Left = s:Go."\<LEFT>"
line 87: let s:Right = s:Go."\<RIGHT>"
line 88: 
line 89: 
line 90: " Will auto generated {']' => '[', ..., '}' => '{'}in initialize.
line 91: let g:AutoPairsClosedPairs = {}
line 92: 
line 93: 
line 94: function! AutoPairsInsert(key)
line 221: 
line 222: function! AutoPairsDelete()
line 287: 
line 288: function! AutoPairsJump()
line 291: " string_chunk cannot use standalone
line 292: let s:string_chunk = '\v%(\\\_.|[^\1]|[\r\n]){-}'
line 293: let s:ss_pattern = '\v''' . s:string_chunk . ''''
line 294: let s:ds_pattern = '\v"'  . s:string_chunk . '"'
line 295: 
line 296: func! s:RegexpQuote(str)
line 299: 
line 300: func! s:RegexpQuoteInSquare(str)
line 303: 
line 304: " Search next open or close pair
line 305: func! s:FormatChunk(open, close)
line 316: 
line 317: " Fast wrap the word in brackets
line 318: function! AutoPairsFastWrap()
line 349: 
line 350: function! AutoPairsMap(key)
line 360: 
line 361: function! AutoPairsToggle()
line 371: 
line 372: function! AutoPairsReturn()
line 404: 
line 405: function! AutoPairsSpace()
line 415: 
line 416: function! AutoPairsBackInsert()
line 425: 
line 426: function! AutoPairsInit()
line 483: 
line 484: function! s:ExpandMap(map)
line 489: 
line 490: function! AutoPairsTryInit()
line 554: 
line 555: " Always silent the command
line 556: inoremap <silent> <SID>AutoPairsReturn <C-R>=AutoPairsReturn()<CR>
line 557: imap <script> <Plug>AutoPairsReturn <SID>AutoPairsReturn
line 558: 
line 559: 
line 560: au BufEnter * :call AutoPairsTryInit()
finished sourcing /Users/jmoussa/.vim/bundle/auto-pairs/plugin/auto-pairs.vim
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/ctrlp.vim/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim"
line 1: " =============================================================================
line 2: " File:          plugin/ctrlp.vim
line 3: " Description:   Fuzzy file, buffer, mru, tag, etc finder.
line 4: " Author:        Kien Nguyen <github.com/kien>
line 5: " =============================================================================
line 6: " GetLatestVimScripts: 3736 1 :AutoInstall: ctrlp.zip
line 7: 
line 8: if ( exists('g:loaded_ctrlp') && g:loaded_ctrlp ) || v:version < 700 || &cp
line 9: ^Ifini
line 10: en
line 11: let g:loaded_ctrlp = 1
line 12: 
line 15: let [g:ctrlp_lines, g:ctrlp_allfiles, g:ctrlp_alltags, g:ctrlp_alldirs, g:ctrlp_allmixes, g:ctrlp_buftags, g:ctrlp_ext_vars, g:ctrlp_builtins] = [[], [], [], [], {}, {}, [], 2]
line 16: 
line 17: if !exists('g:ctrlp_map') | let g:ctrlp_map = '<c-p>' | en
line 17:  let g:ctrlp_map = '<c-p>' | en
line 17:  en
line 18: if !exists('g:ctrlp_cmd') | let g:ctrlp_cmd = 'CtrlP' | en
line 18:  let g:ctrlp_cmd = 'CtrlP' | en
line 18:  en
line 19: 
line 20: com! -n=? -com=dir CtrlP         cal ctrlp#init(0, { 'dir': <q-args> })
line 21: com! -n=? -com=dir CtrlPMRUFiles cal ctrlp#init('mru', { 'dir': <q-args> })
line 22: 
line 23: com! -bar CtrlPBuffer   cal ctrlp#init('buf')
line 24: com! -n=? CtrlPLastMode cal ctrlp#init(-1, { 'args': <q-args> })
line 25: 
line 26: com! -bar CtrlPClearCache     cal ctrlp#clr()
line 27: com! -bar CtrlPClearAllCaches cal ctrlp#clra()
line 28: 
line 29: com! -bar ClearCtrlPCache     cal ctrlp#clr()
line 30: com! -bar ClearAllCtrlPCaches cal ctrlp#clra()
line 31: 
line 32: com! -bar CtrlPCurWD   cal ctrlp#init('fil', { 'mode': '' })
line 33: com! -bar CtrlPCurFile cal ctrlp#init('fil', { 'mode': 'c' })
line 34: com! -bar CtrlPRoot    cal ctrlp#init('fil', { 'mode': 'r' })
line 35: 
line 36: exe 'nn <silent> <plug>(ctrlp) :<c-u>'.g:ctrlp_cmd.'<cr>'
line 36: nn <silent> <plug>(ctrlp) :<c-u>CtrlP<cr>
line 37: 
line 38: if g:ctrlp_map != '' && !hasmapto('<plug>(ctrlp)')
line 39: ^Iexe 'map' g:ctrlp_map '<plug>(ctrlp)'
line 39: map <c-p> <plug>(ctrlp)
line 40: en
line 41: 
line 42: cal ctrlp#mrufiles#init()
Searching for "autoload/ctrlp/mrufiles.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/autoload/ctrlp/mrufiles.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim"
chdir(/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/ctrlp)
fchdir() to previous dir
line 42: sourcing "/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim"
line 1: " =============================================================================
line 2: " File:          autoload/ctrlp/mrufiles.vim
line 3: " Description:   Most Recently Used Files extension
line 4: " Author:        Kien Nguyen <github.com/kien>
line 5: " =============================================================================
line 6: 
line 7: " Static variables {{{1
line 8: let [s:mrbs, s:mrufs] = [[], []]
line 9: let s:mruf_map_string = '!stridx(v:val, cwd) ? strpart(v:val, idx) : v:val'
line 10: 
line 11: fu! ctrlp#mrufiles#opts()
line 25: cal ctrlp#mrufiles#opts()
calling function ctrlp#mrufiles#opts()

line 1: ^Ilet [pref, opts] = ['g:ctrlp_mruf_', { 'max': ['s:max', 250], 'include': ['s:in', ''], 'exclude': ['s:ex', ''], 'case_sensitive': ['s:cseno', 1], 'relative': ['s:re', 0], 'save_on_update': ['s:soup', 1], 'map_string': ['g:ctrlp_mruf_map_string', s:mruf_map_string], }]
line 10: ^Ifor [ke, va] in items(opts)
line 11: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 12: ^Iendfo
line 10: ^Ifor [ke, va] in items(opts)
line 11: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 12: ^Iendfo
line 10: ^Ifor [ke, va] in items(opts)
line 11: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 12: ^Iendfo
line 10: ^Ifor [ke, va] in items(opts)
line 11: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 12: ^Iendfo
line 10: ^Ifor [ke, va] in items(opts)
line 11: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 12: ^Iendfo
line 10: ^Ifor [ke, va] in items(opts)
line 11: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 12: ^Iendfo
line 10: ^Ifor [ke, va] in items(opts)
line 11: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 12: ^Iendfo
line 10: ^Ifor [ke, va] in items(opts)
line 11: ^I^Ilet [{va[0]}, {pref.ke}] = [pref.ke, exists(pref.ke) ? {pref.ke} : va[1]]
line 12: ^Iendfo
function ctrlp#mrufiles#opts returning #0

continuing in /Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim

line 26: " Utilities {{{1
line 27: fu! s:excl(fn)
line 30: 
line 31: fu! s:mergelists()
line 37: 
line 38: fu! s:chop(mrufs)
line 42: 
line 43: fu! s:reformat(mrufs, ...)
line 58: 
line 59: fu! s:record(bufnr)
line 69: 
line 70: fu! s:addtomrufs(fname)
line 87: 
line 88: fu! s:savetofile(mrufs)
line 91: " Public {{{1
line 92: fu! ctrlp#mrufiles#refresh(...)
line 105: 
line 106: fu! ctrlp#mrufiles#remove(files)
line 117: 
line 118: fu! ctrlp#mrufiles#add(fn)
line 123: 
line 124: fu! ctrlp#mrufiles#list(...)
line 128: 
line 129: fu! ctrlp#mrufiles#bufs()
line 132: 
line 133: fu! ctrlp#mrufiles#tgrel()
line 136: 
line 137: fu! ctrlp#mrufiles#cachefile()
line 144: 
line 145: fu! ctrlp#mrufiles#init()
line 156: "}}}
line 157: 
line 158: " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2
finished sourcing /Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim
continuing in /Users/jmoussa/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim
calling function ctrlp#mrufiles#init()

line 1: ^Iif !has('autocmd') | retu | en
line 1:  retu | en
line 1:  en
line 2: ^Ilet s:locked = 0
line 3: ^Iaug CtrlPMRUF
line 4: ^I^Iau!
line 5: ^I^Iau BufWinEnter,BufWinLeave,BufWritePost * cal s:record(expand('<abuf>', 1))
line 6: ^I^Iau QuickFixCmdPre  *vimgrep* let s:locked = 1
line 7: ^I^Iau QuickFixCmdPost *vimgrep* let s:locked = 0
line 8: ^I^Iau VimLeavePre * cal s:savetofile(s:mergelists())
line 9: ^Iaug END
function ctrlp#mrufiles#init returning #0

continuing in /Users/jmoussa/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim

line 43: 
line 44: com! -bar CtrlPTag      cal ctrlp#init(ctrlp#tag#id())
line 45: com! -bar CtrlPQuickfix cal ctrlp#init(ctrlp#quickfix#id())
line 46: 
line 48: com! -n=? -com=dir CtrlPDir cal ctrlp#init(ctrlp#dir#id(), { 'dir': <q-args> })
line 49: 
line 51: com! -n=? -com=buffer CtrlPBufTag cal ctrlp#init(ctrlp#buffertag#cmd(0, <q-args>))
line 52: 
line 53: com! -bar CtrlPBufTagAll cal ctrlp#init(ctrlp#buffertag#cmd(1))
line 54: com! -bar CtrlPRTS       cal ctrlp#init(ctrlp#rtscript#id())
line 55: com! -bar CtrlPUndo      cal ctrlp#init(ctrlp#undo#id())
line 56: 
line 58: com! -n=? -com=buffer CtrlPLine cal ctrlp#init(ctrlp#line#cmd('buf', <q-args>))
line 59: 
line 61: com! -n=? -com=buffer CtrlPChange cal ctrlp#init(ctrlp#changes#cmd('fil', <q-args>))
line 62: 
line 63: com! -bar CtrlPChangeAll   cal ctrlp#init(ctrlp#changes#cmd(1))
line 64: com! -bar CtrlPMixed       cal ctrlp#init(ctrlp#mixed#id())
line 65: com! -bar CtrlPBookmarkDir cal ctrlp#init(ctrlp#bookmarkdir#id())
line 66: 
line 68: com! -n=? -com=dir -bang CtrlPBookmarkDirAdd cal ctrlp#call('ctrlp#bookmarkdir#add', '<bang>', <q-args>)
line 69: 
line 70: " vim:ts=2:sw=2:sts=2
finished sourcing /Users/jmoussa/.vim/bundle/ctrlp.vim/plugin/ctrlp.vim
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/emmet-vim/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/emmet-vim/plugin/emmet.vim"
line 1: "=============================================================================
line 2: " File: emmet.vim
line 3: " Author: Yasuhiro Matsumoto <mattn.jp@gmail.com>
line 4: " Last Change: 26-Jul-2015.
line 5: " Version: 0.86
line 6: " WebPage: http://github.com/mattn/emmet-vim
line 7: " Description: vim plugins for HTML and CSS hi-speed coding.
line 8: " SeeAlso: http://emmet.io/
line 9: " Usage:
line 10: "
line 11: "   This is vim script support expanding abbreviation like emmet.
line 12: "   ref: http://emmet.io/
line 13: "
line 14: "   Type abbreviation
line 15: "      +-------------------------------------
line 16: "      | html:5_
line 17: "      +-------------------------------------
line 18: "   "_" is a cursor position. and type "<c-y>," (Ctrl+y and Comma)
line 19: "   NOTE: Don't worry about key map. you can change it easily.
line 20: "      +-------------------------------------
line 21: "      | <!DOCTYPE HTML>
line 22: "      | <html lang="en">
line 23: "      | <head>
line 24: "      |     <title></title>
line 25: "      |     <meta charset="UTF-8">
line 26: "      | </head>
line 27: "      | <body>
line 28: "      |      _
line 29: "      | </body>
line 30: "      | </html>
line 31: "      +-------------------------------------
line 32: "   Type following
line 33: "      +-------------------------------------
line 34: "      | div#foo$*2>div.bar
line 35: "      +-------------------------------------
line 36: "   And type "<c-y>,"
line 37: "      +-------------------------------------
line 38: "      |<div id="foo1">
line 39: "      |    <div class="bar">_</div>
line 40: "      |</div>
line 41: "      |<div id="foo2">
line 42: "      |    <div class="bar"></div>
line 43: "      |</div>
line 44: "      +-------------------------------------
line 45: "
line 46: " Tips:
line 47: "
line 48: "   You can customize behavior of expanding with overriding config.
line 49: "   This configuration will be marged at loading plugin.
line 50: "
line 51: "     let g:user_emmet_settings = {
line 52: "     \  'indentation' : '  ',
line 53: "     \  'perl' : {
line 54: "     \    'aliases' : {
line 55: "     \      'req' : 'require '
line 56: "     \    },
line 57: "     \    'snippets' : {
line 58: "     \      'use' : "use strict\nuse warnings\n\n",
line 59: "     \      'warn' : "warn \"|\";",
line 60: "     \    }
line 61: "     \  }
line 62: "     \}
line 63: "
line 64: "   You can set language attribute in html using 'emmet_settings.lang'.
line 65: "
line 66: " GetLatestVimScripts: 2981 1 :AutoInstall: emmet.vim
line 67: " script type: plugin
line 68: 
line 69: if &compatible || v:version < 702 || (exists('g:loaded_emmet_vim') && g:loaded_emmet_vim)
line 70:   finish
line 71: endif
line 72: let g:loaded_emmet_vim = 1
line 73: 
line 74: let s:save_cpo = &cpoptions
line 75: set cpoptions&vim
line 76: 
line 77: if !exists('g:emmet_html5')
line 78:   let g:emmet_html5 = 1
line 79: endif
line 80: 
line 81: if !exists('g:emmet_docroot')
line 82:   let g:emmet_docroot = {}
line 83: endif
line 84: 
line 85: if !exists('g:emmet_debug')
line 86:   let g:emmet_debug = 0
line 87: endif
line 88: 
line 89: if !exists('g:emmet_curl_command')
line 90:   let g:emmet_curl_command = 'curl -s -L -A Mozilla/5.0'
line 91: endif
line 92: 
line 93: if !exists('g:user_emmet_leader_key')
line 94:   let g:user_emmet_leader_key = '<c-y>'
line 95: endif
line 96: 
line 97: function! s:install_plugin(mode, buffer)
line 163: 
line 164: command! -nargs=0 -bar EmmetInstall call <SID>install_plugin(get(g:, 'user_emmet_mode', 'a'), 1)
line 165: 
line 166: if get(g:, 'user_emmet_install_global', 1)
line 167:   call s:install_plugin(get(g:, 'user_emmet_mode', 'a'), 0)
calling function <SNR>15_install_plugin('a', 0)

line 1:   let buffer = a:buffer ? '<buffer>' : ''
line 2:   let items = [ {'mode': 'i', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(0,"")<cr>'}, {'mode': 'n', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': ':call emmet#expandAbbr(3,"")<cr>'}, {'mode': 'v', 'var': 'user_emmet_expandabbr_key', 'key': ',', 'plug': 'emmet-expand-abbr', 'func': ':call emmet#expandAbbr(2,"")<cr>'}, {'mode': 'i', 'var': 'user_emmet_expandword_key', 'key': ';', 'plug': 'emmet-expand-word', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(1,"")<cr>'}, {'mode': 'n', 'var': 'user_emmet_expandword_key', 'key': ';', 'plug': 'emmet-expand-word', 'func': ':call emmet#expandAbbr(1,"")<cr>'}, {'mode': 'i', 'var': 'user_emmet_update_tag', 'key': 'u', 'plug': 'emmet-update-tag', 'func': '<c-r>=emmet#util#closePopup()<cr><c-r>=emmet#updateTag()<cr>'}, {'mode': 'n', 'var': 'user_emmet_update_tag', 'key': 'u', 'plug': 'emmet-update-tag', 'func': '
line 39: 
line 40:   let only_plug = get(g:, 'emmet_install_only_plug', 0)
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-expand-abbr) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(0,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-expand-abbr) :call emmet#expandAbbr(3,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-expand-abbr) :call emmet#expandAbbr(2,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>, <plug>(emmet-expand-abbr)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-expand-word) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#expandAbbr(1,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>; <plug>(emmet-expand-word)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-expand-word) :call emmet#expandAbbr(1,"")<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>; <plug>(emmet-expand-word)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-update-tag) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#updateTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>u <plug>(emmet-update-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-update-tag) :call emmet#updateTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>u <plug>(emmet-update-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-balance-tag-inward) <esc>:call emmet#balanceTag(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-balance-tag-inward) :call emmet#balanceTag(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-balance-tag-inward) :call emmet#balanceTag(2)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>d <plug>(emmet-balance-tag-inward)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-balance-tag-outword) <esc>:call emmet#balanceTag(-1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-balance-tag-outword) :call emmet#balanceTag(-1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-balance-tag-outword) :call emmet#balanceTag(-2)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>D <plug>(emmet-balance-tag-outword)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-next) <esc>:call emmet#moveNextPrev(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>n <plug>(emmet-move-next)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-next) :call emmet#moveNextPrev(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>n <plug>(emmet-move-next)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-prev) <esc>:call emmet#moveNextPrev(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>N <plug>(emmet-move-prev)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-prev) :call emmet#moveNextPrev(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>N <plug>(emmet-move-prev)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-next-item) <esc>:call emmet#moveNextPrevItem(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-next-item) :call emmet#moveNextPrevItem(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-move-prev-item) <esc>:call emmet#moveNextPrevItem(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-move-prev-item) :call emmet#moveNextPrevItem(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-image-size) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#imageSize()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>i <plug>(emmet-image-size)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-image-size) :call emmet#imageSize()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>i <plug>(emmet-image-size)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-toggle-comment) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#toggleComment()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>/ <plug>(emmet-toggle-comment)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-toggle-comment) :call emmet#toggleComment()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>/ <plug>(emmet-toggle-comment)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-split-join-tag) <esc>:call emmet#splitJoinTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>j <plug>(emmet-split-join-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-split-join-tag) :call emmet#splitJoinTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>j <plug>(emmet-split-join-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-remove-tag) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#removeTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>k <plug>(emmet-remove-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-remove-tag) :call emmet#removeTag()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>k <plug>(emmet-remove-tag)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-anchorize-url) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#anchorizeURL(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>a <plug>(emmet-anchorize-url)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-anchorize-url) :call emmet#anchorizeURL(0)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>a <plug>(emmet-anchorize-url)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: inoremap  <plug>(emmet-anchorize-summary) <c-r>=emmet#util#closePopup()<cr><c-r>=emmet#anchorizeURL(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: imap  <unique> <c-y>A <plug>(emmet-anchorize-summary)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: nnoremap  <plug>(emmet-anchorize-summary) :call emmet#anchorizeURL(1)<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: nmap  <unique> <c-y>A <plug>(emmet-anchorize-summary)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-merge-lines) :call emmet#mergeLines()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>m <plug>(emmet-merge-lines)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 45: vnoremap  <plug>(emmet-code-pretty) :call emmet#codePretty()<cr>
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 53: vmap  <unique> <c-y>c <plug>(emmet-code-pretty)
line 54:       endif
line 55:     endif
line 56:   endfor
line 41:   for item in items
line 42:     if a:mode !=# 'a' && stridx(a:mode, item.mode) == -1
line 43:       continue
line 44:     endif
line 45:     exe item.mode . 'noremap '. buffer .' <plug>(' . item.plug . ') ' . item.func
line 46:     if item.var != '' && !only_plug
line 47:       if exists('g:' . item.var)
line 48:         let key = eval('g:' . item.var)
line 49:       else
line 50:         let key = g:user_emmet_leader_key . item.key
line 51:       endif
line 52:       if !hasmapto('<plug>(' . item.plug . ')', item.mode) && !len(maparg(key, item.mode))
line 53:         exe item.mode . 'map ' . buffer . ' <unique> ' . key . ' <plug>(' . item.plug . ')'
line 54:       endif
line 55:     endif
line 56:   endfor
line 57: 
line 58:   if exists('g:user_emmet_complete_tag') && g:user_emmet_complete_tag
line 59:     if get(g:, 'user_emmet_install_global', 1)
line 60:       set omnifunc=emmet#completeTag
line 61:     else
line 62:       setlocal omnifunc=emmet#completeTag
line 63:     endif
line 64:   endif
function <SNR>15_install_plugin returning #0

continuing in /Users/jmoussa/.vim/bundle/emmet-vim/plugin/emmet.vim

line 168: endif
line 169: 
line 170: if get(g:, 'user_emmet_install_command', 1)
line 171:   command! -nargs=1 Emmet call emmet#expandAbbr(4, <q-args>)
line 172: endif
line 173: 
line 174: let &cpoptions = s:save_cpo
line 175: unlet s:save_cpo
line 176: 
line 177: " vim:set et:
finished sourcing /Users/jmoussa/.vim/bundle/emmet-vim/plugin/emmet.vim
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim"
line 1: " ============================================================================
line 2: " File:        NERD_tree.vim
line 3: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 4: " License:     This program is free software. It comes without any warranty,
line 5: "              to the extent permitted by applicable law. You can redistribute
line 6: "              it and/or modify it under the terms of the Do What The Fuck You
line 7: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 8: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 9: "
line 10: " ============================================================================
line 11: "
line 12: " SECTION: Script init stuff {{{1
line 13: "============================================================
line 14: if exists("loaded_nerd_tree")
line 15:     finish
line 16: endif
line 17: if v:version < 700
line 18:     echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"
line 19:     finish
line 20: endif
line 21: let loaded_nerd_tree = 1
line 22: 
line 23: "for line continuation - i.e dont want C in &cpo
line 24: let s:old_cpo = &cpo
line 25: set cpo&vim
line 26: 
line 27: "Function: s:initVariable() function {{{2
line 28: "This function is used to initialise a given variable to a given value. The
line 29: "variable is only initialised if it does not exist prior
line 30: "
line 31: "Args:
line 32: "var: the name of the var to be initialised
line 33: "value: the value to initialise var to
line 34: "
line 35: "Returns:
line 36: "1 if the var is set, 0 otherwise
line 37: function! s:initVariable(var, value)
line 44: 
line 45: "SECTION: Init variable calls and other random constants {{{2
line 46: call s:initVariable("g:NERDTreeAutoCenter", 1)
calling function <SNR>16_initVariable('g:NERDTreeAutoCenter', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeAutoCenter = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 47: call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)
calling function <SNR>16_initVariable('g:NERDTreeAutoCenterThreshold', 3)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeAutoCenterThreshold = '3'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 48: call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)
calling function <SNR>16_initVariable('g:NERDTreeCaseSensitiveSort', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCaseSensitiveSort = '0'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 49: call s:initVariable("g:NERDTreeSortHiddenFirst", 1)
calling function <SNR>16_initVariable('g:NERDTreeSortHiddenFirst', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeSortHiddenFirst = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 50: call s:initVariable("g:NERDTreeChDirMode", 0)
calling function <SNR>16_initVariable('g:NERDTreeChDirMode', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeChDirMode = '0'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 51: call s:initVariable("g:NERDTreeCreatePrefix", "silent")
calling function <SNR>16_initVariable('g:NERDTreeCreatePrefix', 'silent')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCreatePrefix = 'silent'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 52: call s:initVariable("g:NERDTreeMinimalUI", 0)
calling function <SNR>16_initVariable('g:NERDTreeMinimalUI', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMinimalUI = '0'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 53: if !exists("g:NERDTreeIgnore")
line 54:     let g:NERDTreeIgnore = ['\~$']
line 55: endif
line 56: call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')
calling function <SNR>16_initVariable('g:NERDTreeBookmarksFile', '/Users/jmoussa/.NERDTreeBookmarks')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeBookmarksFile = '/Users/jmoussa/.NERDTreeBookmarks'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 57: call s:initVariable("g:NERDTreeBookmarksSort", 1)
calling function <SNR>16_initVariable('g:NERDTreeBookmarksSort', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeBookmarksSort = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 58: call s:initVariable("g:NERDTreeHighlightCursorline", 1)
calling function <SNR>16_initVariable('g:NERDTreeHighlightCursorline', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeHighlightCursorline = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 59: call s:initVariable("g:NERDTreeHijackNetrw", 1)
calling function <SNR>16_initVariable('g:NERDTreeHijackNetrw', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeHijackNetrw = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 60: call s:initVariable("g:NERDTreeMouseMode", 1)
calling function <SNR>16_initVariable('g:NERDTreeMouseMode', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMouseMode = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 61: call s:initVariable("g:NERDTreeNotificationThreshold", 100)
calling function <SNR>16_initVariable('g:NERDTreeNotificationThreshold', 100)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeNotificationThreshold = '100'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 62: call s:initVariable("g:NERDTreeQuitOnOpen", 0)
calling function <SNR>16_initVariable('g:NERDTreeQuitOnOpen', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeQuitOnOpen = '0'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 63: call s:initVariable("g:NERDTreeRespectWildIgnore", 0)
calling function <SNR>16_initVariable('g:NERDTreeRespectWildIgnore', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeRespectWildIgnore = '0'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 64: call s:initVariable("g:NERDTreeShowBookmarks", 0)
calling function <SNR>16_initVariable('g:NERDTreeShowBookmarks', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowBookmarks = '0'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 65: call s:initVariable("g:NERDTreeShowFiles", 1)
calling function <SNR>16_initVariable('g:NERDTreeShowFiles', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowFiles = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 66: call s:initVariable("g:NERDTreeShowHidden", 0)
calling function <SNR>16_initVariable('g:NERDTreeShowHidden', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowHidden = '0'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 67: call s:initVariable("g:NERDTreeShowLineNumbers", 0)
calling function <SNR>16_initVariable('g:NERDTreeShowLineNumbers', 0)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeShowLineNumbers = '0'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 68: call s:initVariable("g:NERDTreeSortDirs", 1)
calling function <SNR>16_initVariable('g:NERDTreeSortDirs', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeSortDirs = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 69: 
line 70: if !nerdtree#runningWindows()
Searching for "autoload/nerdtree.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/autoload/nerdtree.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/autoload/nerdtree.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/nerdtree.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/autoload/nerdtree.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/autoload/nerdtree.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/autoload)
fchdir() to previous dir
line 70: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/autoload/nerdtree.vim"
line 1: if exists("g:loaded_nerdtree_autoload")
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_autoload = 1
line 5: 
line 6: function! nerdtree#version()
line 9: 
line 10: " SECTION: General Functions {{{1
line 11: "============================================================
line 12: 
line 13: "FUNCTION: nerdtree#checkForBrowse(dir) {{{2
line 14: "inits a window tree in the current buffer if appropriate
line 15: function! nerdtree#checkForBrowse(dir)
line 26: 
line 27: "FUNCTION: s:reuseWin(dir) {{{2
line 28: "finds a NERDTree buffer with root of dir, and opens it.
line 29: function! s:reuseWin(dir) abort
line 48: 
line 49: " FUNCTION: nerdtree#completeBookmarks(A,L,P) {{{2
line 50: " completion function for the bookmark commands
line 51: function! nerdtree#completeBookmarks(A,L,P)
line 54: 
line 55: "FUNCTION: nerdtree#compareBookmarks(dir) {{{2
line 56: function! nerdtree#compareBookmarks(first, second)
line 59: 
line 60: "FUNCTION: nerdtree#compareNodes(dir) {{{2
line 61: function! nerdtree#compareNodes(n1, n2)
line 64: 
line 65: "FUNCTION: nerdtree#compareNodesBySortKey(n1, n2) {{{2
line 66: function! nerdtree#compareNodesBySortKey(n1, n2)
line 75: 
line 76: " FUNCTION: nerdtree#deprecated(func, [msg]) {{{2
line 77: " Issue a deprecation warning for a:func. If a second arg is given, use this
line 78: " as the deprecation message
line 79: function! nerdtree#deprecated(func, ...)
line 90: 
line 91: " FUNCTION: nerdtree#exec(cmd) {{{2
line 92: " same as :exec cmd  but eventignore=all is set for the duration
line 93: function! nerdtree#exec(cmd)
line 99: 
line 100: " FUNCTION: nerdtree#has_opt(options, name) {{{2
line 101: function! nerdtree#has_opt(options, name)
line 104: 
line 105: " FUNCTION: nerdtree#loadClassFiles() {{{2
line 106: function! nerdtree#loadClassFiles()
line 122: 
line 123: " FUNCTION: nerdtree#postSourceActions() {{{2
line 124: function! nerdtree#postSourceActions()
line 131: 
line 132: "FUNCTION: nerdtree#runningWindows(dir) {{{2
line 133: function! nerdtree#runningWindows()
line 136: 
line 137: " SECTION: View Functions {{{1
line 138: "============================================================
line 139: 
line 140: "FUNCTION: nerdtree#echo  {{{2
line 141: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages
line 142: "
line 143: "Args:
line 144: "msg: the message to echo
line 145: function! nerdtree#echo(msg)
line 149: 
line 150: "FUNCTION: nerdtree#echoError {{{2
line 151: "Wrapper for nerdtree#echo, sets the message type to errormsg for this message
line 152: "Args:
line 153: "msg: the message to echo
line 154: function! nerdtree#echoError(msg)
line 159: 
line 160: "FUNCTION: nerdtree#echoWarning {{{2
line 161: "Wrapper for nerdtree#echo, sets the message type to warningmsg for this message
line 162: "Args:
line 163: "msg: the message to echo
line 164: function! nerdtree#echoWarning(msg)
line 169: 
line 170: "FUNCTION: nerdtree#renderView {{{2
line 171: function! nerdtree#renderView()
line 174: 
line 175: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/autoload/nerdtree.vim
continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim
calling function nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function nerdtree#runningWindows returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 71:     call s:initVariable("g:NERDTreeDirArrowExpandable", "▸")
calling function <SNR>16_initVariable('g:NERDTreeDirArrowExpandable', '▸')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeDirArrowExpandable = '▸'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 72:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "▾")
calling function <SNR>16_initVariable('g:NERDTreeDirArrowCollapsible', '▾')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeDirArrowCollapsible = '▾'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 73: else
line 74:     call s:initVariable("g:NERDTreeDirArrowExpandable", "+")
line 75:     call s:initVariable("g:NERDTreeDirArrowCollapsible", "~")
line 76: endif
line 77: call s:initVariable("g:NERDTreeCascadeOpenSingleChildDir", 1)
calling function <SNR>16_initVariable('g:NERDTreeCascadeOpenSingleChildDir', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCascadeOpenSingleChildDir = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 78: call s:initVariable("g:NERDTreeCascadeSingleChildDir", 1)
calling function <SNR>16_initVariable('g:NERDTreeCascadeSingleChildDir', 1)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCascadeSingleChildDir = '1'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 79: 
line 80: if !exists("g:NERDTreeSortOrder")
line 81:     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$']
line 82: else
line 83:     "if there isnt a * in the sort sequence then add one
line 84:     if count(g:NERDTreeSortOrder, '*') < 1
line 85:         call add(g:NERDTreeSortOrder, '*')
line 86:     endif
line 87: endif
line 88: 
line 89: call s:initVariable("g:NERDTreeGlyphReadOnly", "RO")
calling function <SNR>16_initVariable('g:NERDTreeGlyphReadOnly', 'RO')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeGlyphReadOnly = 'RO'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 90: 
line 91: if !exists('g:NERDTreeStatusline')
line 92: 
line 93:     "the exists() crap here is a hack to stop vim spazzing out when
line 94:     "loading a session that was created with an open nerd tree. It spazzes
line 95:     "because it doesnt store b:NERDTree(its a b: var, and its a hash)
line 96:     let g:NERDTreeStatusline = "%{exists('b:NERDTree')?b:NERDTree.root.path.str():''}"
line 97: 
line 98: endif
line 99: call s:initVariable("g:NERDTreeWinPos", "left")
calling function <SNR>16_initVariable('g:NERDTreeWinPos', 'left')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeWinPos = 'left'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 100: call s:initVariable("g:NERDTreeWinSize", 31)
calling function <SNR>16_initVariable('g:NERDTreeWinSize', 31)

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeWinSize = '31'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 101: 
line 102: "init the shell commands that will be used to copy nodes, and remove dir trees
line 103: "
line 104: "Note: the space after the command is important
line 105: if nerdtree#runningWindows()
calling function nerdtree#runningWindows()

line 1:     return has("win16") || has("win32") || has("win64")
function nerdtree#runningWindows returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 106:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')
line 107:     call s:initVariable("g:NERDTreeCopyDirCmd", 'xcopy /s /e /i /y /q ')
line 108:     call s:initVariable("g:NERDTreeCopyFileCmd", 'copy /y ')
line 109: else
line 110:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')
calling function <SNR>16_initVariable('g:NERDTreeRemoveDirCmd', 'rm -rf ')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeRemoveDirCmd = 'rm -rf '
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 111:     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')
calling function <SNR>16_initVariable('g:NERDTreeCopyCmd', 'cp -r ')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeCopyCmd = 'cp -r '
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 112: endif
line 113: 
line 114: 
line 115: "SECTION: Init variable calls for key mappings {{{2
line 116: call s:initVariable("g:NERDTreeMapActivateNode", "o")
calling function <SNR>16_initVariable('g:NERDTreeMapActivateNode', 'o')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapActivateNode = 'o'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 117: call s:initVariable("g:NERDTreeMapChangeRoot", "C")
calling function <SNR>16_initVariable('g:NERDTreeMapChangeRoot', 'C')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapChangeRoot = 'C'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 118: call s:initVariable("g:NERDTreeMapChdir", "cd")
calling function <SNR>16_initVariable('g:NERDTreeMapChdir', 'cd')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapChdir = 'cd'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 119: call s:initVariable("g:NERDTreeMapCloseChildren", "X")
calling function <SNR>16_initVariable('g:NERDTreeMapCloseChildren', 'X')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCloseChildren = 'X'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 120: call s:initVariable("g:NERDTreeMapCloseDir", "x")
calling function <SNR>16_initVariable('g:NERDTreeMapCloseDir', 'x')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCloseDir = 'x'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 121: call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")
calling function <SNR>16_initVariable('g:NERDTreeMapDeleteBookmark', 'D')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapDeleteBookmark = 'D'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 122: call s:initVariable("g:NERDTreeMapMenu", "m")
calling function <SNR>16_initVariable('g:NERDTreeMapMenu', 'm')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapMenu = 'm'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 123: call s:initVariable("g:NERDTreeMapHelp", "?")
calling function <SNR>16_initVariable('g:NERDTreeMapHelp', '?')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapHelp = '?'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 124: call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")
calling function <SNR>16_initVariable('g:NERDTreeMapJumpFirstChild', 'K')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpFirstChild = 'K'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 125: call s:initVariable("g:NERDTreeMapJumpLastChild", "J")
calling function <SNR>16_initVariable('g:NERDTreeMapJumpLastChild', 'J')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpLastChild = 'J'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 126: call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")
calling function <SNR>16_initVariable('g:NERDTreeMapJumpNextSibling', '<C-j>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpNextSibling = '<C-j>'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 127: call s:initVariable("g:NERDTreeMapJumpParent", "p")
calling function <SNR>16_initVariable('g:NERDTreeMapJumpParent', 'p')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpParent = 'p'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 128: call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")
calling function <SNR>16_initVariable('g:NERDTreeMapJumpPrevSibling', '<C-k>')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpPrevSibling = '<C-k>'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 129: call s:initVariable("g:NERDTreeMapJumpRoot", "P")
calling function <SNR>16_initVariable('g:NERDTreeMapJumpRoot', 'P')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapJumpRoot = 'P'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 130: call s:initVariable("g:NERDTreeMapOpenExpl", "e")
calling function <SNR>16_initVariable('g:NERDTreeMapOpenExpl', 'e')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenExpl = 'e'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 131: call s:initVariable("g:NERDTreeMapOpenInTab", "t")
calling function <SNR>16_initVariable('g:NERDTreeMapOpenInTab', 't')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenInTab = 't'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 132: call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")
calling function <SNR>16_initVariable('g:NERDTreeMapOpenInTabSilent', 'T')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenInTabSilent = 'T'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 133: call s:initVariable("g:NERDTreeMapOpenRecursively", "O")
calling function <SNR>16_initVariable('g:NERDTreeMapOpenRecursively', 'O')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenRecursively = 'O'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 134: call s:initVariable("g:NERDTreeMapOpenSplit", "i")
calling function <SNR>16_initVariable('g:NERDTreeMapOpenSplit', 'i')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenSplit = 'i'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 135: call s:initVariable("g:NERDTreeMapOpenVSplit", "s")
calling function <SNR>16_initVariable('g:NERDTreeMapOpenVSplit', 's')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapOpenVSplit = 's'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 136: call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)
calling function <SNR>16_initVariable('g:NERDTreeMapPreview', 'go')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreview = 'go'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 137: call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)
calling function <SNR>16_initVariable('g:NERDTreeMapPreviewSplit', 'gi')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreviewSplit = 'gi'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 138: call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)
calling function <SNR>16_initVariable('g:NERDTreeMapPreviewVSplit', 'gs')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapPreviewVSplit = 'gs'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 139: call s:initVariable("g:NERDTreeMapQuit", "q")
calling function <SNR>16_initVariable('g:NERDTreeMapQuit', 'q')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapQuit = 'q'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 140: call s:initVariable("g:NERDTreeMapRefresh", "r")
calling function <SNR>16_initVariable('g:NERDTreeMapRefresh', 'r')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapRefresh = 'r'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 141: call s:initVariable("g:NERDTreeMapRefreshRoot", "R")
calling function <SNR>16_initVariable('g:NERDTreeMapRefreshRoot', 'R')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapRefreshRoot = 'R'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 142: call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")
calling function <SNR>16_initVariable('g:NERDTreeMapToggleBookmarks', 'B')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleBookmarks = 'B'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 143: call s:initVariable("g:NERDTreeMapToggleFiles", "F")
calling function <SNR>16_initVariable('g:NERDTreeMapToggleFiles', 'F')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleFiles = 'F'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 144: call s:initVariable("g:NERDTreeMapToggleFilters", "f")
calling function <SNR>16_initVariable('g:NERDTreeMapToggleFilters', 'f')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleFilters = 'f'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 145: call s:initVariable("g:NERDTreeMapToggleHidden", "I")
calling function <SNR>16_initVariable('g:NERDTreeMapToggleHidden', 'I')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleHidden = 'I'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 146: call s:initVariable("g:NERDTreeMapToggleZoom", "A")
calling function <SNR>16_initVariable('g:NERDTreeMapToggleZoom', 'A')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapToggleZoom = 'A'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 147: call s:initVariable("g:NERDTreeMapUpdir", "u")
calling function <SNR>16_initVariable('g:NERDTreeMapUpdir', 'u')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapUpdir = 'u'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 148: call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")
calling function <SNR>16_initVariable('g:NERDTreeMapUpdirKeepOpen', 'U')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapUpdirKeepOpen = 'U'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 149: call s:initVariable("g:NERDTreeMapCWD", "CD")
calling function <SNR>16_initVariable('g:NERDTreeMapCWD', 'CD')

line 1:     if !exists(a:var)
line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"
line 2: let g:NERDTreeMapCWD = 'CD'
line 3:         return 1
function <SNR>16_initVariable returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 150: 
line 151: "SECTION: Load class files{{{2
line 152: call nerdtree#loadClassFiles()
calling function nerdtree#loadClassFiles()

line 1:     runtime lib/nerdtree/path.vim
Searching for "lib/nerdtree/path.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/path.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/path.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/path.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/path.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/path.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 1: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/path.vim"
line 1: "we need to use this number many times for sorting... so we calculate it only
line 2: "once here
line 3: let s:NERDTreeSortStarIndex = index(g:NERDTreeSortOrder, '*')
line 4: " used in formating sortKey, e.g. '%04d'
line 5: if exists("log10")
line 6:     let s:sortKeyFormat = "%0" . float2nr(ceil(log10(len(g:NERDTreeSortOrder)))) . "d"
line 7: else
line 8:     let s:sortKeyFormat = "%04d"
line 9: endif
line 10: 
line 11: "CLASS: Path
line 12: "============================================================
line 13: let s:Path = {}
line 14: let g:NERDTreePath = s:Path
line 15: 
line 16: "FUNCTION: Path.AbsolutePathFor(str) {{{1
line 17: function! s:Path.AbsolutePathFor(str)
line 32: 
line 33: "FUNCTION: Path.bookmarkNames() {{{1
line 34: function! s:Path.bookmarkNames()
line 40: 
line 41: "FUNCTION: Path.cacheDisplayString() {{{1
line 42: function! s:Path.cacheDisplayString() abort
line 67: 
line 68: "FUNCTION: Path.changeToDir() {{{1
line 69: function! s:Path.changeToDir()
line 82: 
line 83: "FUNCTION: Path.compareTo() {{{1
line 84: "
line 85: "Compares this Path to the given path and returns 0 if they are equal, -1 if
line 86: "this Path is "less than" the given path, or 1 if it is "greater".
line 87: "
line 88: "Args:
line 89: "path: the path object to compare this to
line 90: "
line 91: "Return:
line 92: "1, -1 or 0
line 93: function! s:Path.compareTo(path)
line 126: 
line 127: "FUNCTION: Path.Create(fullpath) {{{1
line 128: "
line 129: "Factory method.
line 130: "
line 131: "Creates a path object with the given path. The path is also created on the
line 132: "filesystem. If the path already exists, a NERDTree.Path.Exists exception is
line 133: "thrown. If any other errors occur, a NERDTree.Path exception is thrown.
line 134: "
line 135: "Args:
line 136: "fullpath: the full filesystem path to the file/dir to create
line 137: function! s:Path.Create(fullpath)
line 163: 
line 164: "FUNCTION: Path.copy(dest) {{{1
line 165: "
line 166: "Copies the file/dir represented by this Path to the given location
line 167: "
line 168: "Args:
line 169: "dest: the location to copy this dir/file to
line 170: function! s:Path.copy(dest)
line 189: 
line 190: "FUNCTION: Path.CopyingSupported() {{{1
line 191: "
line 192: "returns 1 if copying is supported for this OS
line 193: function! s:Path.CopyingSupported()
line 196: 
line 197: "FUNCTION: Path.copyingWillOverwrite(dest) {{{1
line 198: "
line 199: "returns 1 if copy this path to the given location will cause files to
line 200: "overwritten
line 201: "
line 202: "Args:
line 203: "dest: the location this path will be copied to
line 204: function! s:Path.copyingWillOverwrite(dest)
line 216: 
line 217: "FUNCTION: Path.createParentDirectories(path) {{{1
line 218: "
line 219: "create parent directories for this path if needed
line 220: "without throwing any errors if those directories already exist
line 221: "
line 222: "Args:
line 223: "path: full path of the node whose parent directories may need to be created
line 224: function! s:Path.createParentDirectories(path)
line 230: 
line 231: "FUNCTION: Path.delete() {{{1
line 232: "
line 233: "Deletes the file or directory represented by this path.
line 234: "
line 235: "Throws NERDTree.Path.Deletion exceptions
line 236: function! s:Path.delete()
line 258: 
line 259: "FUNCTION: Path.displayString() {{{1
line 260: "
line 261: "Returns a string that specifies how the path should be represented as a
line 262: "string
line 263: function! s:Path.displayString()
line 270: 
line 271: "FUNCTION: Path.edit() {{{1
line 272: function! s:Path.edit()
line 275: 
line 276: "FUNCTION: Path.extractDriveLetter(fullpath) {{{1
line 277: "
line 278: "If running windows, cache the drive letter for this path
line 279: function! s:Path.extractDriveLetter(fullpath)
line 293: 
line 294: "FUNCTION: Path.exists() {{{1
line 295: "return 1 if this path points to a location that is readable or is a directory
line 296: function! s:Path.exists()
line 300: 
line 301: "FUNCTION: Path._escChars() {{{1
line 302: function! s:Path._escChars()
line 309: 
line 310: "FUNCTION: Path.getDir() {{{1
line 311: "
line 312: "Returns this path if it is a directory, else this paths parent.
line 313: "
line 314: "Return:
line 315: "a Path object
line 316: function! s:Path.getDir()
line 323: 
line 324: "FUNCTION: Path.getParent() {{{1
line 325: "
line 326: "Returns a new path object for this paths parent
line 327: "
line 328: "Return:
line 329: "a new Path object
line 330: function! s:Path.getParent()
line 339: 
line 340: "FUNCTION: Path.getLastPathComponent(dirSlash) {{{1
line 341: "
line 342: "Gets the last part of this path.
line 343: "
line 344: "Args:
line 345: "dirSlash: if 1 then a trailing slash will be added to the returned value for
line 346: "directory nodes.
line 347: function! s:Path.getLastPathComponent(dirSlash)
line 357: 
line 358: "FUNCTION: Path.getSortOrderIndex() {{{1
line 359: "returns the index of the pattern in g:NERDTreeSortOrder that this path matches
line 360: function! s:Path.getSortOrderIndex()
line 370: 
line 371: "FUNCTION: Path.getSortKey() {{{1
line 372: "returns a string used in compare function for sorting
line 373: function! s:Path.getSortKey()
line 387: 
line 388: 
line 389: "FUNCTION: Path.isUnixHiddenFile() {{{1
line 390: "check for unix hidden files
line 391: function! s:Path.isUnixHiddenFile()
line 394: 
line 395: "FUNCTION: Path.isUnixHiddenPath() {{{1
line 396: "check for unix path with hidden components
line 397: function! s:Path.isUnixHiddenPath()
line 409: 
line 410: "FUNCTION: Path.ignore(nerdtree) {{{1
line 411: "returns true if this path should be ignored
line 412: function! s:Path.ignore(nerdtree)
line 439: 
line 440: "FUNCTION: Path._ignorePatternMatches(pattern) {{{1
line 441: "returns true if this path matches the given ignore pattern
line 442: function! s:Path._ignorePatternMatches(pattern)
line 458: 
line 459: "FUNCTION: Path.isAncestor(path) {{{1
line 460: "return 1 if this path is somewhere above the given path in the filesystem.
line 461: "
line 462: "a:path should be a dir
line 463: function! s:Path.isAncestor(path)
line 472: 
line 473: "FUNCTION: Path.isUnder(path) {{{1
line 474: "return 1 if this path is somewhere under the given path in the filesystem.
line 475: function! s:Path.isUnder(path)
line 484: 
line 485: "FUNCTION: Path.JoinPathStrings(...) {{{1
line 486: function! s:Path.JoinPathStrings(...)
line 493: 
line 494: "FUNCTION: Path.equals() {{{1
line 495: "
line 496: "Determines whether 2 path objects are "equal".
line 497: "They are equal if the paths they represent are the same
line 498: "
line 499: "Args:
line 500: "path: the other path obj to compare this with
line 501: function! s:Path.equals(path)
line 504: 
line 505: "FUNCTION: Path.New() {{{1
line 506: "The Constructor for the Path object
line 507: function! s:Path.New(path)
line 517: 
line 518: "FUNCTION: Path.Slash() {{{1
line 519: "return the slash to use for the current OS
line 520: function! s:Path.Slash()
line 523: 
line 524: "FUNCTION: Path.Resolve() {{{1
line 525: "Invoke the vim resolve() function and return the result
line 526: "This is necessary because in some versions of vim resolve() removes trailing
line 527: "slashes while in other versions it doesn't.  This always removes the trailing
line 528: "slash
line 529: function! s:Path.Resolve(path)
line 533: 
line 534: "FUNCTION: Path.readInfoFromDisk(fullpath) {{{1
line 535: "
line 536: "
line 537: "Throws NERDTree.Path.InvalidArguments exception.
line 538: function! s:Path.readInfoFromDisk(fullpath)
line 587: 
line 588: "FUNCTION: Path.refresh(nerdtree) {{{1
line 589: function! s:Path.refresh(nerdtree)
line 594: 
line 595: "FUNCTION: Path.refreshFlags(nerdtree) {{{1
line 596: function! s:Path.refreshFlags(nerdtree)
line 600: 
line 601: "FUNCTION: Path.rename() {{{1
line 602: "
line 603: "Renames this node on the filesystem
line 604: function! s:Path.rename(newPath)
line 621: 
line 622: "FUNCTION: Path.str() {{{1
line 623: "
line 624: "Returns a string representation of this Path
line 625: "
line 626: "Takes an optional dictionary param to specify how the output should be
line 627: "formatted.
line 628: "
line 629: "The dict may have the following keys:
line 630: "  'format'
line 631: "  'escape'
line 632: "  'truncateTo'
line 633: "
line 634: "The 'format' key may have a value of:
line 635: "  'Cd' - a string to be used with the :cd command
line 636: "  'Edit' - a string to be used with :e :sp :new :tabedit etc
line 637: "  'UI' - a string used in the NERD tree UI
line 638: "
line 639: "The 'escape' key, if specified will cause the output to be escaped with
line 640: "shellescape()
line 641: "
line 642: "The 'truncateTo' key causes the resulting string to be truncated to the value
line 643: "'truncateTo' maps to. A '<' char will be prepended.
line 644: function! s:Path.str(...)
line 677: 
line 678: "FUNCTION: Path._strForUI() {{{1
line 679: function! s:Path._strForUI()
line 686: 
line 687: "FUNCTION: Path._strForCd() {{{1
line 688: "
line 689: " returns a string that can be used with :cd
line 690: function! s:Path._strForCd()
line 693: 
line 694: "FUNCTION: Path._strForEdit() {{{1
line 695: "
line 696: "Return: the string for this path that is suitable to be used with the :edit
line 697: "command
line 698: function! s:Path._strForEdit()
line 716: 
line 717: "FUNCTION: Path._strForGlob() {{{1
line 718: function! s:Path._strForGlob()
line 733: 
line 734: "FUNCTION: Path._str() {{{1
line 735: "
line 736: "Gets the string path for this path object that is appropriate for the OS.
line 737: "EG, in windows c:\foo\bar
line 738: "    in *nix  /foo/bar
line 739: function! s:Path._str()
line 749: 
line 750: "FUNCTION: Path.strTrunk() {{{1
line 751: "Gets the path without the last segment on the end.
line 752: function! s:Path.strTrunk()
line 755: 
line 756: " FUNCTION: Path.tabnr() {{{1
line 757: " return the number of the first tab that is displaying this file
line 758: "
line 759: " return 0 if no tab was found
line 760: function! s:Path.tabnr()
line 771: 
line 772: "FUNCTION: Path.WinToUnixPath(pathstr){{{1
line 773: "Takes in a windows path and returns the unix equiv
line 774: "
line 775: "A class level method
line 776: "
line 777: "Args:
line 778: "pathstr: the windows path to convert
line 779: function! s:Path.WinToUnixPath(pathstr)
line 797: 
line 798: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/path.vim
continuing in function nerdtree#loadClassFiles
line 2:     runtime lib/nerdtree/menu_controller.vim
Searching for "lib/nerdtree/menu_controller.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/menu_controller.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/menu_controller.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/menu_controller.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/menu_controller.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 2: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim"
line 1: "CLASS: MenuController
line 2: "============================================================
line 3: let s:MenuController = {}
line 4: let g:NERDTreeMenuController = s:MenuController
line 5: 
line 6: "FUNCTION: MenuController.New(menuItems) {{{1
line 7: "create a new menu controller that operates on the given menu items
line 8: function! s:MenuController.New(menuItems)
line 17: 
line 18: "FUNCTION: MenuController.showMenu() {{{1
line 19: "start the main loop of the menu and get the user to choose/execute a menu
line 20: "item
line 21: function! s:MenuController.showMenu()
line 43: 
line 44: "FUNCTION: MenuController._echoPrompt() {{{1
line 45: function! s:MenuController._echoPrompt()
line 57: 
line 58: "FUNCTION: MenuController._current(key) {{{1
line 59: "get the MenuItem that is currently selected
line 60: function! s:MenuController._current()
line 63: 
line 64: "FUNCTION: MenuController._handleKeypress(key) {{{1
line 65: "change the selection (if appropriate) and return 1 if the user has made
line 66: "their choice, 0 otherwise
line 67: function! s:MenuController._handleKeypress(key)
line 89: 
line 90: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{1
line 91: "get indexes to all menu items with the given shortcut
line 92: function! s:MenuController._allIndexesFor(shortcut)
line 103: 
line 104: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{1
line 105: "get the index to the next menu item with the given shortcut, starts from the
line 106: "current cursor location and wraps around to the top again if need be
line 107: function! s:MenuController._nextIndexFor(shortcut)
line 122: 
line 123: "FUNCTION: MenuController._setCmdheight() {{{1
line 124: "sets &cmdheight to whatever is needed to display the menu
line 125: function! s:MenuController._setCmdheight()
line 128: 
line 129: "FUNCTION: MenuController._saveOptions() {{{1
line 130: "set any vim options that are required to make the menu work (saving their old
line 131: "values)
line 132: function! s:MenuController._saveOptions()
line 138: 
line 139: "FUNCTION: MenuController._restoreOptions() {{{1
line 140: "restore the options we saved in _saveOptions()
line 141: function! s:MenuController._restoreOptions()
line 145: 
line 146: "FUNCTION: MenuController._cursorDown() {{{1
line 147: "move the cursor to the next menu item, skipping separators
line 148: function! s:MenuController._cursorDown()
line 162: 
line 163: "FUNCTION: MenuController._cursorUp() {{{1
line 164: "move the cursor to the previous menu item, skipping separators
line 165: function! s:MenuController._cursorUp()
line 179: 
line 180: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/menu_controller.vim
continuing in function nerdtree#loadClassFiles
line 3:     runtime lib/nerdtree/menu_item.vim
Searching for "lib/nerdtree/menu_item.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/menu_item.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/menu_item.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/menu_item.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/menu_item.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 3: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim"
line 1: "CLASS: MenuItem
line 2: "============================================================
line 3: let s:MenuItem = {}
line 4: let g:NERDTreeMenuItem = s:MenuItem
line 5: 
line 6: "FUNCTION: MenuItem.All() {{{1
line 7: "get all top level menu items
line 8: function! s:MenuItem.All()
line 14: 
line 15: "FUNCTION: MenuItem.AllEnabled() {{{1
line 16: "get all top level menu items that are currently enabled
line 17: function! s:MenuItem.AllEnabled()
line 26: 
line 27: "FUNCTION: MenuItem.Create(options) {{{1
line 28: "make a new menu item and add it to the global list
line 29: function! s:MenuItem.Create(options)
line 54: 
line 55: "FUNCTION: MenuItem.CreateSeparator(options) {{{1
line 56: "make a new separator menu item and add it to the global list
line 57: function! s:MenuItem.CreateSeparator(options)
line 65: 
line 66: "FUNCTION: MenuItem.CreateSubmenu(options) {{{1
line 67: "make a new submenu and add it to global list
line 68: function! s:MenuItem.CreateSubmenu(options)
line 74: 
line 75: "FUNCTION: MenuItem.enabled() {{{1
line 76: "return 1 if this menu item should be displayed
line 77: "
line 78: "delegates off to the isActiveCallback, and defaults to 1 if no callback was
line 79: "specified
line 80: function! s:MenuItem.enabled()
line 86: 
line 87: "FUNCTION: MenuItem.execute() {{{1
line 88: "perform the action behind this menu item, if this menuitem has children then
line 89: "display a new menu for them, otherwise deletegate off to the menuitem's
line 90: "callback
line 91: function! s:MenuItem.execute()
line 101: 
line 102: "FUNCTION: MenuItem.isSeparator() {{{1
line 103: "return 1 if this menuitem is a separator
line 104: function! s:MenuItem.isSeparator()
line 107: 
line 108: "FUNCTION: MenuItem.isSubmenu() {{{1
line 109: "return 1 if this menuitem is a submenu
line 110: function! s:MenuItem.isSubmenu()
line 113: 
line 114: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/menu_item.vim
continuing in function nerdtree#loadClassFiles
line 4:     runtime lib/nerdtree/key_map.vim
Searching for "lib/nerdtree/key_map.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/key_map.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/key_map.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/key_map.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/key_map.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 4: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim"
line 1: "CLASS: KeyMap
line 2: "============================================================
line 3: let s:KeyMap = {}
line 4: let g:NERDTreeKeyMap = s:KeyMap
line 5: 
line 6: "FUNCTION: KeyMap.All() {{{1
line 7: function! s:KeyMap.All()
line 13: 
line 14: "FUNCTION: KeyMap.FindFor(key, scope) {{{1
line 15: function! s:KeyMap.FindFor(key, scope)
line 23: 
line 24: "FUNCTION: KeyMap.BindAll() {{{1
line 25: function! s:KeyMap.BindAll()
line 30: 
line 31: "FUNCTION: KeyMap.bind() {{{1
line 32: function! s:KeyMap.bind()
line 49: 
line 50: "FUNCTION: KeyMap.Remove(key, scope) {{{1
line 51: function! s:KeyMap.Remove(key, scope)
line 59: 
line 60: "FUNCTION: KeyMap.invoke() {{{1
line 61: "Call the KeyMaps callback function
line 62: function! s:KeyMap.invoke(...)
line 70: 
line 71: "FUNCTION: KeyMap.Invoke() {{{1
line 72: "Find a keymapping for a:key and the current scope invoke it.
line 73: "
line 74: "Scope is determined as follows:
line 75: "   * if the cursor is on a dir node then "DirNode"
line 76: "   * if the cursor is on a file node then "FileNode"
line 77: "   * if the cursor is on a bookmark then "Bookmark"
line 78: "
line 79: "If a keymap has the scope of "all" then it will be called if no other keymap
line 80: "is found for a:key and the scope.
line 81: function! s:KeyMap.Invoke(key)
line 134: 
line 135: "FUNCTION: KeyMap.Create(options) {{{1
line 136: function! s:KeyMap.Create(options)
line 152: 
line 153: "FUNCTION: KeyMap.Add(keymap) {{{1
line 154: function! s:KeyMap.Add(keymap)
line 158: 
line 159: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/key_map.vim
continuing in function nerdtree#loadClassFiles
line 5:     runtime lib/nerdtree/bookmark.vim
Searching for "lib/nerdtree/bookmark.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/bookmark.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/bookmark.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/bookmark.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/bookmark.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 5: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim"
line 1: "CLASS: Bookmark
line 2: "============================================================
line 3: let s:Bookmark = {}
line 4: let g:NERDTreeBookmark = s:Bookmark
line 5: 
line 6: " FUNCTION: Bookmark.activate(nerdtree) {{{1
line 7: function! s:Bookmark.activate(nerdtree, ...)
line 10: 
line 11: " FUNCTION: Bookmark.AddBookmark(name, path) {{{1
line 12: " Class method to add a new bookmark to the list, if a previous bookmark exists
line 13: " with the same name, just update the path for that bookmark
line 14: function! s:Bookmark.AddBookmark(name, path)
line 26: 
line 27: " FUNCTION: Bookmark.Bookmarks()   {{{1
line 28: " Class method to get all bookmarks. Lazily initializes the bookmarks global
line 29: " variable
line 30: function! s:Bookmark.Bookmarks()
line 36: 
line 37: " FUNCTION: Bookmark.BookmarkExistsFor(name)   {{{1
line 38: " class method that returns 1 if a bookmark with the given name is found, 0
line 39: " otherwise
line 40: function! s:Bookmark.BookmarkExistsFor(name)
line 48: 
line 49: " FUNCTION: Bookmark.BookmarkFor(name)   {{{1
line 50: " Class method to get the bookmark that has the given name. {} is return if no
line 51: " bookmark is found
line 52: function! s:Bookmark.BookmarkFor(name)
line 60: 
line 61: " FUNCTION: Bookmark.BookmarkNames()   {{{1
line 62: " Class method to return an array of all bookmark names
line 63: function! s:Bookmark.BookmarkNames()
line 70: 
line 71: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{1
line 72: " Class method to read all bookmarks from the bookmarks file initialize
line 73: " bookmark objects for each one.
line 74: "
line 75: " Args:
line 76: " silent - dont echo an error msg if invalid bookmarks are found
line 77: function! s:Bookmark.CacheBookmarks(silent)
line 112: 
line 113: " FUNCTION: Bookmark.compareTo(otherbookmark) {{{1
line 114: " Compare these two bookmarks for sorting purposes
line 115: function! s:Bookmark.compareTo(otherbookmark)
line 118: " FUNCTION: Bookmark.ClearAll() {{{1
line 119: " Class method to delete all bookmarks.
line 120: function! s:Bookmark.ClearAll()
line 126: 
line 127: " FUNCTION: Bookmark.delete() {{{1
line 128: " Delete this bookmark. If the node for this bookmark is under the current
line 129: " root, then recache bookmarks for its Path object
line 130: function! s:Bookmark.delete()
line 134: 
line 135: " FUNCTION: Bookmark.getNode(nerdtree, searchFromAbsoluteRoot) {{{1
line 136: " Gets the treenode for this bookmark
line 137: "
line 138: " Args:
line 139: " searchFromAbsoluteRoot: specifies whether we should search from the current
line 140: " tree root, or the highest cached node
line 141: function! s:Bookmark.getNode(nerdtree, searchFromAbsoluteRoot)
line 149: 
line 150: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree) {{{1
line 151: " Class method that finds the bookmark with the given name and returns the
line 152: " treenode for it.
line 153: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot, nerdtree)
line 157: 
line 158: " FUNCTION: Bookmark.GetSelected() {{{1
line 159: " returns the Bookmark the cursor is over, or {}
line 160: function! s:Bookmark.GetSelected()
line 172: 
line 173: " FUNCTION: Bookmark.InvalidBookmarks()   {{{1
line 174: " Class method to get all invalid bookmark strings read from the bookmarks
line 175: " file
line 176: function! s:Bookmark.InvalidBookmarks()
line 182: 
line 183: " FUNCTION: Bookmark.mustExist() {{{1
line 184: function! s:Bookmark.mustExist()
line 191: 
line 192: " FUNCTION: Bookmark.New(name, path) {{{1
line 193: " Create a new bookmark object with the given name and path object
line 194: function! s:Bookmark.New(name, path)
line 204: 
line 205: " FUNCTION: Bookmark.open(nerdtree, [options]) {{{1
line 206: "Args:
line 207: "
line 208: "nerdtree: the tree to load open the bookmark in
line 209: "
line 210: "A dictionary containing the following keys (all optional):
line 211: "  'where': Specifies whether the node should be opened in new split/tab or in
line 212: "           the previous window. Can be either 'v' (vertical split), 'h'
line 213: "           (horizontal split), 't' (new tab) or 'p' (previous window).
line 214: "  'reuse': if a window is displaying the file then jump the cursor there
line 215: "  'keepopen': dont close the tree window
line 216: "  'stay': open the file, but keep the cursor in the tree win
line 217: "
line 218: function! s:Bookmark.open(nerdtree, ...)
line 228: 
line 229: " FUNCTION: Bookmark.openInNewTab(options) {{{1
line 230: " Create a new bookmark object with the given name and path object
line 231: function! s:Bookmark.openInNewTab(options)
line 235: 
line 236: " FUNCTION: Bookmark.setPath(path)   {{{1
line 237: " makes this bookmark point to the given path
line 238: function! s:Bookmark.setPath(path)
line 241: 
line 242: " FUNCTION: Bookmark.Sort()   {{{1
line 243: " Class method that sorts all bookmarks
line 244: function! s:Bookmark.Sort()
line 248: 
line 249: " FUNCTION: Bookmark.str()   {{{1
line 250: " Get the string that should be rendered in the view for this bookmark
line 251: function! s:Bookmark.str()
line 263: 
line 264: " FUNCTION: Bookmark.toRoot(nerdtree) {{{1
line 265: " Make the node for this bookmark the new tree root
line 266: function! s:Bookmark.toRoot(nerdtree)
line 276: 
line 277: " FUNCTION: Bookmark.ToRoot(name, nerdtree) {{{1
line 278: " Make the node for this bookmark the new tree root
line 279: function! s:Bookmark.ToRoot(name, nerdtree)
line 283: 
line 284: " FUNCTION: Bookmark.validate() {{{1
line 285: function! s:Bookmark.validate()
line 294: 
line 295: " FUNCTION: Bookmark.Write()   {{{1
line 296: " Class method to write all bookmarks to the bookmarks file
line 297: function! s:Bookmark.Write()
line 311: 
line 312: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/bookmark.vim
continuing in function nerdtree#loadClassFiles
line 6:     runtime lib/nerdtree/tree_file_node.vim
Searching for "lib/nerdtree/tree_file_node.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/tree_file_node.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/tree_file_node.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/tree_file_node.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 6: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim"
line 1: "CLASS: TreeFileNode
line 2: "This class is the parent of the TreeDirNode class and is the
line 3: "'Component' part of the composite design pattern between the treenode
line 4: "classes.
line 5: "============================================================
line 6: let s:TreeFileNode = {}
line 7: let g:NERDTreeFileNode = s:TreeFileNode
line 8: 
line 9: "FUNCTION: TreeFileNode.activate(...) {{{1
line 10: function! s:TreeFileNode.activate(...)
line 13: 
line 14: "FUNCTION: TreeFileNode.bookmark(name) {{{1
line 15: "bookmark this node with a:name
line 16: function! s:TreeFileNode.bookmark(name)
line 35: 
line 36: "FUNCTION: TreeFileNode.cacheParent() {{{1
line 37: "initializes self.parent if it isnt already
line 38: function! s:TreeFileNode.cacheParent()
line 47: 
line 48: "FUNCTION: TreeFileNode.clearBookmarks() {{{1
line 49: function! s:TreeFileNode.clearBookmarks()
line 57: 
line 58: "FUNCTION: TreeFileNode.copy(dest) {{{1
line 59: function! s:TreeFileNode.copy(dest)
line 70: 
line 71: "FUNCTION: TreeFileNode.delete {{{1
line 72: "Removes this node from the tree and calls the Delete method for its path obj
line 73: function! s:TreeFileNode.delete()
line 77: 
line 78: "FUNCTION: TreeFileNode.displayString() {{{1
line 79: "
line 80: "Returns a string that specifies how the node should be represented as a
line 81: "string
line 82: "
line 83: "Return:
line 84: "a string that can be used in the view to represent this node
line 85: function! s:TreeFileNode.displayString()
line 88: 
line 89: "FUNCTION: TreeFileNode.equals(treenode) {{{1
line 90: "
line 91: "Compares this treenode to the input treenode and returns 1 if they are the
line 92: "same node.
line 93: "
line 94: "Use this method instead of ==  because sometimes when the treenodes contain
line 95: "many children, vim seg faults when doing ==
line 96: "
line 97: "Args:
line 98: "treenode: the other treenode to compare to
line 99: function! s:TreeFileNode.equals(treenode)
line 102: 
line 103: "FUNCTION: TreeFileNode.findNode(path) {{{1
line 104: "Returns self if this node.path.Equals the given path.
line 105: "Returns {} if not equal.
line 106: "
line 107: "Args:
line 108: "path: the path object to compare against
line 109: function! s:TreeFileNode.findNode(path)
line 115: 
line 116: "FUNCTION: TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction) {{{1
line 117: "
line 118: "Finds the next sibling for this node in the indicated direction. This sibling
line 119: "must be a directory and may/may not have children as specified.
line 120: "
line 121: "Args:
line 122: "direction: 0 if you want to find the previous sibling, 1 for the next sibling
line 123: "
line 124: "Return:
line 125: "a treenode object or {} if no appropriate sibling could be found
line 126: function! s:TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction)
line 141: 
line 142: "FUNCTION: TreeFileNode.findSibling(direction) {{{1
line 143: "
line 144: "Finds the next sibling for this node in the indicated direction
line 145: "
line 146: "Args:
line 147: "direction: 0 if you want to find the previous sibling, 1 for the next sibling
line 148: "
line 149: "Return:
line 150: "a treenode object or {} if no sibling could be found
line 151: function! s:TreeFileNode.findSibling(direction)
line 180: 
line 181: "FUNCTION: TreeFileNode.getNerdtree(){{{1
line 182: function! s:TreeFileNode.getNerdtree()
line 185: 
line 186: "FUNCTION: TreeFileNode.GetRootForTab(){{{1
line 187: "get the root node for this tab
line 188: function! s:TreeFileNode.GetRootForTab()
line 194: 
line 195: "FUNCTION: TreeFileNode.GetSelected() {{{1
line 196: "gets the treenode that the cursor is currently over
line 197: function! s:TreeFileNode.GetSelected()
line 208: 
line 209: "FUNCTION: TreeFileNode.isVisible() {{{1
line 210: "returns 1 if this node should be visible according to the tree filters and
line 211: "hidden file filters (and their on/off status)
line 212: function! s:TreeFileNode.isVisible()
line 215: 
line 216: "FUNCTION: TreeFileNode.isRoot() {{{1
line 217: function! s:TreeFileNode.isRoot()
line 224: 
line 225: "FUNCTION: TreeFileNode.New(path, nerdtree) {{{1
line 226: "Returns a new TreeNode object with the given path and parent
line 227: "
line 228: "Args:
line 229: "path: file/dir that the node represents
line 230: "nerdtree: the tree the node belongs to
line 231: function! s:TreeFileNode.New(path, nerdtree)
line 242: 
line 243: "FUNCTION: TreeFileNode.open() {{{1
line 244: function! s:TreeFileNode.open(...)
line 249: 
line 250: "FUNCTION: TreeFileNode.openSplit() {{{1
line 251: "Open this node in a new window
line 252: function! s:TreeFileNode.openSplit()
line 256: 
line 257: "FUNCTION: TreeFileNode.openVSplit() {{{1
line 258: "Open this node in a new vertical window
line 259: function! s:TreeFileNode.openVSplit()
line 263: 
line 264: "FUNCTION: TreeFileNode.openInNewTab(options) {{{1
line 265: function! s:TreeFileNode.openInNewTab(options)
line 269: 
line 270: "FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{1
line 271: "Places the cursor on the line number this node is rendered on
line 272: "
line 273: "Args:
line 274: "isJump: 1 if this cursor movement should be counted as a jump by vim
line 275: "recurseUpward: try to put the cursor on the parent if the this node isnt
line 276: "visible
line 277: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)
line 296: 
line 297: "FUNCTION: TreeFileNode.refresh() {{{1
line 298: function! s:TreeFileNode.refresh()
line 301: 
line 302: "FUNCTION: TreeFileNode.refreshFlags() {{{1
line 303: function! s:TreeFileNode.refreshFlags()
line 306: 
line 307: "FUNCTION: TreeFileNode.rename() {{{1
line 308: "Calls the rename method for this nodes path obj
line 309: function! s:TreeFileNode.rename(newName)
line 322: 
line 323: "FUNCTION: TreeFileNode.renderToString {{{1
line 324: "returns a string representation for this tree to be rendered in the view
line 325: function! s:TreeFileNode.renderToString()
line 328: 
line 329: "Args:
line 330: "depth: the current depth in the tree for this call
line 331: "drawText: 1 if we should actually draw the line for this node (if 0 then the
line 332: "child nodes are rendered only)
line 333: "for each depth in the tree
line 334: function! s:TreeFileNode._renderToString(depth, drawText)
line 367: 
line 368: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/tree_file_node.vim
continuing in function nerdtree#loadClassFiles
line 7:     runtime lib/nerdtree/tree_dir_node.vim
Searching for "lib/nerdtree/tree_dir_node.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/tree_dir_node.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/tree_dir_node.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 7: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim"
line 1: "CLASS: TreeDirNode
line 2: "A subclass of NERDTreeFileNode.
line 3: "
line 4: "The 'composite' part of the file/dir composite.
line 5: "============================================================
line 6: let s:TreeDirNode = copy(g:NERDTreeFileNode)
line 7: let g:NERDTreeDirNode = s:TreeDirNode
line 8: 
line 9: "FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{1
line 10: "class method that returns the highest cached ancestor of the current root
line 11: function! s:TreeDirNode.AbsoluteTreeRoot()
line 18: 
line 19: "FUNCTION: TreeDirNode.activate([options]) {{{1
line 20: unlet s:TreeDirNode.activate
line 21: function! s:TreeDirNode.activate(...)
line 27: 
line 28: "FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{1
line 29: "Adds the given treenode to the list of children for this node
line 30: "
line 31: "Args:
line 32: "-treenode: the node to add
line 33: "-inOrder: 1 if the new node should be inserted in sorted order
line 34: function! s:TreeDirNode.addChild(treenode, inOrder)
line 42: 
line 43: "FUNCTION: TreeDirNode.close() {{{1
line 44: "Closes this directory
line 45: function! s:TreeDirNode.close()
line 48: 
line 49: "FUNCTION: TreeDirNode.closeChildren() {{{1
line 50: "Closes all the child dir nodes of this node
line 51: function! s:TreeDirNode.closeChildren()
line 59: 
line 60: "FUNCTION: TreeDirNode.createChild(path, inOrder) {{{1
line 61: "Instantiates a new child node for this node with the given path. The new
line 62: "nodes parent is set to this node.
line 63: "
line 64: "Args:
line 65: "path: a Path object that this node will represent/contain
line 66: "inOrder: 1 if the new node should be inserted in sorted order
line 67: "
line 68: "Returns:
line 69: "the newly created node
line 70: function! s:TreeDirNode.createChild(path, inOrder)
line 75: 
line 76: "FUNCTION: TreeDirNode.displayString() {{{1
line 77: unlet s:TreeDirNode.displayString
line 78: function! s:TreeDirNode.displayString()
line 91: 
line 92: "FUNCTION: TreeDirNode.findNode(path) {{{1
line 93: "Will find one of the children (recursively) that has the given path
line 94: "
line 95: "Args:
line 96: "path: a path object
line 97: unlet s:TreeDirNode.findNode
line 98: function! s:TreeDirNode.findNode(path)
line 116: 
line 117: "FUNCTION: TreeDirNode.getCascade() {{{1
line 118: "Return an array of dir nodes (starting from self) that can be cascade opened.
line 119: function! s:TreeDirNode.getCascade()
line 129: 
line 130: "FUNCTION: TreeDirNode.getChildCount() {{{1
line 131: "Returns the number of children this node has
line 132: function! s:TreeDirNode.getChildCount()
line 135: 
line 136: "FUNCTION: TreeDirNode.getChild(path) {{{1
line 137: "Returns child node of this node that has the given path or {} if no such node
line 138: "exists.
line 139: "
line 140: "This function doesnt not recurse into child dir nodes
line 141: "
line 142: "Args:
line 143: "path: a path object
line 144: function! s:TreeDirNode.getChild(path)
line 157: 
line 158: "FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{1
line 159: "returns the child at the given index
line 160: "Args:
line 161: "indx: the index to get the child from
line 162: "visible: 1 if only the visible children array should be used, 0 if all the
line 163: "children should be searched.
line 164: function! s:TreeDirNode.getChildByIndex(indx, visible)
line 171: 
line 172: "FUNCTION: TreeDirNode.getChildIndex(path) {{{1
line 173: "Returns the index of the child node of this node that has the given path or
line 174: "-1 if no such node exists.
line 175: "
line 176: "This function doesnt not recurse into child dir nodes
line 177: "
line 178: "Args:
line 179: "path: a path object
line 180: function! s:TreeDirNode.getChildIndex(path)
line 202: 
line 203: "FUNCTION: TreeDirNode.getDirChildren() {{{1
line 204: "Get all children that are directories
line 205: function! s:TreeDirNode.getDirChildren()
line 208: 
line 209: "FUNCTION: TreeDirNode.GetSelected() {{{1
line 210: "Returns the current node if it is a dir node, or else returns the current
line 211: "nodes parent
line 212: unlet s:TreeDirNode.GetSelected
line 213: function! s:TreeDirNode.GetSelected()
line 222: 
line 223: "FUNCTION: TreeDirNode.getVisibleChildCount() {{{1
line 224: "Returns the number of visible children this node has
line 225: function! s:TreeDirNode.getVisibleChildCount()
line 228: 
line 229: "FUNCTION: TreeDirNode.getVisibleChildren() {{{1
line 230: "Returns a list of children to display for this node, in the correct order
line 231: "
line 232: "Return:
line 233: "an array of treenodes
line 234: function! s:TreeDirNode.getVisibleChildren()
line 243: 
line 244: "FUNCTION: TreeDirNode.hasVisibleChildren() {{{1
line 245: "returns 1 if this node has any childre, 0 otherwise..
line 246: function! s:TreeDirNode.hasVisibleChildren()
line 249: 
line 250: "FUNCTION: TreeDirNode.isCascadable() {{{1
line 251: "true if this dir has only one visible child - which is also a dir
line 252: function! s:TreeDirNode.isCascadable()
line 260: 
line 261: "FUNCTION: TreeDirNode._initChildren() {{{1
line 262: "Removes all childen from this node and re-reads them
line 263: "
line 264: "Args:
line 265: "silent: 1 if the function should not echo any "please wait" messages for
line 266: "large directories
line 267: "
line 268: "Return: the number of child nodes read
line 269: function! s:TreeDirNode._initChildren(silent)
line 319: 
line 320: "FUNCTION: TreeDirNode.New(path, nerdtree) {{{1
line 321: "Returns a new TreeNode object with the given path and parent
line 322: "
line 323: "Args:
line 324: "path: dir that the node represents
line 325: "nerdtree: the tree the node belongs to
line 326: function! s:TreeDirNode.New(path, nerdtree)
line 342: 
line 343: "FUNCTION: TreeDirNode.open([opts]) {{{1
line 344: "Open the dir in the current tree or in a new tree elsewhere.
line 345: "
line 346: "If opening in the current tree, return the number of cached nodes.
line 347: unlet s:TreeDirNode.open
line 348: function! s:TreeDirNode.open(...)
line 363: 
line 364: "FUNCTION: TreeDirNode.openAlong([opts]) {{{1
line 365: "recursive open the dir if it has only one directory child.
line 366: "
line 367: "return the level of opened directories.
line 368: function! s:TreeDirNode.openAlong(...)
line 384: 
line 385: " FUNCTION: TreeDirNode.openExplorer() {{{1
line 386: " opens an explorer window for this node in the previous window (could be a
line 387: " nerd tree or a netrw)
line 388: function! s:TreeDirNode.openExplorer()
line 391: 
line 392: "FUNCTION: TreeDirNode.openInNewTab(options) {{{1
line 393: unlet s:TreeDirNode.openInNewTab
line 394: function! s:TreeDirNode.openInNewTab(options)
line 398: 
line 399: "FUNCTION: TreeDirNode._openInNewTab() {{{1
line 400: function! s:TreeDirNode._openInNewTab()
line 404: 
line 405: "FUNCTION: TreeDirNode.openRecursively() {{{1
line 406: "Opens this treenode and all of its children whose paths arent 'ignored'
line 407: "because of the file filters.
line 408: "
line 409: "This method is actually a wrapper for the OpenRecursively2 method which does
line 410: "the work.
line 411: function! s:TreeDirNode.openRecursively()
line 414: 
line 415: "FUNCTION: TreeDirNode._openRecursively2() {{{1
line 416: "Opens this all children of this treenode recursively if either:
line 417: "   *they arent filtered by file filters
line 418: "   *a:forceOpen is 1
line 419: "
line 420: "Args:
line 421: "forceOpen: 1 if this node should be opened regardless of file filters
line 422: function! s:TreeDirNode._openRecursively2(forceOpen)
line 436: 
line 437: "FUNCTION: TreeDirNode.refresh() {{{1
line 438: unlet s:TreeDirNode.refresh
line 439: function! s:TreeDirNode.refresh()
line 492: 
line 493: "FUNCTION: TreeDirNode.refreshFlags() {{{1
line 494: unlet s:TreeDirNode.refreshFlags
line 495: function! s:TreeDirNode.refreshFlags()
line 501: 
line 502: "FUNCTION: TreeDirNode.refreshDirFlags() {{{1
line 503: function! s:TreeDirNode.refreshDirFlags()
line 506: 
line 507: "FUNCTION: TreeDirNode.reveal(path) {{{1
line 508: "reveal the given path, i.e. cache and open all treenodes needed to display it
line 509: "in the UI
line 510: "Returns the revealed node
line 511: function! s:TreeDirNode.reveal(path, ...)
line 536: 
line 537: "FUNCTION: TreeDirNode.removeChild(treenode) {{{1
line 538: "
line 539: "Removes the given treenode from this nodes set of children
line 540: "
line 541: "Args:
line 542: "treenode: the node to remove
line 543: "
line 544: "Throws a NERDTree.ChildNotFoundError if the given treenode is not found
line 545: function! s:TreeDirNode.removeChild(treenode)
line 555: 
line 556: "FUNCTION: TreeDirNode.sortChildren() {{{1
line 557: "
line 558: "Sorts the children of this node according to alphabetical order and the
line 559: "directory priority.
line 560: "
line 561: function! s:TreeDirNode.sortChildren()
line 565: 
line 566: "FUNCTION: TreeDirNode.toggleOpen([options]) {{{1
line 567: "Opens this directory if it is closed and vice versa
line 568: function! s:TreeDirNode.toggleOpen(...)
line 580: 
line 581: "FUNCTION: TreeDirNode.transplantChild(newNode) {{{1
line 582: "Replaces the child of this with the given node (where the child node's full
line 583: "path matches a:newNode's fullpath). The search for the matching node is
line 584: "non-recursive
line 585: "
line 586: "Arg:
line 587: "newNode: the node to graft into the tree
line 588: function! s:TreeDirNode.transplantChild(newNode)
line 597: 
line 598: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/tree_dir_node.vim
continuing in function nerdtree#loadClassFiles
line 8:     runtime lib/nerdtree/opener.vim
Searching for "lib/nerdtree/opener.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/opener.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/opener.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/opener.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/opener.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/opener.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 8: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/opener.vim"
line 1: "CLASS: Opener
line 2: "============================================================
line 3: let s:Opener = {}
line 4: let g:NERDTreeOpener = s:Opener
line 5: 
line 6: "FUNCTION: s:Opener._bufInWindows(bnum){{{1
line 7: "[[STOLEN FROM VTREEEXPLORER.VIM]]
line 8: "Determine the number of windows open to this buffer number.
line 9: "Care of Yegappan Lakshman.  Thanks!
line 10: "
line 11: "Args:
line 12: "bnum: the subject buffers buffer number
line 13: function! s:Opener._bufInWindows(bnum)
line 29: "FUNCTION: Opener._checkToCloseTree(newtab) {{{1
line 30: "Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see
line 31: "if the tree should be closed now.
line 32: "
line 33: "Args:
line 34: "a:newtab - boolean. If set, only close the tree now if we are opening the
line 35: "target in a new tab. This is needed because we have to close tree before we
line 36: "leave the tab
line 37: function! s:Opener._checkToCloseTree(newtab)
line 46: 
line 47: 
line 48: "FUNCTION: s:Opener._firstUsableWindow(){{{1
line 49: "find the window number of the first normal window
line 50: function! s:Opener._firstUsableWindow()
line 64: 
line 65: "FUNCTION: Opener._gotoTargetWin() {{{1
line 66: function! s:Opener._gotoTargetWin()
line 91: 
line 92: "FUNCTION: s:Opener._isWindowUsable(winnumber) {{{1
line 93: "Returns 0 if opening a file from the tree in the given window requires it to
line 94: "be split, 1 otherwise
line 95: "
line 96: "Args:
line 97: "winnumber: the number of the window in question
line 98: function! s:Opener._isWindowUsable(winnumber)
line 122: 
line 123: "FUNCTION: Opener.New(path, opts) {{{1
line 124: "Args:
line 125: "
line 126: "a:path: The path object that is to be opened.
line 127: "
line 128: "a:opts:
line 129: "
line 130: "A dictionary containing the following keys (all optional):
line 131: "  'where': Specifies whether the node should be opened in new split/tab or in
line 132: "           the previous window. Can be either 'v' or 'h' or 't' (for open in
line 133: "           new tab)
line 134: "  'reuse': if a window is displaying the file then jump the cursor there. Can
line 135: "           'all', 'currenttab' or empty to not reuse.
line 136: "  'keepopen': dont close the tree window
line 137: "  'stay': open the file, but keep the cursor in the tree win
line 138: function! s:Opener.New(path, opts)
line 157: 
line 158: "FUNCTION: Opener._newSplit() {{{1
line 159: function! s:Opener._newSplit()
line 217: 
line 218: "FUNCTION: Opener._newVSplit() {{{1
line 219: function! s:Opener._newVSplit()
line 233: 
line 234: "FUNCTION: Opener.open(target) {{{1
line 235: function! s:Opener.open(target)
line 242: 
line 243: "FUNCTION: Opener._openFile() {{{1
line 244: function! s:Opener._openFile()
line 255: 
line 256: "FUNCTION: Opener._openDirectory(node) {{{1
line 257: function! s:Opener._openDirectory(node)
line 276: 
line 277: "FUNCTION: Opener._previousWindow() {{{1
line 278: function! s:Opener._previousWindow()
line 296: 
line 297: "FUNCTION: Opener._restoreCursorPos(){{{1
line 298: function! s:Opener._restoreCursorPos()
line 302: 
line 303: "FUNCTION: Opener._reuseWindow(){{{1
line 304: "put the cursor in the first window we find for this file
line 305: "
line 306: "return 1 if we were successful
line 307: function! s:Opener._reuseWindow()
line 336: 
line 337: "FUNCTION: Opener._saveCursorPos(){{{1
line 338: function! s:Opener._saveCursorPos()
line 342: 
line 343: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/opener.vim
continuing in function nerdtree#loadClassFiles
line 9:     runtime lib/nerdtree/creator.vim
Searching for "lib/nerdtree/creator.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/creator.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/creator.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/creator.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/creator.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/creator.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 9: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/creator.vim"
line 1: "CLASS: Creator
line 2: "Creates tab/window/mirror nerdtree windows. Sets up all the window and
line 3: "buffer options and key mappings etc.
line 4: "============================================================
line 5: let s:Creator = {}
line 6: let g:NERDTreeCreator = s:Creator
line 7: 
line 8: "FUNCTION: s:Creator._bindMappings() {{{1
line 9: function! s:Creator._bindMappings()
line 24: 
line 25: "FUNCTION: s:Creator._broadcastInitEvent() {{{1
line 26: function! s:Creator._broadcastInitEvent()
line 29: 
line 30: " FUNCTION: s:Creator.BufNamePrefix() {{{2
line 31: function! s:Creator.BufNamePrefix()
line 34: 
line 35: "FUNCTION: s:Creator.CreateTabTree(a:name) {{{1
line 36: function! s:Creator.CreateTabTree(name)
line 40: 
line 41: "FUNCTION: s:Creator.createTabTree(a:name) {{{1
line 42: "name: the name of a bookmark or a directory
line 43: function! s:Creator.createTabTree(name)
line 76: 
line 77: "FUNCTION: s:Creator.CreateWindowTree(dir) {{{1
line 78: function! s:Creator.CreateWindowTree(dir)
line 82: 
line 83: "FUNCTION: s:Creator.createWindowTree(dir) {{{1
line 84: function! s:Creator.createWindowTree(dir)
line 109: 
line 110: " FUNCTION: s:Creator._createNERDTree(path) {{{1
line 111: function! s:Creator._createNERDTree(path, type)
line 120: 
line 121: " FUNCTION: s:Creator.CreateMirror() {{{1
line 122: function! s:Creator.CreateMirror()
line 126: 
line 127: " FUNCTION: s:Creator.createMirror() {{{1
line 128: function! s:Creator.createMirror()
line 179: 
line 180: "FUNCTION: s:Creator._createTreeWin() {{{1
line 181: "Inits the NERD tree window. ie. opens it, sizes it, sets all the local
line 182: "options etc
line 183: function! s:Creator._createTreeWin()
line 200: 
line 201: "FUNCTION: s:Creator._isBufHidden(nr) {{{1
line 202: function! s:Creator._isBufHidden(nr)
line 209: 
line 210: "FUNCTION: s:Creator.New() {{{1
line 211: function! s:Creator.New()
line 215: 
line 216: " FUNCTION: s:Creator._nextBufferName() {{{2
line 217: " returns the buffer name for the next nerd tree
line 218: function! s:Creator._nextBufferName()
line 222: 
line 223: " FUNCTION: s:Creator._nextBufferNumber() {{{2
line 224: " the number to add to the nerd tree buffer name to make the buf name unique
line 225: function! s:Creator._nextBufferNumber()
line 234: 
line 235: "FUNCTION: s:Creator._pathForString(str) {{{1
line 236: "find a bookmark or adirectory for the given string
line 237: function! s:Creator._pathForString(str)
line 263: 
line 264: " Function: s:Creator._removeTreeBufForTab()   {{{1
line 265: function! s:Creator._removeTreeBufForTab()
line 280: 
line 281: "FUNCTION: s:Creator._setCommonBufOptions() {{{1
line 282: function! s:Creator._setCommonBufOptions()
line 312: 
line 313: "FUNCTION: s:Creator._setupStatusline() {{{1
line 314: function! s:Creator._setupStatusline()
line 319: 
line 320: " FUNCTION: s:Creator._tabpagevar(tabnr, var) {{{1
line 321: function! s:Creator._tabpagevar(tabnr, var)
line 337: 
line 338: "FUNCTION: s:Creator.ToggleTabTree(dir) {{{1
line 339: function! s:Creator.ToggleTabTree(dir)
line 343: 
line 344: "FUNCTION: s:Creator.toggleTabTree(dir) {{{1
line 345: "Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is
line 346: "closed it is restored or initialized (if it doesnt exist)
line 347: "
line 348: "Args:
line 349: "dir: the full path for the root node (is only used if the NERD tree is being
line 350: "initialized.
line 351: function! s:Creator.toggleTabTree(dir)
line 366: 
line 367: " Function: s:Creator._uniq(list)   {{{1
line 368: " returns a:list without duplicates
line 369: function! s:Creator._uniq(list)
line 378: 
line 379: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/creator.vim
continuing in function nerdtree#loadClassFiles
line 10:     runtime lib/nerdtree/flag_set.vim
Searching for "lib/nerdtree/flag_set.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/flag_set.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/flag_set.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/flag_set.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/flag_set.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 10: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim"
line 1: "CLASS: FlagSet
line 2: "============================================================
line 3: let s:FlagSet = {}
line 4: let g:NERDTreeFlagSet = s:FlagSet
line 5: 
line 6: "FUNCTION: FlagSet.addFlag(scope, flag) {{{1
line 7: function! s:FlagSet.addFlag(scope, flag)
line 13: 
line 14: "FUNCTION: FlagSet.clearFlags(scope) {{{1
line 15: function! s:FlagSet.clearFlags(scope)
line 18: 
line 19: "FUNCTION: FlagSet._flagsForScope(scope) {{{1
line 20: function! s:FlagSet._flagsForScope(scope)
line 26: 
line 27: "FUNCTION: FlagSet.New() {{{1
line 28: function! s:FlagSet.New()
line 33: 
line 34: "FUNCTION: FlagSet.removeFlag(scope, flag) {{{1
line 35: function! s:FlagSet.removeFlag(scope, flag)
line 43: 
line 44: "FUNCTION: FlagSet.renderToString() {{{1
line 45: function! s:FlagSet.renderToString()
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/flag_set.vim
continuing in function nerdtree#loadClassFiles
line 11:     runtime lib/nerdtree/nerdtree.vim
Searching for "lib/nerdtree/nerdtree.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/nerdtree.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/nerdtree.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/nerdtree.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/nerdtree.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 11: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim"
line 1: "CLASS: NERDTree
line 2: "============================================================
line 3: let s:NERDTree = {}
line 4: let g:NERDTree = s:NERDTree
line 5: 
line 6: "FUNCTION: s:NERDTree.AddPathFilter() {{{1
line 7: function! s:NERDTree.AddPathFilter(callback)
line 10: 
line 11: "FUNCTION: s:NERDTree.changeRoot(node) {{{1
line 12: function! s:NERDTree.changeRoot(node)
line 32: 
line 33: "FUNCTION: s:NERDTree.Close() {{{1
line 34: "Closes the tab tree window for this tab
line 35: function! s:NERDTree.Close()
line 56: 
line 57: "FUNCTION: s:NERDTree.CloseIfQuitOnOpen() {{{1
line 58: "Closes the NERD tree window if the close on open option is set
line 59: function! s:NERDTree.CloseIfQuitOnOpen()
line 64: 
line 65: "FUNCTION: s:NERDTree.CursorToBookmarkTable(){{{1
line 66: "Places the cursor at the top of the bookmarks table
line 67: function! s:NERDTree.CursorToBookmarkTable()
line 87: 
line 88: "FUNCTION: s:NERDTree.CursorToTreeWin(){{{1
line 89: "Places the cursor in the nerd tree window
line 90: function! s:NERDTree.CursorToTreeWin()
line 94: 
line 95: " Function: s:NERDTree.ExistsForBuffer()   {{{1
line 96: " Returns 1 if a nerd tree root exists in the current buffer
line 97: function! s:NERDTree.ExistsForBuf()
line 100: 
line 101: " Function: s:NERDTree.ExistsForTab()   {{{1
line 102: " Returns 1 if a nerd tree root exists in the current tab
line 103: function! s:NERDTree.ExistsForTab()
line 111: 
line 112: function! s:NERDTree.ForCurrentBuf()
line 119: 
line 120: "FUNCTION: s:NERDTree.ForCurrentTab() {{{1
line 121: function! s:NERDTree.ForCurrentTab()
line 129: 
line 130: "FUNCTION: s:NERDTree.getRoot() {{{1
line 131: function! s:NERDTree.getRoot()
line 134: 
line 135: "FUNCTION: s:NERDTree.GetWinNum() {{{1
line 136: "gets the nerd tree window number for this tab
line 137: function! s:NERDTree.GetWinNum()
line 144: 
line 145: "FUNCTION: s:NERDTree.IsOpen() {{{1
line 146: function! s:NERDTree.IsOpen()
line 149: 
line 150: "FUNCTION: s:NERDTree.isTabTree() {{{1
line 151: function! s:NERDTree.isTabTree()
line 154: 
line 155: "FUNCTION: s:NERDTree.isWinTree() {{{1
line 156: function! s:NERDTree.isWinTree()
line 159: 
line 160: "FUNCTION: s:NERDTree.MustBeOpen() {{{1
line 161: function! s:NERDTree.MustBeOpen()
line 166: 
line 167: "FUNCTION: s:NERDTree.New() {{{1
line 168: function! s:NERDTree.New(path, type)
line 175: 
line 176: "FUNCTION: s:NERDTree.PathFilters() {{{1
line 177: function! s:NERDTree.PathFilters()
line 183: 
line 184: "FUNCTION: s:NERDTree.previousBuf() {{{1
line 185: function! s:NERDTree.previousBuf()
line 188: 
line 189: function! s:NERDTree.setPreviousBuf(bnum)
line 192: 
line 193: "FUNCTION: s:NERDTree.render() {{{1
line 194: "A convenience function - since this is called often
line 195: function! s:NERDTree.render()
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/nerdtree.vim
continuing in function nerdtree#loadClassFiles
line 12:     runtime lib/nerdtree/ui.vim
Searching for "lib/nerdtree/ui.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/ui.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/ui.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/ui.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/ui.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/ui.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 12: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/ui.vim"
line 1: "CLASS: UI
line 2: "============================================================
line 3: let s:UI = {}
line 4: let g:NERDTreeUI = s:UI
line 5: 
line 6: "FUNCTION: s:UI.centerView() {{{2
line 7: "centers the nerd tree window around the cursor (provided the nerd tree
line 8: "options permit)
line 9: function! s:UI.centerView()
line 19: 
line 20: "FUNCTION: s:UI._dumpHelp  {{{1
line 21: "prints out the quick help
line 22: function! s:UI._dumpHelp()
line 126: 
line 127: 
line 128: "FUNCTION: s:UI.new(nerdtree) {{{1
line 129: function! s:UI.New(nerdtree)
line 140: 
line 141: "FUNCTION: s:UI.getPath(ln) {{{1
line 142: "Gets the full path to the node that is rendered on the given line number
line 143: "
line 144: "Args:
line 145: "ln: the line number to get the path for
line 146: "
line 147: "Return:
line 148: "A path if a node was selected, {} if nothing is selected.
line 149: "If the 'up a dir' line was selected then the path to the parent of the
line 150: "current root is returned
line 151: function! s:UI.getPath(ln)
line 202: 
line 203: "FUNCTION: s:UI.getLineNum(file_node){{{1
line 204: "returns the line number this node is rendered on, or -1 if it isnt rendered
line 205: function! s:UI.getLineNum(file_node)
line 250: 
line 251: "FUNCTION: s:UI.getRootLineNum(){{{1
line 252: "gets the line number of the root node
line 253: function! s:UI.getRootLineNum()
line 260: 
line 261: "FUNCTION: s:UI.getShowBookmarks() {{{1
line 262: function! s:UI.getShowBookmarks()
line 265: 
line 266: "FUNCTION: s:UI.getShowFiles() {{{1
line 267: function! s:UI.getShowFiles()
line 270: 
line 271: "FUNCTION: s:UI.getShowHelp() {{{1
line 272: function! s:UI.getShowHelp()
line 275: 
line 276: "FUNCTION: s:UI.getShowHidden() {{{1
line 277: function! s:UI.getShowHidden()
line 280: 
line 281: "FUNCTION: s:UI._indentLevelFor(line) {{{1
line 282: function! s:UI._indentLevelFor(line)
line 290: 
line 291: "FUNCTION: s:UI.IndentWid() {{{1
line 292: function! s:UI.IndentWid()
line 295: 
line 296: "FUNCTION: s:UI.isIgnoreFilterEnabled() {{{1
line 297: function! s:UI.isIgnoreFilterEnabled()
line 300: 
line 301: "FUNCTION: s:UI.isMinimal() {{{1
line 302: function! s:UI.isMinimal()
line 305: 
line 306: "FUNCTION: s:UI.MarkupReg() {{{1
line 307: function! s:UI.MarkupReg()
line 310: 
line 311: "FUNCTION: s:UI._renderBookmarks {{{1
line 312: function! s:UI._renderBookmarks()
line 327: 
line 328: "FUNCTION: s:UI.restoreScreenState() {{{1
line 329: "
line 330: "Sets the screen state back to what it was when nerdtree#saveScreenState was last
line 331: "called.
line 332: "
line 333: "Assumes the cursor is in the NERDTree window
line 334: function! s:UI.restoreScreenState()
line 347: 
line 348: "FUNCTION: s:UI.saveScreenState() {{{1
line 349: "Saves the current cursor position in the current buffer and the window
line 350: "scroll position
line 351: function! s:UI.saveScreenState()
line 360: 
line 361: "FUNCTION: s:UI.setShowHidden(val) {{{1
line 362: function! s:UI.setShowHidden(val)
line 365: 
line 366: "FUNCTION: s:UI._stripMarkup(line, removeLeadingSpaces){{{1
line 367: "returns the given line with all the tree parts stripped off
line 368: "
line 369: "Args:
line 370: "line: the subject line
line 371: "removeLeadingSpaces: 1 if leading spaces are to be removed (leading spaces =
line 372: "any spaces before the actual text of the node)
line 373: function! s:UI._stripMarkup(line, removeLeadingSpaces)
line 405: 
line 406: "FUNCTION: s:UI.render() {{{1
line 407: function! s:UI.render()
line 461: 
line 462: 
line 463: "FUNCTION: UI.renderViewSavingPosition {{{1
line 464: "Renders the tree and ensures the cursor stays on the current node or the
line 465: "current nodes parent if it is no longer available upon re-rendering
line 466: function! s:UI.renderViewSavingPosition()
line 481: 
line 482: "FUNCTION: s:UI.toggleHelp() {{{1
line 483: function! s:UI.toggleHelp()
line 486: 
line 487: " FUNCTION: s:UI.toggleIgnoreFilter() {{{1
line 488: " toggles the use of the NERDTreeIgnore option
line 489: function! s:UI.toggleIgnoreFilter()
line 494: 
line 495: " FUNCTION: s:UI.toggleShowBookmarks() {{{1
line 496: " toggles the display of bookmarks
line 497: function! s:UI.toggleShowBookmarks()
line 507: 
line 508: " FUNCTION: s:UI.toggleShowFiles() {{{1
line 509: " toggles the display of hidden files
line 510: function! s:UI.toggleShowFiles()
line 515: 
line 516: " FUNCTION: s:UI.toggleShowHidden() {{{1
line 517: " toggles the display of hidden files
line 518: function! s:UI.toggleShowHidden()
line 523: 
line 524: " FUNCTION: s:UI.toggleZoom() {{{1
line 525: " zoom (maximize/minimize) the NERDTree window
line 526: function! s:UI.toggleZoom()
line 536: 
line 537: "FUNCTION: s:UI.UpDirLine() {{{1
line 538: function! s:UI.UpDirLine()
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/ui.vim
continuing in function nerdtree#loadClassFiles
line 13:     runtime lib/nerdtree/event.vim
Searching for "lib/nerdtree/event.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/event.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/event.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/event.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/event.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/event.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 13: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/event.vim"
line 1: "CLASS: Event
line 2: "============================================================
line 3: let s:Event = {}
line 4: let g:NERDTreeEvent = s:Event
line 5: 
line 6: function! s:Event.New(nerdtree, subject, action, params) abort
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/event.vim
continuing in function nerdtree#loadClassFiles
line 14:     runtime lib/nerdtree/notifier.vim
Searching for "lib/nerdtree/notifier.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/lib/nerdtree/notifier.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/lib/nerdtree/notifier.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/lib/nerdtree/notifier.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/lib/nerdtree/notifier.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree)
fchdir() to previous dir
line 14: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim"
line 1: "CLASS: Notifier
line 2: "============================================================
line 3: let s:Notifier = {}
line 4: 
line 5: function! s:Notifier.AddListener(event, funcname)
line 13: 
line 14: function! s:Notifier.NotifyListeners(event, path, nerdtree, params)
line 21: 
line 22: function! s:Notifier.GetListenersMap()
line 28: 
line 29: function! s:Notifier.GetListenersForEvent(name)
line 33: 
line 34: let g:NERDTreePathNotifier = deepcopy(s:Notifier)
line 35: 
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/lib/nerdtree/notifier.vim
continuing in function nerdtree#loadClassFiles
function nerdtree#loadClassFiles returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 153: 
line 154: " SECTION: Commands {{{1
line 155: "============================================================
line 156: call nerdtree#ui_glue#setupCommands()
Searching for "autoload/nerdtree/ui_glue.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/autoload/nerdtree/ui_glue.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/nerdtree/ui_glue.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/autoload/nerdtree/ui_glue.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/autoload/nerdtree)
fchdir() to previous dir
line 156: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim"
line 1: if exists("g:loaded_nerdtree_ui_glue_autoload")
line 2:     finish
line 3: endif
line 4: let g:loaded_nerdtree_ui_glue_autoload = 1
line 5: 
line 6: " FUNCTION: nerdtree#ui_glue#createDefaultBindings() {{{1
line 7: function! nerdtree#ui_glue#createDefaultBindings()
line 80: 
line 81: 
line 82: "SECTION: Interface bindings {{{1
line 83: "============================================================
line 84: 
line 85: "FUNCTION: s:activateAll() {{{1
line 86: "handle the user activating the updir line
line 87: function! s:activateAll()
line 92: 
line 93: "FUNCTION: s:activateDirNode() {{{1
line 94: "handle the user activating a tree node
line 95: function! s:activateDirNode(node)
line 98: 
line 99: "FUNCTION: s:activateFileNode() {{{1
line 100: "handle the user activating a tree node
line 101: function! s:activateFileNode(node)
line 104: 
line 105: "FUNCTION: s:activateBookmark() {{{1
line 106: "handle the user activating a bookmark
line 107: function! s:activateBookmark(bm)
line 110: 
line 111: " FUNCTION: nerdtree#ui_glue#bookmarkNode(name) {{{1
line 112: " Associate the current node with the given name
line 113: function! nerdtree#ui_glue#bookmarkNode(...)
line 130: 
line 131: " FUNCTION: s:chCwd(node) {{{1
line 132: function! s:chCwd(node)
line 139: 
line 140: " FUNCTION: s:chRoot(node) {{{1
line 141: " changes the current root to the selected one
line 142: function! s:chRoot(node)
line 145: 
line 146: " FUNCTION: s:nerdtree#ui_glue#chRootCwd() {{{1
line 147: " changes the current root to CWD
line 148: function! nerdtree#ui_glue#chRootCwd()
line 160: 
line 161: " FUNCTION: nnerdtree#ui_glue#clearBookmarks(bookmarks) {{{1
line 162: function! nerdtree#ui_glue#clearBookmarks(bookmarks)
line 177: 
line 178: " FUNCTION: s:closeChildren(node) {{{1
line 179: " closes all childnodes of the current node
line 180: function! s:closeChildren(node)
line 185: 
line 186: " FUNCTION: s:closeCurrentDir(node) {{{1
line 187: " closes the parent dir of the current node
line 188: function! s:closeCurrentDir(node)
line 206: 
line 207: " FUNCTION: s:closeTreeWindow() {{{1
line 208: " close the tree window
line 209: function! s:closeTreeWindow()
line 220: 
line 221: " FUNCTION: s:deleteBookmark(bm) {{{1
line 222: " if the cursor is on a bookmark, prompt to delete
line 223: function! s:deleteBookmark(bm)
line 240: 
line 241: " FUNCTION: s:displayHelp() {{{1
line 242: " toggles the help display
line 243: function! s:displayHelp()
line 248: 
line 249: " FUNCTION: s:findAndRevealPath() {{{1
line 250: function! s:findAndRevealPath()
line 300: 
line 301: "FUNCTION: s:handleLeftClick() {{{1
line 302: "Checks if the click should open the current node
line 303: function! s:handleLeftClick()
line 336: 
line 337: " FUNCTION: s:handleMiddleMouse() {{{1
line 338: function! s:handleMiddleMouse()
line 351: 
line 352: " FUNCTION: s:jumpToChild(direction) {{{2
line 353: " Args:
line 354: " direction: 0 if going to first child, 1 if going to last
line 355: function! s:jumpToChild(currentNode, direction)
line 379: 
line 380: 
line 381: " FUNCTION: nerdtree#ui_glue#invokeKeyMap(key) {{{1
line 382: "this is needed since I cant figure out how to invoke dict functions from a
line 383: "key map
line 384: function! nerdtree#ui_glue#invokeKeyMap(key)
line 387: 
line 388: " FUNCTION: s:jumpToFirstChild() {{{1
line 389: " wrapper for the jump to child method
line 390: function! s:jumpToFirstChild(node)
line 393: 
line 394: " FUNCTION: s:jumpToLastChild() {{{1
line 395: " wrapper for the jump to child method
line 396: function! s:jumpToLastChild(node)
line 399: 
line 400: " FUNCTION: s:jumpToParent(node) {{{1
line 401: " moves the cursor to the parent of the current node
line 402: function! s:jumpToParent(node)
line 410: 
line 411: " FUNCTION: s:jumpToRoot() {{{1
line 412: " moves the cursor to the root node
line 413: function! s:jumpToRoot()
line 417: 
line 418: " FUNCTION: s:jumpToNextSibling(node) {{{1
line 419: function! s:jumpToNextSibling(node)
line 422: 
line 423: " FUNCTION: s:jumpToPrevSibling(node) {{{1
line 424: function! s:jumpToPrevSibling(node)
line 427: 
line 428: " FUNCTION: s:jumpToSibling(currentNode, forward) {{{2
line 429: " moves the cursor to the sibling of the current node in the given direction
line 430: "
line 431: " Args:
line 432: " forward: 1 if the cursor should move to the next sibling, 0 if it should
line 433: " move back to the previous sibling
line 434: function! s:jumpToSibling(currentNode, forward)
line 442: 
line 443: " FUNCTION: nerdtree#ui_glue#openBookmark(name) {{{1
line 444: " put the cursor on the given bookmark and, if its a file, open it
line 445: function! nerdtree#ui_glue#openBookmark(name)
line 461: 
line 462: " FUNCTION: s:openHSplit(target) {{{1
line 463: function! s:openHSplit(target)
line 466: 
line 467: " FUNCTION: s:openVSplit(target) {{{1
line 468: function! s:openVSplit(target)
line 471: 
line 472: " FUNCTION: s:openExplorer(node) {{{1
line 473: function! s:openExplorer(node)
line 476: 
line 477: " FUNCTION: s:openInNewTab(target) {{{1
line 478: function! s:openInNewTab(target)
line 481: 
line 482: " FUNCTION: s:openInNewTabSilent(target) {{{1
line 483: function! s:openInNewTabSilent(target)
line 486: 
line 487: " FUNCTION: s:openNodeRecursively(node) {{{1
line 488: function! s:openNodeRecursively(node)
line 495: 
line 496: "FUNCTION: s:previewNodeCurrent(node) {{{1
line 497: function! s:previewNodeCurrent(node)
line 500: 
line 501: "FUNCTION: s:previewNodeHSplit(node) {{{1
line 502: function! s:previewNodeHSplit(node)
line 505: 
line 506: "FUNCTION: s:previewNodeVSplit(node) {{{1
line 507: function! s:previewNodeVSplit(node)
line 510: 
line 511: " FUNCTION: nerdtree#ui_glue#revealBookmark(name) {{{1
line 512: " put the cursor on the node associate with the given name
line 513: function! nerdtree#ui_glue#revealBookmark(name)
line 521: 
line 522: " FUNCTION: s:refreshRoot() {{{1
line 523: " Reloads the current root. All nodes below this will be lost and the root dir
line 524: " will be reloaded.
line 525: function! s:refreshRoot()
line 532: 
line 533: " FUNCTION: s:refreshCurrent(node) {{{1
line 534: " refreshes the root for the current node
line 535: function! s:refreshCurrent(node)
line 547: 
line 548: " FUNCTION: nerdtree#ui_glue#setupCommands() {{{1
line 549: function! nerdtree#ui_glue#setupCommands()
line 559: 
line 560: " Function: s:SID()   {{{1
line 561: function s:SID()
line 567: 
line 568: " FUNCTION: s:showMenu(node) {{{1
line 569: function! s:showMenu(node)
line 573: 
line 574: " FUNCTION: s:toggleIgnoreFilter() {{{1
line 575: function! s:toggleIgnoreFilter()
line 578: 
line 579: " FUNCTION: s:toggleShowBookmarks() {{{1
line 580: function! s:toggleShowBookmarks()
line 583: 
line 584: " FUNCTION: s:toggleShowFiles() {{{1
line 585: function! s:toggleShowFiles()
line 588: 
line 589: " FUNCTION: s:toggleShowHidden() {{{1
line 590: " toggles the display of hidden files
line 591: function! s:toggleShowHidden()
line 594: 
line 595: " FUNCTION: s:toggleZoom() {{{1
line 596: function! s:toggleZoom()
line 599: 
line 600: "FUNCTION: nerdtree#ui_glue#upDir(keepState) {{{1
line 601: "moves the tree up a level
line 602: "
line 603: "Args:
line 604: "keepState: 1 if the current root should be left open when the tree is
line 605: "re-rendered
line 606: function! nerdtree#ui_glue#upDir(keepState)
line 635: 
line 636: " FUNCTION: s:upDirCurrentRootOpen() {{{1
line 637: function! s:upDirCurrentRootOpen()
line 640: 
line 641: " FUNCTION: s:upDirCurrentRootClosed() {{{1
line 642: function! s:upDirCurrentRootClosed()
line 645: 
line 646: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/autoload/nerdtree/ui_glue.vim
continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim
calling function nerdtree#ui_glue#setupCommands()

line 1:     command! -n=? -complete=dir -bar NERDTree :call g:NERDTreeCreator.CreateTabTree('<args>')
line 2:     command! -n=? -complete=dir -bar NERDTreeToggle :call g:NERDTreeCreator.ToggleTabTree('<args>')
line 3:     command! -n=0 -bar NERDTreeClose :call g:NERDTree.Close()
line 4:     command! -n=1 -complete=customlist,nerdtree#completeBookmarks -bar NERDTreeFromBookmark call g:NERDTreeCreator.CreateTabTree('<args>')
line 5:     command! -n=0 -bar NERDTreeMirror call g:NERDTreeCreator.CreateMirror()
line 6:     command! -n=0 -bar NERDTreeFind call s:findAndRevealPath()
line 7:     command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()
line 8:     command! -n=0 -bar NERDTreeCWD call NERDTreeCWD()
function nerdtree#ui_glue#setupCommands returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 157: 
line 158: " SECTION: Auto commands {{{1
line 159: "============================================================
line 160: augroup NERDTree
line 161:     "Save the cursor position whenever we close the nerd tree
line 162:     exec "autocmd BufLeave ". g:NERDTreeCreator.BufNamePrefix() ."* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif"
calling function 181()

line 1:     return 'NERD_tree_'
function 181 returning 'NERD_tree_'

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 162: autocmd BufLeave NERD_tree_* if g:NERDTree.IsOpen() | call b:NERDTree.ui.saveScreenState() | endif
line 163: 
line 164:     "disallow insert mode in the NERDTree
line 165:     exec "autocmd BufEnter ". g:NERDTreeCreator.BufNamePrefix() ."* stopinsert"
calling function 181()

line 1:     return 'NERD_tree_'
function 181 returning 'NERD_tree_'

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 165: autocmd BufEnter NERD_tree_* stopinsert
line 166: augroup END
line 167: 
line 168: if g:NERDTreeHijackNetrw
line 169:     augroup NERDTreeHijackNetrw
line 170:         autocmd VimEnter * silent! autocmd! FileExplorer
line 171:         au BufEnter,VimEnter * call nerdtree#checkForBrowse(expand("<amatch>"))
line 172:     augroup END
line 173: endif
line 174: 
line 175: " SECTION: Public API {{{1
line 176: "============================================================
line 177: function! NERDTreeAddMenuItem(options)
line 180: 
line 181: function! NERDTreeAddMenuSeparator(...)
line 185: 
line 186: function! NERDTreeAddSubmenu(options)
line 189: 
line 190: function! NERDTreeAddKeyMap(options)
line 193: 
line 194: function! NERDTreeRender()
line 197: 
line 198: function! NERDTreeFocus()
line 205: 
line 206: function! NERDTreeCWD()
line 210: 
line 211: function! NERDTreeAddPathFilter(callback)
line 214: 
line 215: " SECTION: Post Source Actions {{{1
line 216: call nerdtree#postSourceActions()
calling function nerdtree#postSourceActions()

line 1:     call g:NERDTreeBookmark.CacheBookmarks(1)
calling function nerdtree#postSourceActions[1]..82(1)

line 1:     if filereadable(g:NERDTreeBookmarksFile)
line 2:         let g:NERDTreeBookmarks = []
line 3:         let g:NERDTreeInvalidBookmarks = []
line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)
line 5:         let invalidBookmarksFound = 0
line 6:         for i in bookmarkStrings
line 7: 
line 8:             "ignore blank lines
line 9:             if i != ''
line 10: 
line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')
line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')
line 13:                 let path = fnamemodify(path, ':p')
line 14: 
line 15:                 try
line 16:                     let bookmark = s:Bookmark.New(name, g:NERDTreePath.New(path))
line 17:                     call add(g:NERDTreeBookmarks, bookmark)
line 18:                 catch /^NERDTree.InvalidArgumentsError/
line 19:                     call add(g:NERDTreeInvalidBookmarks, i)
line 20:                     let invalidBookmarksFound += 1
line 21:                 endtry
line 22:             endif
line 23:         endfor
line 24:         if invalidBookmarksFound
line 25:             call s:Bookmark.Write()
line 26:             if !a:silent
line 27:                 call nerdtree#echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")
line 28:             endif
line 29:         endif
line 30:         if g:NERDTreeBookmarksSort ==# 1
line 31:             call s:Bookmark.Sort()
line 32:         endif
line 33:     endif
function nerdtree#postSourceActions[1]..82 returning #0

continuing in function nerdtree#postSourceActions

line 2:     call nerdtree#ui_glue#createDefaultBindings()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings()

line 1:     let s = '<SNR>' . s:SID() . '_'
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>32_SID()

line 1:     if !exists("s:sid")
line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
line 3:     endif
line 4:     return s:sid
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[1]..<SNR>32_SID returning '32'

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 2: 
line 3:     call NERDTreeAddKeyMap({ 'key': '<MiddleRelease>', 'scope': "all", 'callback': s."handleMiddleMouse" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap({'key': '<MiddleRelease>', 'scope': 'a...callback': '<SNR>32_handleMiddleMouse'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74({'key': '<MiddleRelease>', 'scope': 'a...callback': '<SNR>32_handleMiddleMouse'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[4]..68('<MiddleRelease>', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning []

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...MiddleMouse', 'key': '<MiddleRelease>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('<MiddleRelease>', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning []

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning []

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[3]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 4:     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>32_handleLeftClick'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74({'key': '<LeftRelease>', 'scope': 'all', 'callback': '<SNR>32_handleLeftClick'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[4]..68('<LeftRelease>', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...iddleMouse', 'key': '<MiddleRelease>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ndleLeftClick', 'key': '<LeftRelease>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('<LeftRelease>', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...iddleMouse', 'key': '<MiddleRelease>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...iddleMouse', 'key': '<MiddleRelease>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[4]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 5:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>32_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74({'key': '<2-LeftMouse>', 'scope': 'Dir... 'callback': '<SNR>32_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[4]..68('<2-LeftMouse>', 'DirNode')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...dleLeftClick', 'key': '<LeftRelease>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...tivateDirNode', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('<2-LeftMouse>', 'DirNode')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...dleLeftClick', 'key': '<LeftRelease>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...dleLeftClick', 'key': '<LeftRelease>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[5]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 6:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>32_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74({'key': '<2-LeftMouse>', 'scope': 'Fil...'callback': '<SNR>32_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[4]..68('<2-LeftMouse>', 'FileNode')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...ivateDirNode', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ivateFileNode', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('<2-LeftMouse>', 'FileNode')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...ivateDirNode', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...ivateDirNode', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[6]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 7:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>32_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74({'key': '<2-LeftMouse>', 'scope': 'Boo...'callback': '<SNR>32_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[4]..68('<2-LeftMouse>', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...vateFileNode', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ivateBookmark', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('<2-LeftMouse>', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...vateFileNode', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...vateFileNode', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[7]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 8:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>32_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74({'key': '<2-LeftMouse>', 'scope': 'all', 'callback': '<SNR>32_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[4]..68('<2-LeftMouse>', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...vateBookmark', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...2_activateAll', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('<2-LeftMouse>', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...vateBookmark', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...vateBookmark', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[8]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 9: 
line 10: 
line 11:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>32_activateDirNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74({'key': 'o', 'scope': 'DirNode', 'callback': '<SNR>32_activateDirNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[4]..68('o', 'DirNode')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu..._activateAll', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun... '<SNR>32_activateDirNode', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('o', 'DirNode')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu..._activateAll', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu..._activateAll', 'key': '<2-LeftMouse>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[11]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 12:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>32_activateFileNode'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74({'key': 'o', 'scope': 'FileNode', 'callback': '<SNR>32_activateFileNode'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[4]..68('o', 'FileNode')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_activateDirNode', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...'<SNR>32_activateFileNode', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('o', 'FileNode')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_activateDirNode', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_activateDirNode', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[12]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 13:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>32_activateBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74({'key': 'o', 'scope': 'Bookmark', 'callback': '<SNR>32_activateBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[4]..68('o', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_activateFileNode', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...'<SNR>32_activateBookmark', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('o', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_activateFileNode', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_activateFileNode', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[13]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 14:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap({'key': 'o', 'scope': 'all', 'callback': '<SNR>32_activateAll'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74({'key': 'o', 'scope': 'all', 'callback': '<SNR>32_activateAll'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[4]..68('o', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_activateBookmark', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ck': '<SNR>32_activateAll', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('o', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_activateBookmark', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_activateBookmark', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[14]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 15: 
line 16:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap({'key': 'i', 'scope': 'Node', 'callback': '<SNR>32_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74({'key': 'i', 'scope': 'Node', 'callback': '<SNR>32_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[4]..68('i', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_activateAll', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ack': '<SNR>32_openHSplit', 'key': 'i'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('i', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_activateAll', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_activateAll', 'key': 'o'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[16]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 17:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap({'key': 's', 'scope': 'Node', 'callback': '<SNR>32_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74({'key': 's', 'scope': 'Node', 'callback': '<SNR>32_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[4]..68('s', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openHSplit', 'key': 'i'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ack': '<SNR>32_openVSplit', 'key': 's'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('s', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openHSplit', 'key': 'i'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openHSplit', 'key': 'i'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[17]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 18: 
line 19:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Bookmark", 'callback': s."openHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap({'key': 'i', 'scope': 'Bookmark', 'callback': '<SNR>32_openHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74({'key': 'i', 'scope': 'Bookmark', 'callback': '<SNR>32_openHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[4]..68('i', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openVSplit', 'key': 's'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ack': '<SNR>32_openHSplit', 'key': 'i'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('i', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openVSplit', 'key': 's'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openVSplit', 'key': 's'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[19]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 20:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Bookmark", 'callback': s."openVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap({'key': 's', 'scope': 'Bookmark', 'callback': '<SNR>32_openVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74({'key': 's', 'scope': 'Bookmark', 'callback': '<SNR>32_openVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[4]..68('s', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openHSplit', 'key': 'i'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ack': '<SNR>32_openVSplit', 'key': 's'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('s', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openHSplit', 'key': 'i'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openHSplit', 'key': 'i'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[20]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 21: 
line 22:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap({'key': 'go', 'scope': 'Node', 'callback': '<SNR>32_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74({'key': 'go', 'scope': 'Node', 'callback': '<SNR>32_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[4]..68('go', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openVSplit', 'key': 's'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...NR>32_previewNodeCurrent', 'key': 'go'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('go', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openVSplit', 'key': 's'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_openVSplit', 'key': 's'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[22]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 23:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>32_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74({'key': 'gs', 'scope': 'Node', 'callback': '<SNR>32_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[4]..68('gs', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_previewNodeCurrent', 'key': 'go'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...SNR>32_previewNodeVSplit', 'key': 'gs'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('gs', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_previewNodeCurrent', 'key': 'go'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_previewNodeCurrent', 'key': 'go'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[23]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 24:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>32_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74({'key': 'gi', 'scope': 'Node', 'callback': '<SNR>32_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[4]..68('gi', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeVSplit', 'key': 'gs'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...SNR>32_previewNodeHSplit', 'key': 'gi'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('gi', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeVSplit', 'key': 'gs'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeVSplit', 'key': 'gs'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[24]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 25: 
line 26:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Bookmark", 'callback': s."previewNodeCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>32_previewNodeCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74({'key': 'go', 'scope': 'Bookmark', 'callback': '<SNR>32_previewNodeCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[4]..68('go', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeHSplit', 'key': 'gi'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...NR>32_previewNodeCurrent', 'key': 'go'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('go', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeHSplit', 'key': 'gi'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeHSplit', 'key': 'gi'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[26]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 27:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Bookmark", 'callback': s."previewNodeVSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap({'key': 'gs', 'scope': 'Bookmark', 'callback': '<SNR>32_previewNodeVSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74({'key': 'gs', 'scope': 'Bookmark', 'callback': '<SNR>32_previewNodeVSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[4]..68('gs', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_previewNodeCurrent', 'key': 'go'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...SNR>32_previewNodeVSplit', 'key': 'gs'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('gs', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_previewNodeCurrent', 'key': 'go'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_previewNodeCurrent', 'key': 'go'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[27]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 28:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Bookmark", 'callback': s."previewNodeHSplit" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap({'key': 'gi', 'scope': 'Bookmark', 'callback': '<SNR>32_previewNodeHSplit'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74({'key': 'gi', 'scope': 'Bookmark', 'callback': '<SNR>32_previewNodeHSplit'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[4]..68('gi', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeVSplit', 'key': 'gs'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...SNR>32_previewNodeHSplit', 'key': 'gi'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('gi', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeVSplit', 'key': 'gs'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeVSplit', 'key': 'gs'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[28]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 29: 
line 30:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>32_openNodeRecursively'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74({'key': 'O', 'scope': 'DirNode', 'callback': '<SNR>32_openNodeRecursively'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[4]..68('O', 'DirNode')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeHSplit', 'key': 'gi'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...NR>32_openNodeRecursively', 'key': 'O'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('O', 'DirNode')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeHSplit', 'key': 'gi'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_previewNodeHSplit', 'key': 'gi'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[30]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 31: 
line 32:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': "all", 'callback': s."upDirCurrentRootClosed" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap({'key': 'u', 'scope': 'all', 'callback': '<SNR>32_upDirCurrentRootClosed'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74({'key': 'u', 'scope': 'all', 'callback': '<SNR>32_upDirCurrentRootClosed'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[4]..68('u', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_openNodeRecursively', 'key': 'O'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...32_upDirCurrentRootClosed', 'key': 'u'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('u', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_openNodeRecursively', 'key': 'O'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_openNodeRecursively', 'key': 'O'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[32]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 33:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': "all", 'callback': s."upDirCurrentRootOpen" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap({'key': 'U', 'scope': 'all', 'callback': '<SNR>32_upDirCurrentRootOpen'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74({'key': 'U', 'scope': 'all', 'callback': '<SNR>32_upDirCurrentRootOpen'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[4]..68('U', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...2_upDirCurrentRootClosed', 'key': 'u'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...R>32_upDirCurrentRootOpen', 'key': 'U'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('U', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...2_upDirCurrentRootClosed', 'key': 'u'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...2_upDirCurrentRootClosed', 'key': 'u'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[33]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 34:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': "Node", 'callback': s."chRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap({'key': 'C', 'scope': 'Node', 'callback': '<SNR>32_chRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74({'key': 'C', 'scope': 'Node', 'callback': '<SNR>32_chRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[4]..68('C', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...>32_upDirCurrentRootOpen', 'key': 'U'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...allback': '<SNR>32_chRoot', 'key': 'C'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('C', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...>32_upDirCurrentRootOpen', 'key': 'U'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...>32_upDirCurrentRootOpen', 'key': 'U'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[34]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 35: 
line 36:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>32_chCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74({'key': 'cd', 'scope': 'Node', 'callback': '<SNR>32_chCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[4]..68('cd', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...llback': '<SNR>32_chRoot', 'key': 'C'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...allback': '<SNR>32_chCwd', 'key': 'cd'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('cd', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...llback': '<SNR>32_chRoot', 'key': 'C'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...llback': '<SNR>32_chRoot', 'key': 'C'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[36]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 37: 
line 38:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap({'key': 'q', 'scope': 'all', 'callback': '<SNR>32_closeTreeWindow'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74({'key': 'q', 'scope': 'all', 'callback': '<SNR>32_closeTreeWindow'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[4]..68('q', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...llback': '<SNR>32_chCwd', 'key': 'cd'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun... '<SNR>32_closeTreeWindow', 'key': 'q'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('q', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...llback': '<SNR>32_chCwd', 'key': 'cd'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...llback': '<SNR>32_chCwd', 'key': 'cd'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[38]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 39: 
line 40:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCWD, 'scope': "all", 'callback': "nerdtree#ui_glue#chRootCwd" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74({'key': 'CD', 'scope': 'all', 'callback': 'nerdtree#ui_glue#chRootCwd'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[4]..68('CD', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_closeTreeWindow', 'key': 'q'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...rdtree#ui_glue#chRootCwd', 'key': 'CD'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('CD', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_closeTreeWindow', 'key': 'q'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_closeTreeWindow', 'key': 'q'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[40]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 41: 
line 42:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap({'key': 'R', 'scope': 'all', 'callback': '<SNR>32_refreshRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74({'key': 'R', 'scope': 'all', 'callback': '<SNR>32_refreshRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[4]..68('R', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...dtree#ui_glue#chRootCwd', 'key': 'CD'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ck': '<SNR>32_refreshRoot', 'key': 'R'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('R', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...dtree#ui_glue#chRootCwd', 'key': 'CD'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...dtree#ui_glue#chRootCwd', 'key': 'CD'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[42]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 43:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap({'key': 'r', 'scope': 'Node', 'callback': '<SNR>32_refreshCurrent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74({'key': 'r', 'scope': 'Node', 'callback': '<SNR>32_refreshCurrent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[4]..68('r', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_refreshRoot', 'key': 'R'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...: '<SNR>32_refreshCurrent', 'key': 'r'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('r', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_refreshRoot', 'key': 'R'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_refreshRoot', 'key': 'R'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[43]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 44: 
line 45:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap({'key': '?', 'scope': 'all', 'callback': '<SNR>32_displayHelp'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74({'key': '?', 'scope': 'all', 'callback': '<SNR>32_displayHelp'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[4]..68('?', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu... '<SNR>32_refreshCurrent', 'key': 'r'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ck': '<SNR>32_displayHelp', 'key': '?'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('?', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu... '<SNR>32_refreshCurrent', 'key': 'r'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu... '<SNR>32_refreshCurrent', 'key': 'r'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[45]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 46:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap({'key': 'A', 'scope': 'all', 'callback': '<SNR>32_toggleZoom'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74({'key': 'A', 'scope': 'all', 'callback': '<SNR>32_toggleZoom'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[4]..68('A', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_displayHelp', 'key': '?'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ack': '<SNR>32_toggleZoom', 'key': 'A'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('A', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_displayHelp', 'key': '?'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...k': '<SNR>32_displayHelp', 'key': '?'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[46]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 47:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap({'key': 'I', 'scope': 'all', 'callback': '<SNR>32_toggleShowHidden'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74({'key': 'I', 'scope': 'all', 'callback': '<SNR>32_toggleShowHidden'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[4]..68('I', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_toggleZoom', 'key': 'A'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...'<SNR>32_toggleShowHidden', 'key': 'I'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('I', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_toggleZoom', 'key': 'A'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_toggleZoom', 'key': 'A'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[47]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 48:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap({'key': 'f', 'scope': 'all', 'callback': '<SNR>32_toggleIgnoreFilter'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74({'key': 'f', 'scope': 'all', 'callback': '<SNR>32_toggleIgnoreFilter'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[4]..68('f', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_toggleShowHidden', 'key': 'I'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...SNR>32_toggleIgnoreFilter', 'key': 'f'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('f', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_toggleShowHidden', 'key': 'I'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_toggleShowHidden', 'key': 'I'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[48]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 49:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap({'key': 'F', 'scope': 'all', 'callback': '<SNR>32_toggleShowFiles'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74({'key': 'F', 'scope': 'all', 'callback': '<SNR>32_toggleShowFiles'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[4]..68('F', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_toggleIgnoreFilter', 'key': 'f'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun... '<SNR>32_toggleShowFiles', 'key': 'F'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('F', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_toggleIgnoreFilter', 'key': 'f'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_toggleIgnoreFilter', 'key': 'f'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[49]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 50:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap({'key': 'B', 'scope': 'all', 'callback': '<SNR>32_toggleShowBookmarks'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74({'key': 'B', 'scope': 'all', 'callback': '<SNR>32_toggleShowBookmarks'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[4]..68('B', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_toggleShowFiles', 'key': 'F'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...NR>32_toggleShowBookmarks', 'key': 'B'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('B', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_toggleShowFiles', 'key': 'F'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_toggleShowFiles', 'key': 'F'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[50]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 51: 
line 52:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap({'key': 'x', 'scope': 'Node', 'callback': '<SNR>32_closeCurrentDir'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74({'key': 'x', 'scope': 'Node', 'callback': '<SNR>32_closeCurrentDir'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[4]..68('x', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_toggleShowBookmarks', 'key': 'B'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun... '<SNR>32_closeCurrentDir', 'key': 'x'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('x', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_toggleShowBookmarks', 'key': 'B'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...R>32_toggleShowBookmarks', 'key': 'B'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[52]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 53:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>32_closeChildren'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74({'key': 'X', 'scope': 'DirNode', 'callback': '<SNR>32_closeChildren'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[4]..68('X', 'DirNode')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_closeCurrentDir', 'key': 'x'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...': '<SNR>32_closeChildren', 'key': 'X'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('X', 'DirNode')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_closeCurrentDir', 'key': 'x'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_closeCurrentDir', 'key': 'x'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[53]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 54: 
line 55:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap({'key': 'm', 'scope': 'Node', 'callback': '<SNR>32_showMenu'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74({'key': 'm', 'scope': 'Node', 'callback': '<SNR>32_showMenu'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[4]..68('m', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...: '<SNR>32_closeChildren', 'key': 'X'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...lback': '<SNR>32_showMenu', 'key': 'm'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('m', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...: '<SNR>32_closeChildren', 'key': 'X'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...: '<SNR>32_closeChildren', 'key': 'X'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[55]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 56: 
line 57:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap({'key': 'p', 'scope': 'Node', 'callback': '<SNR>32_jumpToParent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74({'key': 'p', 'scope': 'Node', 'callback': '<SNR>32_jumpToParent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[4]..68('p', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...back': '<SNR>32_showMenu', 'key': 'm'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...k': '<SNR>32_jumpToParent', 'key': 'p'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('p', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...back': '<SNR>32_showMenu', 'key': 'm'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...back': '<SNR>32_showMenu', 'key': 'm'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[57]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 58:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap({'key': 'K', 'scope': 'Node', 'callback': '<SNR>32_jumpToFirstChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74({'key': 'K', 'scope': 'Node', 'callback': '<SNR>32_jumpToFirstChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[4]..68('K', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_jumpToParent', 'key': 'p'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...'<SNR>32_jumpToFirstChild', 'key': 'K'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('K', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_jumpToParent', 'key': 'p'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_jumpToParent', 'key': 'p'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[58]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 59:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap({'key': 'J', 'scope': 'Node', 'callback': '<SNR>32_jumpToLastChild'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74({'key': 'J', 'scope': 'Node', 'callback': '<SNR>32_jumpToLastChild'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[4]..68('J', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_jumpToFirstChild', 'key': 'K'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun... '<SNR>32_jumpToLastChild', 'key': 'J'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('J', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_jumpToFirstChild', 'key': 'K'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...<SNR>32_jumpToFirstChild', 'key': 'K'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[59]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 60:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap({'key': 'P', 'scope': 'all', 'callback': '<SNR>32_jumpToRoot'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74({'key': 'P', 'scope': 'all', 'callback': '<SNR>32_jumpToRoot'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[4]..68('P', 'all')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_jumpToLastChild', 'key': 'J'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...ack': '<SNR>32_jumpToRoot', 'key': 'P'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('P', 'all')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_jumpToLastChild', 'key': 'J'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...'<SNR>32_jumpToLastChild', 'key': 'J'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[60]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 61:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>32_jumpToNextSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74({'key': '<C-j>', 'scope': 'Node', 'callback': '<SNR>32_jumpToNextSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[4]..68('<C-j>', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_jumpToRoot', 'key': 'P'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...>32_jumpToNextSibling', 'key': '<C-j>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('<C-j>', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_jumpToRoot', 'key': 'P'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...ck': '<SNR>32_jumpToRoot', 'key': 'P'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[61]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 62:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>32_jumpToPrevSibling'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74({'key': '<C-k>', 'scope': 'Node', 'callback': '<SNR>32_jumpToPrevSibling'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[4]..68('<C-k>', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...32_jumpToNextSibling', 'key': '<C-j>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...>32_jumpToPrevSibling', 'key': '<C-k>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('<C-k>', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...32_jumpToNextSibling', 'key': '<C-j>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...32_jumpToNextSibling', 'key': '<C-j>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[62]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 63: 
line 64:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Node", 'callback': s."openInNewTab" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap({'key': 't', 'scope': 'Node', 'callback': '<SNR>32_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74({'key': 't', 'scope': 'Node', 'callback': '<SNR>32_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[4]..68('t', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...32_jumpToPrevSibling', 'key': '<C-k>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...k': '<SNR>32_openInNewTab', 'key': 't'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('t', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...32_jumpToPrevSibling', 'key': '<C-k>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...32_jumpToPrevSibling', 'key': '<C-k>'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[64]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 65:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Node", 'callback': s."openInNewTabSilent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap({'key': 'T', 'scope': 'Node', 'callback': '<SNR>32_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74({'key': 'T', 'scope': 'Node', 'callback': '<SNR>32_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[4]..68('T', 'Node')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openInNewTab', 'key': 't'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...SNR>32_openInNewTabSilent', 'key': 'T'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('T', 'Node')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openInNewTab', 'key': 't'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openInNewTab', 'key': 't'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[65]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 66:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Bookmark", 'callback': s."openInNewTab" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>32_openInNewTab'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74({'key': 't', 'scope': 'Bookmark', 'callback': '<SNR>32_openInNewTab'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[4]..68('t', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_openInNewTabSilent', 'key': 'T'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...k': '<SNR>32_openInNewTab', 'key': 't'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('t', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_openInNewTabSilent', 'key': 'T'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_openInNewTabSilent', 'key': 'T'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[66]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 67:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Bookmark", 'callback': s."openInNewTabSilent" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>32_openInNewTabSilent'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74({'key': 'T', 'scope': 'Bookmark', 'callback': '<SNR>32_openInNewTabSilent'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[4]..68('T', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openInNewTab', 'key': 't'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...SNR>32_openInNewTabSilent', 'key': 'T'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('T', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openInNewTab', 'key': 't'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openInNewTab', 'key': 't'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[67]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 68: 
line 69:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>32_openExplorer'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74({'key': 'e', 'scope': 'DirNode', 'callback': '<SNR>32_openExplorer'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[4]..68('e', 'DirNode')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_openInNewTabSilent', 'key': 'T'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...k': '<SNR>32_openExplorer', 'key': 'e'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('e', 'DirNode')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_openInNewTabSilent', 'key': 'T'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...NR>32_openInNewTabSilent', 'key': 'T'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[69]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

line 70: 
line 71:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>32_deleteBookmark'})

line 1:     call g:NERDTreeKeyMap.Create(a:options)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74({'key': 'D', 'scope': 'Bookmark', 'callback': '<SNR>32_deleteBookmark'})

line 1:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))
line 2: 
line 3:     "dont override other mappings unless the 'override' option is given
line 4:     if get(opts, 'override', 0) == 0 && !empty(s:KeyMap.FindFor(opts['key'], opts['scope']))
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[4]..68('D', 'Bookmark')

line 1:     for i in s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[4]..68[1]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openExplorer', 'key': 'e'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[4]..68

line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 1:     for i in s:KeyMap.All()
line 2:          if i.key ==# a:key && i.scope ==# a:scope
line 3:             return i
line 4:         endif
line 5:     endfor
line 6:     return {}
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[4]..68 returning {}

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74

line 5:         return
line 6:     end
line 7: 
line 8:     let newKeyMap = copy(self)
line 9:     let newKeyMap.key = opts['key']
line 10:     let newKeyMap.quickhelpText = opts['quickhelpText']
line 11:     let newKeyMap.callback = opts['callback']
line 12:     let newKeyMap.scope = opts['scope']
line 13: 
line 14:     call s:KeyMap.Add(newKeyMap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75({'All': function('67'), 'BindAll': fun...: '<SNR>32_deleteBookmark', 'key': 'D'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71('D', 'Bookmark')

line 1:     let maps = s:KeyMap.All()
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71[1]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openExplorer', 'key': 'e'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71

line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
line 2:     for i in range(len(maps))
line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope
line 4:             return remove(maps, i)
line 5:         endif
line 6:     endfor
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75[1]..71 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75

line 2:     call add(s:KeyMap.All(), a:keymap)
calling function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67()

line 1:     if !exists("s:keyMaps")
line 2:         let s:keyMaps = []
line 3:     endif
line 4:     return s:keyMaps
function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75[2]..67 returning [{'All': function('67'), 'BindAll': fu...': '<SNR>32_openExplorer', 'key': 'e'}]

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74[14]..75 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap[1]..74 returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings[71]..NERDTreeAddKeyMap returning #0

continuing in function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings

function nerdtree#postSourceActions[2]..nerdtree#ui_glue#createDefaultBindings returning #0

continuing in function nerdtree#postSourceActions

line 3: 
line 4:     "load all nerdtree plugins
line 5:     runtime! nerdtree_plugin/**/*.vim
Searching for "nerdtree_plugin/**/*.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim"
line 1: " ============================================================================
line 2: " File:        exec_menuitem.vim
line 3: " Description: plugin for NERD Tree that provides an execute file menu item
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists("g:loaded_nerdtree_exec_menuitem")
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_exec_menuitem = 1
line 16: 
line 21: call NERDTreeAddMenuItem({ 'text': '(!)Execute file', 'shortcut': '!', 'callback': 'NERDTreeExecFile', 'isActiveCallback': 'NERDTreeExecFileActive' })
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeExecFile', 'shor...iveCallback': 'NERDTreeExecFileActive'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning []

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...reeExecFile', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim

line 22: 
line 23: function! NERDTreeExecFileActive()
line 27: 
line 28: function! NERDTreeExecFile()
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim
continuing in function nerdtree#postSourceActions
chdir(/Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin)
fchdir() to previous dir
line 5: sourcing "/Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim"
line 1: " ============================================================================
line 2: " File:        fs_menu.vim
line 3: " Description: plugin for the NERD Tree that provides a file system menu
line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
line 5: " License:     This program is free software. It comes without any warranty,
line 6: "              to the extent permitted by applicable law. You can redistribute
line 7: "              it and/or modify it under the terms of the Do What The Fuck You
line 8: "              Want To Public License, Version 2, as published by Sam Hocevar.
line 9: "              See http://sam.zoy.org/wtfpl/COPYING for more details.
line 10: "
line 11: " ============================================================================
line 12: if exists("g:loaded_nerdtree_fs_menu")
line 13:     finish
line 14: endif
line 15: let g:loaded_nerdtree_fs_menu = 1
line 16: 
line 17: "Automatically delete the buffer after deleting or renaming a file
line 18: if !exists("g:NERDTreeAutoDeleteBuffer")
line 19:     let g:NERDTreeAutoDeleteBuffer = 0
line 20: endif
line 21: 
line 22: call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeAddNode', 'shortcut': 'a', 'text': '(a)dd a childnode'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning [{'All': function('58'), 'isActiveCall...eeExecFile', 'Create': function('60')}]

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...TreeAddNode', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 23: call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeMoveNode', 'shor...'m', 'text': '(m)ove the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning [{'All': function('58'), 'isActiveCall...reeAddNode', 'Create': function('60')}]

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...reeMoveNode', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 24: call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeDeleteNode', 'sh...', 'text': '(d)elete the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning [{'All': function('58'), 'isActiveCall...eeMoveNode', 'Create': function('60')}]

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...eDeleteNode', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 25: 
line 26: if has("gui_mac") || has("gui_macvim") || has("mac")
line 27:     call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeRevealInFinder',... '(r)eveal in Finder the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeRevealInFinder',... '(r)eveal in Finder the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning [{'All': function('58'), 'isActiveCall...DeleteNode', 'Create': function('60')}]

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...ealInFinder', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 28:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeExecuteFile', 's...n the current node with system editor'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeExecuteFile', 's...n the current node with system editor'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning [{'All': function('58'), 'isActiveCall...alInFinder', 'Create': function('60')}]

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...ExecuteFile', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 29:     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeQuickLook', 'sho...'text': '(q)uicklook the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeQuickLook', 'sho...'text': '(q)uicklook the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning [{'All': function('58'), 'isActiveCall...xecuteFile', 'Create': function('60')}]

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...eeQuickLook', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 30: endif
line 31: 
line 32: if g:NERDTreePath.CopyingSupported()
calling function 8()

line 1:     return exists('g:NERDTreeCopyCmd') || (exists('g:NERDTreeCopyDirCmd') && exists('g:NERDTreeCopyFileCmd'))
function 8 returning #1

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 33:     call NERDTreeAddMenuItem({'text': '(c)opy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeCopyNode', 'shor...'c', 'text': '(c)opy the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning [{'All': function('58'), 'isActiveCall...eQuickLook', 'Create': function('60')}]

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...reeCopyNode', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 34: endif
line 35: 
line 36: if has("unix") || has("osx")
line 37:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNode'})
calling function NERDTreeAddMenuItem({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     call g:NERDTreeMenuItem.Create(a:options)
calling function NERDTreeAddMenuItem[1]..60({'callback': 'NERDTreeListNode', 'shor...'l', 'text': '(l)ist the current node'})

line 1:     let newMenuItem = copy(self)
line 2: 
line 3:     let newMenuItem.text = a:options['text']
line 4:     let newMenuItem.shortcut = a:options['shortcut']
line 5:     let newMenuItem.children = []
line 6: 
line 7:     let newMenuItem.isActiveCallback = -1
line 8:     if has_key(a:options, 'isActiveCallback')
line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback']
line 10:     endif
line 11: 
line 12:     let newMenuItem.callback = -1
line 13:     if has_key(a:options, 'callback')
line 14:         let newMenuItem.callback = a:options['callback']
line 15:     endif
line 16: 
line 17:     if has_key(a:options, 'parent')
line 18:         call add(a:options['parent'].children, newMenuItem)
line 19:     else
line 20:         call add(s:MenuItem.All(), newMenuItem)
calling function NERDTreeAddMenuItem[1]..60[20]..58()

line 1:     if !exists("s:menuItems")
line 2:         let s:menuItems = []
line 3:     endif
line 4:     return s:menuItems
function NERDTreeAddMenuItem[1]..60[20]..58 returning [{'All': function('58'), 'isActiveCall...eeCopyNode', 'Create': function('60')}]

continuing in function NERDTreeAddMenuItem[1]..60

line 21:     endif
line 22: 
line 23:     return newMenuItem
function NERDTreeAddMenuItem[1]..60 returning {'All': function('58'), 'isActiveCallb...reeListNode', 'Create': function('60')}

continuing in function NERDTreeAddMenuItem

function NERDTreeAddMenuItem returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim

line 38: else
line 39:     call NERDTreeAddMenuItem({'text': '(l)ist the current node', 'shortcut': 'l', 'callback': 'NERDTreeListNodeWin32'})
line 40: endif
line 41: 
line 42: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1
line 43: "prints out the given msg and, if the user responds by pushing 'y' then the
line 44: "buffer with the given bufnum is deleted
line 45: "
line 46: "Args:
line 47: "bufnum: the buffer that may be deleted
line 48: "msg: a message that will be echoed to the user asking them if they wish to
line 49: "     del the buffer
line 50: function! s:promptToDelBuffer(bufnum, msg)
line 65: 
line 66: "FUNCTION: s:promptToRenameBuffer(bufnum, msg){{{1
line 67: "prints out the given msg and, if the user responds by pushing 'y' then the
line 68: "buffer with the given bufnum is replaced with a new one
line 69: "
line 70: "Args:
line 71: "bufnum: the buffer that may be deleted
line 72: "msg: a message that will be echoed to the user asking them if they wish to
line 73: "     del the buffer
line 74: function! s:promptToRenameBuffer(bufnum, msg, newFileName)
line 92: "FUNCTION: NERDTreeAddNode(){{{1
line 93: function! NERDTreeAddNode()
line 123: 
line 124: "FUNCTION: NERDTreeMoveNode(){{{1
line 125: function! NERDTreeMoveNode()
line 157: 
line 158: " FUNCTION: NERDTreeDeleteNode() {{{1
line 159: function! NERDTreeDeleteNode()
line 201: 
line 202: " FUNCTION: NERDTreeListNode() {{{1
line 203: function! NERDTreeListNode()
line 212: 
line 213: " FUNCTION: NERDTreeListNodeWin32() {{{1
line 214: function! NERDTreeListNodeWin32()
line 224: 
line 225: " FUNCTION: NERDTreeCopyNode() {{{1
line 226: function! NERDTreeCopyNode()
line 263: 
line 264: " FUNCTION: NERDTreeQuickLook() {{{1
line 265: function! NERDTreeQuickLook()
line 271: 
line 272: " FUNCTION: NERDTreeRevealInFinder() {{{1
line 273: function! NERDTreeRevealInFinder()
line 279: 
line 280: " FUNCTION: NERDTreeExecuteFile() {{{1
line 281: function! NERDTreeExecuteFile()
line 287: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim
continuing in function nerdtree#postSourceActions
Searching for "/Users/jmoussa/.vim/bundle/syntastic/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/tlib_vim/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snippets/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/youcompleteme/nerdtree_plugin/**/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/nerdtree_plugin/**/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/nerdtree_plugin/**/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/after/nerdtree_plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/after/nerdtree_plugin/**/*.vim"
Searching for "/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/nerdtree_plugin/**/*.vim"
function nerdtree#postSourceActions returning #0

continuing in /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim

line 217: 
line 218: "reset &cpo back to users setting
line 219: let &cpo = s:old_cpo
line 220: 
line 221: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/nerdtree/plugin/NERD_tree.vim
Searching for "/Users/jmoussa/.vim/bundle/syntastic/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim"
line 1: if exists('g:loaded_syntastic_notifier_autoloclist') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/balloons.vim"
line 1: if exists('g:loaded_syntastic_notifier_balloons') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/balloons.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/checker.vim"
line 1: if exists('g:loaded_syntastic_checker') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/checker.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/cursor.vim"
line 1: if exists('g:loaded_syntastic_notifier_cursor') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/cursor.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim"
line 1: if exists('g:loaded_syntastic_notifier_highlighting') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/loclist.vim"
line 1: if exists('g:loaded_syntastic_loclist') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/loclist.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/modemap.vim"
line 1: if exists('g:loaded_syntastic_modemap') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/modemap.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim"
line 1: if exists('g:loaded_syntastic_notifiers') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/registry.vim"
line 1: if exists('g:loaded_syntastic_registry') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/registry.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/signs.vim"
line 1: if exists('g:loaded_syntastic_notifier_signs') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/signs.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim"
line 1: "============================================================================
line 2: "File:        syntastic.vim
line 3: "Description: Vim plugin for on the fly syntax checking.
line 4: "License:     This program is free software. It comes without any warranty,
line 5: "             to the extent permitted by applicable law. You can redistribute
line 6: "             it and/or modify it under the terms of the Do What The Fuck You
line 7: "             Want To Public License, Version 2, as published by Sam Hocevar.
line 8: "             See http://sam.zoy.org/wtfpl/COPYING for more details.
line 9: "
line 10: "============================================================================
line 11: 
line 12: if exists('g:loaded_syntastic_plugin') || &compatible
line 13:     finish
line 14: endif
line 15: let g:loaded_syntastic_plugin = 1
line 16: 
line 17: if has('reltime')
line 18:     let g:_SYNTASTIC_START = reltime()
line 19:     lockvar! g:_SYNTASTIC_START
line 20: endif
line 21: 
line 22: let g:_SYNTASTIC_VERSION = '3.8.0-10'
line 23: lockvar g:_SYNTASTIC_VERSION
line 24: 
line 25: " Sanity checks {{{1
line 26: 
line 27: if v:version < 700 || (v:version == 700 && !has('patch175'))
line 28:     call syntastic#log#error('need Vim version 7.0.175 or later')
line 29:     finish
line 30: endif
line 31: 
line 40: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'user_commands' ]
line 41:     if !has(s:feature)
line 42:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)
line 43:         finish
line 44:     endif
line 45: endfor
line 40: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'user_commands' ]
line 41:     if !has(s:feature)
line 42:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)
line 43:         finish
line 44:     endif
line 45: endfor
line 40: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'user_commands' ]
line 41:     if !has(s:feature)
line 42:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)
line 43:         finish
line 44:     endif
line 45: endfor
line 40: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'user_commands' ]
line 41:     if !has(s:feature)
line 42:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)
line 43:         finish
line 44:     endif
line 45: endfor
line 40: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'user_commands' ]
line 41:     if !has(s:feature)
line 42:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)
line 43:         finish
line 44:     endif
line 45: endfor
line 40: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'user_commands' ]
line 41:     if !has(s:feature)
line 42:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)
line 43:         finish
line 44:     endif
line 45: endfor
line 40: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'user_commands' ]
line 41:     if !has(s:feature)
line 42:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)
line 43:         finish
line 44:     endif
line 45: endfor
line 40: for s:feature in [ 'autocmd', 'eval', 'file_in_path', 'modify_fname', 'quickfix', 'reltime', 'user_commands' ]
line 41:     if !has(s:feature)
line 42:         call syntastic#log#error('need Vim compiled with feature ' . s:feature)
line 43:         finish
line 44:     endif
line 45: endfor
line 46: 
line 47: let s:_running_windows = syntastic#util#isRunningWindows()
Searching for "autoload/syntastic/util.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/autoload/syntastic/util.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/autoload/syntastic/util.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/syntastic/util.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/autoload/syntastic/util.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/autoload/syntastic/util.vim"
Searching for "/Users/jmoussa/.vim/bundle/syntastic/autoload/syntastic/util.vim"
chdir(/Users/jmoussa/.vim/bundle/syntastic/autoload/syntastic)
fchdir() to previous dir
line 47: sourcing "/Users/jmoussa/.vim/bundle/syntastic/autoload/syntastic/util.vim"
line 1: if exists('g:loaded_syntastic_util_autoload') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_util_autoload = 1
line 5: 
line 6: let s:save_cpo = &cpo
line 7: set cpo&vim
line 8: 
line 9: " Public functions {{{1
line 10: 
line 11: function! syntastic#util#isRunningWindows() abort " {{{2
line 14: 
line 15: function! syntastic#util#DevNull() abort " {{{2
line 21: 
line 22: " Get directory separator
line 23: function! syntastic#util#Slash() abort " {{{2
line 26: 
line 27: function! syntastic#util#CygwinPath(path) abort " {{{2
line 30: 
line 31: function! syntastic#util#system(command) abort " {{{2
line 71: 
line 72: " Create a temporary directory
line 73: function! syntastic#util#tmpdir() abort " {{{2
line 106: 
line 107: " Recursively remove a directory
line 108: function! syntastic#util#rmrf(what) abort " {{{2
line 120: 
line 121: function! syntastic#util#getbufvar(buf, name, ...) abort " {{{2
line 124: 
line 125: " Search the first 5 lines of the file for a magic number and return a map
line 126: " containing the args and the executable
line 127: "
line 128: " e.g.
line 129: "
line 130: " #!/usr/bin/perl -f -bar
line 131: "
line 132: " returns
line 133: "
line 134: " {'exe': '/usr/bin/perl', 'args': ['-f', '-bar']}
line 135: function! syntastic#util#parseShebang() abort " {{{2
line 148: 
line 149: " Get the value of a Vim variable.  Allow buffer variables to override global ones.
line 150: function! syntastic#util#bufRawVar(buf, name, ...) abort " {{{2
line 153: 
line 154: " Get the value of a syntastic variable.  Allow buffer variables to override global ones.
line 155: function! syntastic#util#bufVar(buf, name, ...) abort " {{{2
line 158: 
line 159: " Get the value of a Vim variable.  Allow local variables to override global ones.
line 160: function! syntastic#util#rawVar(name, ...) abort " {{{2
line 163: 
line 164: " Get the value of a syntastic variable.  Allow local variables to override global ones.
line 165: function! syntastic#util#var(name, ...) abort " {{{2
line 168: 
line 169: " Parse a version string.  Return an array of version components.
line 170: function! syntastic#util#parseVersion(version, ...) abort " {{{2
line 173: 
line 174: " Verify that the 'installed' version is at least the 'required' version.
line 175: "
line 176: " 'installed' and 'required' must be arrays. If they have different lengths,
line 177: " the "missing" elements will be assumed to be 0 for the purposes of checking.
line 178: "
line 179: " See http://semver.org for info about version numbers.
line 180: function! syntastic#util#versionIsAtLeast(installed, required) abort " {{{2
line 183: 
line 184: " Almost lexicographic comparison of two lists of integers. :) If lists
line 185: " have different lengths, the "missing" elements are assumed to be 0.
line 186: function! syntastic#util#compareLexi(a, b) abort " {{{2
line 197: 
line 198: function! syntastic#util#screenWidth(str, tabstop) abort " {{{2
line 207: 
line 208: " Print as much of a:msg as possible without "Press Enter" prompt appearing
line 209: function! syntastic#util#wideMsg(msg) abort " {{{2
line 231: 
line 232: " Check whether a buffer is loaded, listed, and not hidden
line 233: function! syntastic#util#bufIsActive(buffer) abort " {{{2
line 250: 
line 251: " Start in directory a:where and walk up the parent folders until it finds a
line 252: " file named a:what; return path to that file
line 253: function! syntastic#util#findFileInParent(what, where) abort " {{{2
line 260: 
line 261: " Start in directory a:where and walk up the parent folders until it finds a
line 262: " file matching a:what; return path to that file
line 263: function! syntastic#util#findGlobInParent(what, where) abort " {{{2
line 298: 
line 299: " Returns the buffer number of a filename
line 300: " @vimlint(EVL104, 1, l:old_shellslash)
line 301: function! syntastic#util#fname2buf(fname) abort " {{{2
line 327: " @vimlint(EVL104, 0, l:old_shellslash)
line 328: 
line 329: " Returns unique elements in a list
line 330: function! syntastic#util#unique(list) abort " {{{2
line 342: 
line 343: " A less noisy shellescape()
line 344: function! syntastic#util#shescape(string) abort " {{{2
line 347: 
line 348: " A less noisy shellescape(expand())
line 349: function! syntastic#util#shexpand(string, ...) abort " {{{2
line 352: 
line 353: " Escape arguments
line 354: function! syntastic#util#argsescape(opt) abort " {{{2
line 363: 
line 364: " Decode XML entities
line 365: function! syntastic#util#decodeXMLEntities(string) abort " {{{2
line 374: 
line 375: function! syntastic#util#redraw(full) abort " {{{2
line 382: 
line 383: function! syntastic#util#dictFilter(errors, filter) abort " {{{2
line 393: 
line 394: " Return a [seconds, fractions] list of strings, representing the
line 395: " (hopefully high resolution) time since program start
line 396: function! syntastic#util#stamp() abort " {{{2
line 399: 
line 400: function! syntastic#util#setLastTick(buf) abort " {{{2
line 403: 
line 404: let s:_wid_base = 'syntastic_' . getpid() . '_' . reltimestr(g:_SYNTASTIC_START) . '_'
line 405: let s:_wid_pool = 0
line 406: 
line 407: " Add unique IDs to windows
line 408: function! syntastic#util#setWids() abort " {{{2
line 418: 
line 419: function! syntastic#util#str2float(val) abort " {{{2
line 422: 
line 423: function! syntastic#util#float2str(val) abort " {{{2
line 426: 
line 427: " Crude printf()-like width formatter.  Handles wide characters.
line 428: function! syntastic#util#wformat(format, str) abort " {{{2
line 481: 
line 482: " }}}1
line 483: 
line 484: " Private functions {{{1
line 485: 
line 486: function! s:_translateFilter(filters) abort " {{{2
line 501: 
line 502: function! s:_translateElement(key, term) abort " {{{2
line 539: 
line 540: " strwidth() was added in Vim 7.3; if it doesn't exist, we use strlen()
line 541: " and hope for the best :)
line 542: let s:_width = function(exists('*strwidth') ? 'strwidth' : 'strlen')
line 543: lockvar s:_width
line 544: 
line 545: " @vimlint(EVL103, 1, a:flags)
line 546: function! s:_delete_dumb(what, flags) abort " {{{2
line 560: " @vimlint(EVL103, 0, a:flags)
line 561: 
line 562: " delete(dir, 'rf') was added in Vim 7.4.1107, but it didn't become usable until 7.4.1128
line 563: let s:_delete = function(v:version > 704 || (v:version == 704 && has('patch1128')) ? 'delete' : 's:_delete_dumb')
line 564: lockvar s:_delete
line 565: 
line 566: function! s:_rmrf(what) abort " {{{2
line 590: 
line 591: let s:_str2float = function(exists('*str2float') ? 'str2float' : 'str2nr')
line 592: lockvar s:_str2float
line 593: 
line 594: function! s:_float2str_smart(val) abort " {{{2
line 597: 
line 598: function! s:_float2str_dumb(val) abort " {{{2
line 601: 
line 602: let s:_float2str = function(has('float') ? 's:_float2str_smart' : 's:_float2str_dumb')
line 603: lockvar s:_float2str
line 604: 
line 605: function! s:_getbufvar_dumb(buf, name, ...) abort " {{{2
line 613: 
line 614: let s:_getbufvar = function(v:version > 703 || (v:version == 703 && has('patch831')) ? 'getbufvar' : 's:_getbufvar_dumb')
line 615: lockvar s:_getbufvar
line 616: 
line 617: " }}}1
line 618: 
line 619: let &cpo = s:save_cpo
line 620: unlet s:save_cpo
line 621: 
line 622: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/autoload/syntastic/util.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
calling function syntastic#util#isRunningWindows()

line 1:     return has('win16') || has('win32') || has('win64')
function syntastic#util#isRunningWindows returning #0

continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim

line 48: lockvar s:_running_windows
line 49: 
line 50: if !exists('g:syntastic_shell')
line 51:     let g:syntastic_shell = &shell
line 52: endif
line 53: 
line 54: if s:_running_windows
line 55:     let g:_SYNTASTIC_UNAME = 'Windows'
line 56: elseif executable('uname')
line 57:     try
line 58:         let g:_SYNTASTIC_UNAME = split(syntastic#util#system('uname'), "\n")[0]
calling function syntastic#util#system('uname')

line 1:     let old_shell = &shell
line 2:     let old_lc_messages = $LC_MESSAGES
line 3:     let old_lc_all = $LC_ALL
line 4: 
line 5:     let &shell = syntastic#util#var('shell')
calling function syntastic#util#system[5]..syntastic#util#var('shell')

line 1:     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)
calling function syntastic#util#system[5]..syntastic#util#var[1]..syntastic#util#rawVar('syntastic_shell')

line 1:     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))
function syntastic#util#system[5]..syntastic#util#var[1]..syntastic#util#rawVar returning '/bin/bash'

continuing in function syntastic#util#system[5]..syntastic#util#var

function syntastic#util#system[5]..syntastic#util#var returning '/bin/bash'

continuing in function syntastic#util#system

line 6:     let $LC_MESSAGES = 'C'
line 7:     let $LC_ALL = ''
line 8: 
line 9:     let crashed = 0
line 10:     let cmd_start = reltime()
line 11:     try
line 12:         let out = system(a:command)
Calling shell to execute: "(uname) > /var/folders/t1/f89v4xm93_g704frrdvfbdjh0000gn/T/v4K2IFc/0"
line 13:     catch
line 14:         let crashed = 1
line 15:         call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)
line 16:         if syntastic#util#isRunningWindows()
line 17:             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
line 18:         else
line 19:             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
line 20:             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
line 21:         endif
line 22:         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))
line 23:         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
line 24:         call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
line 25:         let out = ''
line 26:     endtry
line 27:     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
line 28: 
line 29:     let $LC_ALL = old_lc_all
line 30:     let $LC_MESSAGES = old_lc_messages
line 31: 
line 32:     let &shell = old_shell
line 33: 
line 34:     if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')
line 35:         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
line 36:     endif
line 37: 
line 38:     return out
function syntastic#util#system returning 'Darwin^@'

continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim

line 59:     catch /\m^Vim\%((\a\+)\)\=:E484/
line 60:         call syntastic#log#error("can't run external programs (misconfigured shell options?)")
line 61:         finish
line 62:     catch /\m^Vim\%((\a\+)\)\=:E684/
line 63:         let g:_SYNTASTIC_UNAME = 'Unknown'
line 64:     endtry
line 65: else
line 66:     let g:_SYNTASTIC_UNAME = 'Unknown'
line 67: endif
line 68: lockvar g:_SYNTASTIC_UNAME
line 69: 
line 70: " }}}1
line 71: 
line 72: " Defaults {{{1
line 73: 
line 104: let g:_SYNTASTIC_DEFAULTS = { 'aggregate_errors':         0, 'always_populate_loc_list': 0, 'auto_jump':                0, 'auto_loc_list':            2, 'check_on_open':            0, 'check_on_wq':              1, 'cursor_columns':           1, 'debug':                    0, 'echo_current_error':       1, 'enable_balloons':          1, 'enable_highlighting':      1, 'enable_signs':             1, 'error_symbol':             '>>', 'exit_checks':              !(s:_running_windows && syntastic#util#var('shell', &shell) =~? '\m\<cmd\.exe$'), 'filetype_map':             {}, 'full_redraws':             !(has('gui_running') || has('gui_macvim')), 'id_checkers':              1, 'ignore_extensions':        '\c\v^([gx]?z|lzma|bz2)$', 'ignore_files':             [], 'loc_list_height':          10, 'nested_autocommands':      0, 'quiet_messages':           {}, 'reuse_loc_lists':          1, 'shell':                    &shell, 'sort_aggregated_errors':   1, 'stl_format':               '[Syntax: line:%F (%t)]',
line 105: lockvar! g:_SYNTASTIC_DEFAULTS
line 106: 
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 107: for s:key in keys(g:_SYNTASTIC_DEFAULTS)
line 108:     if !exists('g:syntastic_' . s:key)
line 109:         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
line 110:     endif
line 111: endfor
line 112: 
line 113: if exists('g:syntastic_quiet_warnings')
line 114:     call syntastic#log#oneTimeWarn("variable g:syntastic_quiet_warnings is deprecated, please use let g:syntastic_quiet_messages = {'level': 'warnings'} instead")
line 115:     if g:syntastic_quiet_warnings
line 116:         let s:quiet_warnings = get(g:syntastic_quiet_messages, 'type', [])
line 117:         if type(s:quiet_warnings) != type([])
line 118:             let s:quiet_warnings = [s:quiet_warnings]
line 119:         endif
line 120:         call add(s:quiet_warnings, 'warnings')
line 121:         let g:syntastic_quiet_messages['type'] = s:quiet_warnings
line 122:     endif
line 123: endif
line 124: 
line 125: " }}}1
line 126: 
line 127: " Debug {{{1
line 128: 
line 137: let g:_SYNTASTIC_SHELL_OPTIONS = [ 'shell', 'shellcmdflag', 'shellpipe', 'shellquote', 'shellredir', 'shelltemp', 'shellxquote' ]
line 142: for s:feature in [ 'autochdir', 'shellslash', 'shellxescape', ]
line 143: 
line 144:     if exists('+' . s:feature)
line 145:         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)
line 146:     endif
line 147: endfor
line 142: for s:feature in [ 'autochdir', 'shellslash', 'shellxescape', ]
line 143: 
line 144:     if exists('+' . s:feature)
line 145:         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)
line 146:     endif
line 147: endfor
line 142: for s:feature in [ 'autochdir', 'shellslash', 'shellxescape', ]
line 143: 
line 144:     if exists('+' . s:feature)
line 145:         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)
line 146:     endif
line 147: endfor
line 142: for s:feature in [ 'autochdir', 'shellslash', 'shellxescape', ]
line 143: 
line 144:     if exists('+' . s:feature)
line 145:         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)
line 146:     endif
line 147: endfor
line 148: lockvar! g:_SYNTASTIC_SHELL_OPTIONS
line 149: 
line 150: " debug constants
line 151: let     g:_SYNTASTIC_DEBUG_TRACE         = 1
line 152: lockvar g:_SYNTASTIC_DEBUG_TRACE
line 153: let     g:_SYNTASTIC_DEBUG_LOCLIST       = 2
line 154: lockvar g:_SYNTASTIC_DEBUG_LOCLIST
line 155: let     g:_SYNTASTIC_DEBUG_NOTIFICATIONS = 4
line 156: lockvar g:_SYNTASTIC_DEBUG_NOTIFICATIONS
line 157: let     g:_SYNTASTIC_DEBUG_AUTOCOMMANDS  = 8
line 158: lockvar g:_SYNTASTIC_DEBUG_AUTOCOMMANDS
line 159: let     g:_SYNTASTIC_DEBUG_VARIABLES     = 16
line 160: lockvar g:_SYNTASTIC_DEBUG_VARIABLES
line 161: let     g:_SYNTASTIC_DEBUG_CHECKERS      = 32
line 162: lockvar g:_SYNTASTIC_DEBUG_CHECKERS
line 163: 
line 164: " }}}1
line 165: 
line 166: runtime! plugin/syntastic/*.vim
Searching for "plugin/syntastic/*.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/*.vim"
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim"
line 1: if exists('g:loaded_syntastic_notifier_autoloclist') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_autoloclist = 1
line 5: 
line 6: let g:SyntasticAutoloclistNotifier = {}
line 7: 
line 8: " Public methods {{{1
line 9: "
line 10: function! g:SyntasticAutoloclistNotifier.New() abort " {{{2
line 14: 
line 15: function! g:SyntasticAutoloclistNotifier.refresh(loclist) abort " {{{2
line 19: 
line 20: function! g:SyntasticAutoloclistNotifier.AutoToggle(loclist) abort " {{{2
line 52: 
line 53: " }}}1
line 54: 
line 55: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/autoloclist.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/balloons.vim"
line 1: if exists('g:loaded_syntastic_notifier_balloons') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_balloons = 1
line 5: 
line 6: if !has('balloon_eval')
line 7:     let g:syntastic_enable_balloons = 0
line 8: endif
line 9: 
line 10: let g:SyntasticBalloonsNotifier = {}
line 11: 
line 12: " Public methods {{{1
line 13: 
line 14: function! g:SyntasticBalloonsNotifier.New() abort " {{{2
line 18: 
line 19: function! g:SyntasticBalloonsNotifier.enabled() abort " {{{2
line 22: 
line 23: " Update the error balloons
line 24: function! g:SyntasticBalloonsNotifier.refresh(loclist) abort " {{{2
line 33: 
line 34: " Reset the error balloons
line 35: " @vimlint(EVL103, 1, a:loclist)
line 36: function! g:SyntasticBalloonsNotifier.reset(loclist) abort " {{{2
line 44: " @vimlint(EVL103, 0, a:loclist)
line 45: 
line 46: " }}}1
line 47: 
line 48: " Private functions {{{1
line 49: 
line 50: function! SyntasticBalloonsExprNotifier() abort " {{{2
line 56: 
line 57: " }}}1
line 58: 
line 59: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/balloons.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/checker.vim"
line 1: if exists('g:loaded_syntastic_checker') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_checker = 1
line 5: 
line 6: let g:SyntasticChecker = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticChecker.New(args, ...) abort " {{{2
line 59: 
line 60: function! g:SyntasticChecker.getFiletype() abort " {{{2
line 63: 
line 64: function! g:SyntasticChecker.getName() abort " {{{2
line 67: 
line 68: function! g:SyntasticChecker.getCName() abort " {{{2
line 71: 
line 72: " Synchronise _exec with user's setting.  Force re-validation if needed.
line 73: "
line 74: " XXX: This function must be called at least once before calling either
line 75: " getExec() or getExecEscaped().  Normally isAvailable() does that for you
line 76: " automatically, but you should keep still this in mind if you change the
line 77: " current checker workflow.
line 78: function! g:SyntasticChecker.syncExec(...) abort " {{{2
line 88: 
line 89: function! g:SyntasticChecker.getExec() abort " {{{2
line 92: 
line 93: function! g:SyntasticChecker.getExecEscaped() abort " {{{2
line 96: 
line 97: function! g:SyntasticChecker.getLocListRaw() abort " {{{2
line 140: 
line 141: function! g:SyntasticChecker.getLocList() abort " {{{2
line 144: 
line 145: function! g:SyntasticChecker.getVersion(...) abort " {{{2
line 162: 
line 163: function! g:SyntasticChecker.setVersion(version) abort " {{{2
line 169: 
line 170: function! g:SyntasticChecker.log(msg, ...) abort " {{{2
line 178: 
line 179: function! g:SyntasticChecker.makeprgBuild(opts) abort " {{{2
line 191: 
line 192: function! g:SyntasticChecker.isAvailable() abort " {{{2
line 204: 
line 205: function! g:SyntasticChecker.isDisabled() abort " {{{2
line 208: 
line 209: function! g:SyntasticChecker.wantSort() abort " {{{2
line 212: 
line 213: " This method is no longer used by syntastic.  It's here only to maintain
line 214: " backwards compatibility with external checkers which might depend on it.
line 215: function! g:SyntasticChecker.setWantSort(val) abort " {{{2
line 220: 
line 221: " }}}1
line 222: 
line 223: " Private methods {{{1
line 224: 
line 225: function! g:SyntasticChecker._quietMessages(errors) abort " {{{2
line 249: 
line 250: function! g:SyntasticChecker._populateHighlightRegexes(errors) abort " {{{2
line 262: 
line 263: function! g:SyntasticChecker._getOpt(opts, basename, name, default) abort " {{{2
line 271: 
line 272: " }}}1
line 273: 
line 274: " Private functions {{{1
line 275: 
line 276: function! s:_isAvailableDefault() dict " {{{2
line 279: 
line 280: " }}}1
line 281: 
line 282: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/checker.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/cursor.vim"
line 1: if exists('g:loaded_syntastic_notifier_cursor') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_cursor = 1
line 5: 
line 6: let g:SyntasticCursorNotifier = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticCursorNotifier.New() abort " {{{2
line 14: 
line 15: function! g:SyntasticCursorNotifier.enabled() abort " {{{2
line 18: 
line 19: function! g:SyntasticCursorNotifier.refresh(loclist) abort " {{{2
line 29: 
line 30: " @vimlint(EVL103, 1, a:loclist)
line 31: function! g:SyntasticCursorNotifier.reset(loclist) abort " {{{2
line 37: " @vimlint(EVL103, 0, a:loclist)
line 38: 
line 39: " }}}1
line 40: 
line 41: " Private functions {{{1
line 42: 
line 43: function! SyntasticRefreshCursor() abort " {{{2
line 91: 
line 92: " }}}1
line 93: 
line 94: " Utilities {{{1
line 95: 
line 96: function! s:_is_same_index(line, old_line, column, idx, messages) abort " {{{2
line 115: 
line 116: function! s:_find_index(column, messages) abort " {{{2
line 135: 
line 136: " }}}1
line 137: 
line 138: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/cursor.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim"
line 1: if exists('g:loaded_syntastic_notifier_highlighting') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_highlighting = 1
line 5: 
line 6: " Highlighting requires getmatches introduced in 7.1.040
line 7: let s:has_highlighting = v:version > 701 || (v:version == 701 && has('patch040'))
line 8: lockvar s:has_highlighting
line 9: 
line 10: let g:SyntasticHighlightingNotifier = {}
line 11: 
line 12: let s:setup_done = 0
line 13: 
line 14: " Public methods {{{1
line 15: 
line 16: function! g:SyntasticHighlightingNotifier.New() abort " {{{2
line 27: 
line 28: function! g:SyntasticHighlightingNotifier.enabled() abort " {{{2
line 31: 
line 32: " Sets error highlights in the current window
line 33: function! g:SyntasticHighlightingNotifier.refresh(loclist) abort " {{{2
line 61: 
line 62: " Remove all error highlights from the window
line 63: " @vimlint(EVL103, 1, a:loclist)
line 64: function! g:SyntasticHighlightingNotifier.reset(loclist) abort " {{{2
line 70: " @vimlint(EVL103, 0, a:loclist)
line 71: 
line 72: " }}}1
line 73: 
line 74: " Private methods {{{1
line 75: 
line 76: " One time setup: define our own highlighting
line 77: function! g:SyntasticHighlightingNotifier._setup() abort " {{{2
line 93: 
line 94: function! g:SyntasticHighlightingNotifier._reset() abort " {{{2
line 101: 
line 102: " }}}1
line 103: 
line 104: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/highlighting.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/loclist.vim"
line 1: if exists('g:loaded_syntastic_loclist') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_loclist = 1
line 5: 
line 6: let g:SyntasticLoclist = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticLoclist.New(rawLoclist) abort " {{{2
line 29: 
line 30: function! g:SyntasticLoclist.current(...) abort " {{{2
line 39: 
line 40: function! g:SyntasticLoclist.extend(other) abort " {{{2
line 43: 
line 44: function! g:SyntasticLoclist.sort() abort " {{{2
line 55: 
line 56: function! g:SyntasticLoclist.isEmpty() abort " {{{2
line 59: 
line 60: function! g:SyntasticLoclist.isNewerThan(stamp) abort " {{{2
line 67: 
line 68: function! g:SyntasticLoclist.copyRaw() abort " {{{2
line 71: 
line 72: function! g:SyntasticLoclist.getRaw() abort " {{{2
line 75: 
line 76: function! g:SyntasticLoclist.getBuffers() abort " {{{2
line 79: 
line 80: function! g:SyntasticLoclist.getCursorColumns() abort " {{{2
line 83: 
line 84: function! g:SyntasticLoclist.getStatuslineFlag() abort " {{{2
line 138: 
line 139: function! g:SyntasticLoclist.getFirstError(...) abort " {{{2
line 153: 
line 154: function! g:SyntasticLoclist.getName() abort " {{{2
line 157: 
line 158: function! g:SyntasticLoclist.setName(name) abort " {{{2
line 161: 
line 162: function! g:SyntasticLoclist.getOwner() abort " {{{2
line 165: 
line 166: function! g:SyntasticLoclist.setOwner(buffer) abort " {{{2
line 169: 
line 170: function! g:SyntasticLoclist.deploy() abort " {{{2
line 176: 
line 177: function! g:SyntasticLoclist.destroy() abort " {{{2
line 182: 
line 183: function! g:SyntasticLoclist.decorate(tag) abort " {{{2
line 188: 
line 189: function! g:SyntasticLoclist.balloons() abort " {{{2
line 211: 
line 212: function! g:SyntasticLoclist.errors() abort " {{{2
line 218: 
line 219: function! g:SyntasticLoclist.warnings() abort " {{{2
line 225: 
line 226: " Legacy function.  Syntastic no longer calls it, but we keep it
line 227: " around because other plugins (f.i. powerline) depend on it.
line 228: function! g:SyntasticLoclist.hasErrorsOrWarningsToDisplay() abort " {{{2
line 231: 
line 232: " cache used by EchoCurrentError()
line 233: function! g:SyntasticLoclist.messages(buf) abort " {{{2
line 277: 
line 278: "Filter the list and return new native loclist
line 279: "e.g.
line 280: "  .filter({'bufnr': 10, 'type': 'e'})
line 281: "
line 282: "would return all errors for buffer 10.
line 283: "
line 284: "Note that all string comparisons are done with ==?
line 285: function! g:SyntasticLoclist.filter(filters) abort " {{{2
line 291: 
line 292: function! g:SyntasticLoclist.setloclist(new) abort " {{{2
line 310: 
line 311: "display the cached errors for this buf in the location list
line 312: function! g:SyntasticLoclist.show() abort " {{{2
line 342: 
line 343: " }}}1
line 344: 
line 345: " Public functions {{{1
line 346: 
line 347: function! SyntasticLoclistHide() abort " {{{2
line 351: 
line 352: " }}}1
line 353: 
line 354: " Utilities {{{1
line 355: 
line 356: function! s:_translate(key, val) abort " {{{2
line 359: 
line 360: function! s:_set_screen_column(item) abort " {{{2
line 376: 
line 377: function! s:_remove_shadowed_items(errors) abort " {{{2
line 408: 
line 409: function! s:_compare_error_items_by_columns(a, b) abort " {{{2
line 426: 
line 427: function! s:_compare_error_items_by_lines(a, b) abort " {{{2
line 442: 
line 443: " }}}1
line 444: 
line 445: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/loclist.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/modemap.vim"
line 1: if exists('g:loaded_syntastic_modemap') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_modemap = 1
line 5: 
line 6: let g:SyntasticModeMap = {}
line 7: 
line 8: " Public methods {{{1
line 9: 
line 10: function! g:SyntasticModeMap.Instance() abort " {{{2
line 18: 
line 19: function! g:SyntasticModeMap.synch() abort " {{{2
line 30: 
line 31: function! g:SyntasticModeMap.allowsAutoChecking(filetype) abort " {{{2
line 41: 
line 42: function! g:SyntasticModeMap.doAutoChecking(buf) abort " {{{2
line 50: 
line 51: function! g:SyntasticModeMap.isPassive() abort " {{{2
line 54: 
line 55: function! g:SyntasticModeMap.toggleMode() abort " {{{2
line 70: 
line 71: function! g:SyntasticModeMap.echoMode() abort " {{{2
line 74: 
line 75: function! g:SyntasticModeMap.modeInfo(filetypes) abort " {{{2
line 103: 
line 104: " }}}1
line 105: 
line 106: " Private methods {{{1
line 107: 
line 108: function! g:SyntasticModeMap._isOneFiletypeActive(filetypes) abort " {{{2
line 111: 
line 112: function! g:SyntasticModeMap._noFiletypesArePassive(filetypes) abort " {{{2
line 115: 
line 116: " }}}1
line 117: 
line 118: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/modemap.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim"
line 1: if exists('g:loaded_syntastic_notifiers') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifiers = 1
line 5: 
line 6: let g:SyntasticNotifiers = {}
line 7: 
line 8: let s:_NOTIFIER_TYPES = ['signs', 'balloons', 'highlighting', 'cursor', 'autoloclist']
line 9: lockvar! s:_NOTIFIER_TYPES
line 10: 
line 11: let s:_PERSISTENT_NOTIFIERS = ['signs', 'balloons']
line 12: lockvar! s:_PERSISTENT_NOTIFIERS
line 13: 
line 14: " Public methods {{{1
line 15: 
line 16: function! g:SyntasticNotifiers.Instance() abort " {{{2
line 24: 
line 25: function! g:SyntasticNotifiers.refresh(loclist) abort " {{{2
line 50: 
line 51: function! g:SyntasticNotifiers.reset(loclist) abort " {{{2
line 69: 
line 70: " }}}1
line 71: 
line 72: " Private methods {{{1
line 73: 
line 74: function! g:SyntasticNotifiers._initNotifiers() abort " {{{2
line 83: 
line 84: " }}}1
line 85: 
line 86: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/notifiers.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/registry.vim"
line 1: if exists('g:loaded_syntastic_registry') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_registry = 1
line 5: 
line 6: " Initialisation {{{1
line 7: 
line 114: let s:_DEFAULT_CHECKERS = { 'actionscript':  ['mxmlc'], 'ada':           ['gcc'], 'ansible':       ['ansible_lint'], 'apiblueprint':  ['drafter'], 'applescript':   ['osacompile'], 'asciidoc':      ['asciidoc'], 'asl':           ['iasl'], 'asm':           ['gcc'], 'bro':           ['bro'], 'bemhtml':       ['bemhtmllint'], 'c':             ['gcc'], 'cabal':         ['cabal'], 'chef':          ['foodcritic'], 'co':            ['coco'], 'cobol':         ['cobc'], 'coffee':        ['coffee', 'coffeelint'], 'coq':           ['coqtop'], 'cpp':           ['gcc'], 'cs':            ['mcs'], 'css':           ['csslint'], 'cucumber':      ['cucumber'], 'cuda':          ['nvcc'], 'd':             ['dmd'], 'dart':          ['dartanalyzer'], 'docbk':         ['xmllint'], 'dockerfile':    ['dockerfile_lint'], 'dustjs':        ['swiffer'], 'elixir':        [], 'erlang':        ['escript'], 'eruby':         ['ruby'], 'fortran':       ['gfortran'], 'glsl':          ['cgc'], 'go':            [], 'haml':          ['ham
line 115: lockvar! s:_DEFAULT_CHECKERS
line 116: 
line 127: let s:_DEFAULT_FILETYPE_MAP = { 'gentoo-metadata': 'xml', 'groff': 'nroff', 'lhaskell': 'haskell', 'litcoffee': 'coffee', 'mail': 'text', 'mkd': 'markdown', 'pe-puppet': 'puppet', 'sgml': 'docbk', 'sgmllnx': 'docbk', }
line 128: lockvar! s:_DEFAULT_FILETYPE_MAP
line 129: 
line 138: let s:_ECLIM_TYPES = [ 'c', 'cpp', 'html', 'java', 'php', 'python', 'ruby', ]
line 139: lockvar! s:_ECLIM_TYPES
line 140: 
line 146: let s:_YCM_TYPES = [ 'c', 'cpp', 'objc', 'objcpp', ]
line 147: lockvar! s:_YCM_TYPES
line 148: 
line 149: let g:SyntasticRegistry = {}
line 150: 
line 151: " }}}1
line 152: 
line 153: " Public methods {{{1
line 154: 
line 155: " Note: Handling of filetype aliases: all public methods take aliases as
line 156: " parameters, all private methods take normalized filetypes.  Public methods
line 157: " are thus supposed to normalize filetypes before calling private methods.
line 158: 
line 159: function! g:SyntasticRegistry.Instance() abort " {{{2
line 167: 
line 168: function! g:SyntasticRegistry.CreateAndRegisterChecker(args) abort " {{{2
line 186: 
line 187: " Given a list of checker names hints_list, return a map name --> checker.
line 188: " If hints_list is empty, user settings are are used instead. Checkers are
line 189: " not checked for availability (that is, the corresponding IsAvailable() are
line 190: " not run).
line 191: function! g:SyntasticRegistry.getCheckers(ftalias, hints_list) abort " {{{2
line 226: 
line 227: " Same as getCheckers(), but keep only the available checkers.  This runs the
line 228: " corresponding IsAvailable() functions for all checkers.
line 229: function! g:SyntasticRegistry.getCheckersAvailable(ftalias, hints_list) abort " {{{2
line 232: 
line 233: " Same as getCheckers(), but keep only the checkers that are available and
line 234: " disabled.  This runs the corresponding IsAvailable() functions for all checkers.
line 235: function! g:SyntasticRegistry.getCheckersDisabled(ftalias, hints_list) abort " {{{2
line 238: 
line 239: function! g:SyntasticRegistry.getKnownFiletypes() abort " {{{2
line 254: 
line 255: function! g:SyntasticRegistry.getNamesOfAvailableCheckers(ftalias) abort " {{{2
line 260: 
line 261: function! g:SyntasticRegistry.resolveFiletypes(ftalias) abort " {{{2
line 264: 
line 265: function! g:SyntasticRegistry.echoInfoFor(ftalias_list) abort " {{{2
line 325: 
line 326: " }}}1
line 327: 
line 328: " Private methods {{{1
line 329: 
line 330: function! g:SyntasticRegistry._registerChecker(checker) abort " {{{2
line 343: 
line 344: function! g:SyntasticRegistry._findChecker(cname) abort " {{{2
line 355: 
line 356: function! g:SyntasticRegistry._filterCheckersByName(cnames) abort " {{{2
line 359: 
line 360: function! g:SyntasticRegistry._loadCheckersFor(filetype, force) abort " {{{2
line 371: 
line 372: " Check for obsolete variable g:syntastic_<filetype>_checker
line 373: function! g:SyntasticRegistry._sanityCheck(filetype) abort " {{{2
line 389: 
line 390: " }}}1
line 391: 
line 392: " Utilities {{{1
line 393: 
line 394: "resolve filetype aliases, and replace - with _ otherwise we cant name
line 395: "syntax checker functions legally for filetypes like "gentoo-metadata"
line 396: function! s:_normalise_filetype(ftalias) abort " {{{2
line 402: 
line 403: function! s:_disabled_by_eclim(filetype) abort " {{{2
line 412: 
line 413: function! s:_disabled_by_ycm(filetype) abort " {{{2
line 416: 
line 417: function! s:_compare_checker_names(a, b) abort " {{{2
line 436: 
line 437: " }}}1
line 438: 
line 439: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/registry.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
chdir(/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic)
fchdir() to previous dir
line 166: sourcing "/Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/signs.vim"
line 1: if exists('g:loaded_syntastic_notifier_signs') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_notifier_signs = 1
line 5: 
line 6: " Initialisation {{{1
line 7: 
line 8: " start counting sign ids at 5000, start here to hopefully avoid conflicting
line 9: " with any other code that places signs (not sure if this precaution is
line 10: " actually needed)
line 11: let s:first_sign_id = 5000
line 12: let s:next_sign_id = s:first_sign_id
line 13: 
line 14: let g:SyntasticSignsNotifier = {}
line 15: 
line 16: let s:setup_done = 0
line 17: 
line 18: " }}}1
line 19: 
line 20: " Public methods {{{1
line 21: 
line 22: function! g:SyntasticSignsNotifier.New() abort " {{{2
line 26: 
line 27: function! g:SyntasticSignsNotifier.enabled() abort " {{{2
line 30: 
line 31: function! g:SyntasticSignsNotifier.refresh(loclist) abort " {{{2
line 46: 
line 47: " }}}1
line 48: 
line 49: " Private methods {{{1
line 50: 
line 51: " One time setup: define our own sign types and highlighting
line 52: function! g:SyntasticSignsNotifier._setup() abort " {{{2
line 84: 
line 85: " Place signs by all syntax errors in the buffer
line 86: function! g:SyntasticSignsNotifier._signErrors(loclist) abort " {{{2
line 117: 
line 118: " Remove the signs with the given ids from this buffer
line 119: function! g:SyntasticSignsNotifier._removeSigns(ids) abort " {{{2
line 127: 
line 128: " Get all the ids of the SyntaxError signs in the buffer
line 129: function! g:SyntasticSignsNotifier._bufSignIds() abort " {{{2
line 135: 
line 136: " }}}1
line 137: 
line 138: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic/signs.vim
continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
Searching for "/Users/jmoussa/.vim/bundle/tlib_vim/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snippets/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/youcompleteme/plugin/syntastic/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/plugin/syntastic/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/syntastic/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/syntastic/*.vim"
Searching for "/Users/jmoussa/.vim/after/plugin/syntastic/*.vim"
Searching for "/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/syntastic/*.vim"
line 167: 
line 168: let s:registry = g:SyntasticRegistry.Instance()
calling function 341()

line 1:     if !exists('s:SyntasticRegistryInstance')
line 2:         let s:SyntasticRegistryInstance = copy(self)
line 3:         let s:SyntasticRegistryInstance._checkerMap = {}
line 4:     endif
line 5: 
line 6:     return s:SyntasticRegistryInstance
function 341 returning {'_filterCheckersByName': function('35...346'), '_findChecker': function('351')}

continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim

line 169: let s:notifiers = g:SyntasticNotifiers.Instance()
calling function 337()

line 1:     if !exists('s:SyntasticNotifiersInstance')
line 2:         let s:SyntasticNotifiersInstance = copy(self)
line 3:         call s:SyntasticNotifiersInstance._initNotifiers()
calling function 337[3]..340()

line 1:     let self._notifier = {}
line 2:     for type in s:_NOTIFIER_TYPES
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 337[3]..340[4]..355()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 337[3]..340[4]..355 returning {'_signErrors': function('359'), '_buf...ion('355'), 'refresh': function('357')}

continuing in function 337[3]..340

line 5:     endfor
line 2:     for type in s:_NOTIFIER_TYPES
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 337[3]..340[4]..266()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 337[3]..340[4]..266 returning {'enabled': function('267'), 'reset': ...ion('266'), 'refresh': function('268')}

continuing in function 337[3]..340

line 5:     endfor
line 2:     for type in s:_NOTIFIER_TYPES
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 337[3]..340[4]..294()

line 1:     let newObj = copy(self)
line 2: 
line 3:     if !s:setup_done
line 4:         call self._setup()
calling function 337[3]..340[4]..294[4]..298()

line 1:     if s:has_highlighting
line 2:         if !hlexists('SyntasticError')
line 3:             highlight link SyntasticError SpellBad
line 4:         endif
line 5:         if !hlexists('SyntasticWarning')
line 6:             highlight link SyntasticWarning SpellCap
line 7:         endif
line 8:         if !hlexists('SyntasticStyleError')
line 9:             highlight link SyntasticStyleError SyntasticError
line 10:         endif
line 11:         if !hlexists('SyntasticStyleWarning')
line 12:             highlight link SyntasticStyleWarning SyntasticWarning
line 13:         endif
line 14:     endif
function 337[3]..340[4]..294[4]..298 returning #0

continuing in function 337[3]..340[4]..294

line 5:         let s:setup_done = 1
line 6:         lockvar s:setup_done
line 7:     endif
line 8: 
line 9:     return newObj
function 337[3]..340[4]..294 returning {'_reset': function('299'), 'enabled':...ion('294'), 'refresh': function('296')}

continuing in function 337[3]..340

line 5:     endfor
line 2:     for type in s:_NOTIFIER_TYPES
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 337[3]..340[4]..290()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 337[3]..340[4]..290 returning {'enabled': function('291'), 'reset': ...ion('290'), 'refresh': function('292')}

continuing in function 337[3]..340

line 5:     endfor
line 2:     for type in s:_NOTIFIER_TYPES
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
calling function 337[3]..340[4]..263()

line 1:     let newObj = copy(self)
line 2:     return newObj
function 337[3]..340[4]..263 returning {'AutoToggle': function('265'), 'New':...ion('263'), 'refresh': function('264')}

continuing in function 337[3]..340

line 5:     endfor
line 2:     for type in s:_NOTIFIER_TYPES
line 3:         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
line 4:         let self._notifier[type] = g:{class}.New()
line 5:     endfor
line 6: 
line 7:     let self._enabled_types = copy(s:_NOTIFIER_TYPES)
function 337[3]..340 returning #0

continuing in function 337

line 4:     endif
line 5: 
line 6:     return s:SyntasticNotifiersInstance
function 337 returning {'_notifier': {'signs': {'_signErrors'...ion('339'), 'refresh': function('338')}

continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim

line 170: let s:modemap = g:SyntasticModeMap.Instance()
calling function 327()

line 1:     if !exists('s:SyntasticModeMapInstance')
line 2:         let s:SyntasticModeMapInstance = copy(self)
line 3:         call s:SyntasticModeMapInstance.synch()
calling function 327[3]..328()

line 1:     if exists('g:syntastic_mode_map')
line 2:         let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
line 3:         let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
line 4:         let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
line 5:     else
line 6:         let self._mode = 'active'
line 7:         let self._activeFiletypes = []
line 8:         let self._passiveFiletypes = []
line 9:     endif
function 327[3]..328 returning #0

continuing in function 327

line 4:     endif
line 5: 
line 6:     return s:SyntasticModeMapInstance
function 327 returning {'_activeFiletypes': [], '_mode': 'act..._isOneFiletypeActive': function('335')}

continuing in /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim

line 171: 
line 172: let s:_check_stack = []
line 173: let s:_quit_pre = []
line 174: 
line 175: " Commands {{{1
line 176: 
line 177: " @vimlint(EVL103, 1, a:cursorPos)
line 178: " @vimlint(EVL103, 1, a:cmdLine)
line 179: " @vimlint(EVL103, 1, a:argLead)
line 180: function! s:CompleteCheckerName(argLead, cmdLine, cursorPos) abort " {{{2
line 196: " @vimlint(EVL103, 0, a:cursorPos)
line 197: " @vimlint(EVL103, 0, a:cmdLine)
line 198: " @vimlint(EVL103, 0, a:argLead)
line 199: 
line 200: 
line 201: " @vimlint(EVL103, 1, a:cursorPos)
line 202: " @vimlint(EVL103, 1, a:cmdLine)
line 203: " @vimlint(EVL103, 1, a:argLead)
line 204: function! s:CompleteFiletypes(argLead, cmdLine, cursorPos) abort " {{{2
line 207: " @vimlint(EVL103, 0, a:cursorPos)
line 208: " @vimlint(EVL103, 0, a:cmdLine)
line 209: " @vimlint(EVL103, 0, a:argLead)
line 210: 
line 211: command! -bar -nargs=* -complete=custom,s:CompleteCheckerName SyntasticCheck call SyntasticCheck(<f-args>)
line 212: command! -bar -nargs=? -complete=custom,s:CompleteFiletypes   SyntasticInfo  call SyntasticInfo(<f-args>)
line 213: command! -bar Errors              call SyntasticErrors()
line 214: command! -bar SyntasticReset      call SyntasticReset()
line 215: command! -bar SyntasticToggleMode call SyntasticToggleMode()
line 216: command! -bar SyntasticSetLoclist call SyntasticSetLoclist()
line 217: 
line 218: command! SyntasticJavacEditClasspath runtime! syntax_checkers/java/*.vim | SyntasticJavacEditClasspath
line 219: command! SyntasticJavacEditConfig    runtime! syntax_checkers/java/*.vim | SyntasticJavacEditConfig
line 220: 
line 221: " }}}1
line 222: 
line 223: " Public API {{{1
line 224: 
line 225: function! SyntasticCheck(...) abort " {{{2
line 229: 
line 230: function! SyntasticInfo(...) abort " {{{2
line 237: 
line 238: function! SyntasticErrors() abort " {{{2
line 241: 
line 242: function! SyntasticReset() abort " {{{2
line 246: 
line 247: function! SyntasticToggleMode() abort " {{{2
line 253: 
line 254: function! SyntasticSetLoclist() abort " {{{2
line 257: 
line 258: " }}}1
line 259: 
line 260: " Autocommands {{{1
line 261: 
line 262: augroup syntastic
line 263:     autocmd!
line 264:     autocmd VimEnter    * call s:VimEnterHook()
line 265:     autocmd BufEnter    * call s:BufEnterHook(expand('<afile>', 1))
line 266:     autocmd BufWinEnter * call s:BufWinEnterHook(expand('<afile>', 1))
line 267: augroup END
line 268: 
line 269: if g:syntastic_nested_autocommands
line 270:     augroup syntastic
line 271:         autocmd BufReadPost  * nested call s:BufReadPostHook(expand('<afile>', 1))
line 272:         autocmd BufWritePost * nested call s:BufWritePostHook(expand('<afile>', 1))
line 273:     augroup END
line 274: else
line 275:     augroup syntastic
line 276:         autocmd BufReadPost  * call s:BufReadPostHook(expand('<afile>', 1))
line 277:         autocmd BufWritePost * call s:BufWritePostHook(expand('<afile>', 1))
line 278:     augroup END
line 279: endif
line 280: 
line 281: if exists('##QuitPre')
line 282:     " QuitPre was added in Vim 7.3.544
line 283:     augroup syntastic
line 284:         autocmd QuitPre * call s:QuitPreHook(expand('<afile>', 1))
line 285:     augroup END
line 286: endif
line 287: 
line 288: function! s:BufReadPostHook(fname) abort " {{{2
line 298: 
line 299: function! s:BufWritePostHook(fname) abort " {{{2
line 305: 
line 306: function! s:BufEnterHook(fname) abort " {{{2
line 332: 
line 333: function! s:BufWinEnterHook(fname) abort " {{{2
line 345: 
line 346: function! s:VimEnterHook() abort " {{{2
line 363: 
line 364: function! s:QuitPreHook(fname) abort " {{{2
line 377: 
line 378: " }}}1
line 379: 
line 380: " Main {{{1
line 381: 
line 382: "refresh and redraw all the error info for this buf when saving or reading
line 383: function! s:UpdateErrors(buf, auto_invoked, checker_names) abort " {{{2
line 439: 
line 440: "clear the loc list for the buffer
line 441: function! s:ClearCache(buf) abort " {{{2
line 446: 
line 447: "detect and cache all syntax errors in this buffer
line 448: function! s:CacheErrors(buf, checker_names) abort " {{{2
line 543: 
line 544: "Emulates the :lmake command. Sets up the make environment according to the
line 545: "options given, runs make, resets the environment, returns the location list
line 546: "
line 547: "a:options can contain the following keys:
line 548: "    'makeprg'
line 549: "    'errorformat'
line 550: "
line 551: "The corresponding options are set for the duration of the function call. They
line 552: "are set with :let, so dont escape spaces.
line 553: "
line 554: "a:options may also contain:
line 555: "   'defaults' - a dict containing default values for the returned errors
line 556: "   'subtype' - all errors will be assigned the given subtype
line 557: "   'preprocess' - a function to be applied to the error file before parsing errors
line 558: "   'postprocess' - a list of functions to be applied to the error list
line 559: "   'cwd' - change directory to the given path before running the checker
line 560: "   'env' - environment variables to set before running the checker
line 561: "   'returns' - a list of valid exit codes for the checker
line 562: " @vimlint(EVL102, 1, l:env_save)
line 563: function! SyntasticMake(options) abort " {{{2
line 685: " @vimlint(EVL102, 0, l:env_save)
line 686: 
line 687: "return a string representing the state of buffer according to
line 688: "g:syntastic_stl_format
line 689: "
line 690: "return '' if no errors are cached for the buffer
line 691: function! SyntasticStatuslineFlag() abort " {{{2
line 694: 
line 695: " }}}1
line 696: 
line 697: " Utilities {{{1
line 698: 
line 699: function! s:_ignore_file(filename) abort " {{{2
line 708: 
line 709: function! s:_is_quitting(buf) abort " {{{2
line 722: 
line 723: " Skip running in special buffers
line 724: function! s:_skip_file(buf) abort " {{{2
line 735: 
line 736: " Explain why checks will be skipped for the current file
line 737: function! s:_explain_skip(filetypes) abort " {{{2
line 772: 
line 773: " Take a list of errors and add default values to them from a:options
line 774: function! s:_add_to_errors(errors, options) abort " {{{2
line 785: 
line 786: function! s:_os_name() abort " {{{2
line 789: 
line 790: " }}}1
line 791: 
line 792: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/plugin/syntastic.vim
Searching for "/Users/jmoussa/.vim/bundle/tlib_vim/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/tlib_vim/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/tlib_vim/plugin/02tlib.vim"
line 1: " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
line 2: " @Created:     2007-04-10.
line 3: " @Last Change: 2016-07-28.
line 4: " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
line 5: " @Revision:    817
line 6: " @Website:     http://www.vim.org/account/profile.php?user_id=4037
line 7: " GetLatestVimScripts: 1863 1 tlib.vim
line 8: " tlib.vim -- Some utility functions
line 9: 
line 10: if &cp || exists("g:loaded_tlib")
line 11:     finish
line 12: endif
line 13: if v:version < 700 "{{{2
line 14:     echoerr "tlib requires Vim >= 7"
line 15:     finish
line 16: endif
line 17: let g:loaded_tlib = 122
line 18: 
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21: 
line 22: 
line 23: " :display: :TLet VAR = VALUE
line 24: " Set a variable only if it doesn't already exist.
line 25: " EXAMPLES: >
line 26: "   TLet foo = 1
line 27: "   TLet foo = 2
line 28: "   echo foo
line 29: "   => 1
line 30: command! -nargs=+ TLet if !exists(matchstr(<q-args>, '^[^=[:space:]]\+')) | exec 'let '. <q-args> | endif
line 31: 
line 32: 
line 33: " Open a scratch buffer (a buffer without a file).
line 34: "   TScratch  ... use split window
line 35: "   TScratch! ... use the whole frame
line 36: " This command takes an (inner) dictionary as optional argument.
line 37: " EXAMPLES: >
line 38: "   TScratch 'scratch': '__FOO__'
line 39: "   => Open a scratch buffer named __FOO__
line 40: command! -bar -nargs=* -bang TScratch call tlib#scratch#UseScratch({'scratch_split': empty('<bang>'), <args>})
line 41: 
line 42: 
line 43: " :display: :TVarArg VAR1, [VAR2, DEFAULT2] ...
line 44: " A convenience wrapper for |tlib#arg#Let|.
line 45: " EXAMPLES: >
line 46: "   function! Foo(...)
line 47: "       TVarArg ['a', 1], 'b'
line 48: "       echo 'a='. a
line 49: "       echo 'b='. b
line 50: "   endf
line 51: command! -nargs=+ TVarArg exec tlib#arg#Let([<args>])
line 52: 
line 53: 
line 54: " :display: :TBrowseOutput COMMAND
line 55: " Ever wondered how to efficiently browse the output of a command 
line 56: " without redirecting it to a file? This command takes a command as 
line 57: " argument and presents the output via |tlib#input#List()| so that you 
line 58: " can easily search for a keyword (e.g. the name of a variable or 
line 59: " function) and the like.
line 60: "
line 61: " If you press enter, the selected line will be copied to the command 
line 62: " line. Press ESC to cancel browsing.
line 63: "
line 64: " EXAMPLES: >
line 65: "   TBrowseOutput 20verb TeaseTheCulprit
line 66: command! -nargs=1 -complete=command TBrowseOutput call tlib#cmd#BrowseOutput(<q-args>)
line 67: 
line 68: 
line 69: " :display: :TBrowseScriptnames
line 70: " List all sourced script names (the output of ':scriptnames').
line 71: "
line 72: " When you press enter, the selected script will be opened in the current
line 73: " window. Press ESC to cancel.
line 74: "
line 75: " EXAMPLES: >
line 76: "   TBrowseScriptnames 
line 77: command! -nargs=0 -complete=command TBrowseScriptnames call tlib#cmd#TBrowseScriptnames()
line 78: 
line 79: 
line 80: " :display: :Tlibtrace GUARD, VAR1, VAR2...
line 81: " Do nothing unless |tlib#trace#Enable()| was called.
line 82: " 
line 83: " When |:Tlibtraceset| or |tlib#trace#Enable()| were called:
line 84: "
line 85: " If GUARD is a number that evaluates to true or if it is a string that 
line 86: " matches a |regexp|, which was added using Tlibtrace! (with '!'), 
line 87: " display the values of VAR1, VAR2 ...
line 88: command! -nargs=+ -bang Tlibtrace :
line 89: 
line 90: 
line 91: " :Tlibtraceset +RX1, -RX2...
line 92: " If |tlib#trace#Enable()| was called: With the optional <bang>, users 
line 93: " can add and remove GUARDs (actually a |regexp|) that should be traced.
line 94: "
line 95: " If no `+` or `-` is prepended, assume `+`.
line 96: command! -nargs=+ -bang Tlibtraceset call tlib#trace#Set(<q-args>)
line 97: 
line 98: 
line 99: " :display: :Tlibtrace ASSERTION
line 100: command! -nargs=+ -bang Tlibassert :
line 101: 
line 102: " :display: :Tlibtype val, 'type', ...
line 103: command! -nargs=+ Tlibtype :
line 104: 
line 105: 
line 106: 
line 107: let &cpo = s:save_cpo
line 108: unlet s:save_cpo
finished sourcing /Users/jmoussa/.vim/bundle/tlib_vim/plugin/02tlib.vim
Searching for "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/vim-snipmate/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/vim-snipmate/plugin/snipMate.vim"
line 1: " File:          snipMate.vim
line 2: " Description:   snipMate.vim implements some of TextMate's snippets features in
line 3: "                Vim. A snippet is a piece of often-typed text that you can
line 4: "                insert into your document using a trigger word followed by a "<tab>".
line 5: "
line 6: "                For more help see snipMate.txt; you can do this by using:
line 7: "                :helptags ~/.vim/doc
line 8: "                :h SnipMate
line 9: 
line 10: if exists('loaded_snips') || &cp || version < 700
line 11: ^Ifinish
line 12: endif
line 13: let loaded_snips = 1
line 14: 
line 15: " Save and reset 'cpo'
line 16: let s:save_cpo = &cpo
line 17: set cpo&vim
line 18: 
line 19: try
line 20: ^Icall funcref#Function('')
Searching for "autoload/funcref.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/autoload/funcref.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/autoload/funcref.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/funcref.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/autoload/funcref.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/autoload/funcref.vim"
Searching for "/Users/jmoussa/.vim/bundle/syntastic/autoload/funcref.vim"
Searching for "/Users/jmoussa/.vim/bundle/tlib_vim/autoload/funcref.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/autoload/funcref.vim"
chdir(/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/autoload)
fchdir() to previous dir
line 20: sourcing "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/autoload/funcref.vim"
line 1: " funcref.vim
line 2: " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
line 3: " @Last Change: 2010-01-03.
line 4: " @Revision:    0.1.0
line 5: 
line 6: " documentation see doc/funcref.txt
line 7: 
line 8: " usage:
line 9: "  funcref#Function("filename#Function")
line 10: "  optionally pass arguments:
line 11: "  funcref#Function("filename#Function",{'args': [2]})
line 12: "  optionally define self:
line 13: "  funcref#Function("filename#Function",{'self': object})
line 14: function! funcref#Function(name,...)
line 19: 
line 20: " args : same as used for call(f,[args], self)
line 21: " f must be either
line 22: "   - a string which can be evaled (use "return 'value'" to return a value)
line 23: "   - a Vim function reference created by function('..')
line 24: "   - a faked function reference created by funcref#Function(..)
line 25: "
line 26: " the last "self" argument can be overriden by the function reference
line 27: " You can pass arguments in a closure like style
line 28: function! funcref#Call(...)
finished sourcing /Users/jmoussa/.vim/bundle/vim-addon-mw-utils/autoload/funcref.vim
continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/plugin/snipMate.vim
calling function funcref#Function('')

line 1:   let d = a:0 > 0 ? a:1 : {}
line 2:   let d['faked_function_reference'] = a:name
line 3:   return d
function funcref#Function returning {'faked_function_reference': ''}

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/plugin/snipMate.vim

line 21: catch /.*/
line 22: ^Iechoe "you're missing vim-addon-mw-utils. See install instructions at ".expand('<sfile>:h:h').'/README.md'
line 23: endtry
line 24: 
line 25: if (!exists('g:snipMateSources'))
line 26:   let g:snipMateSources = {}
line 27:   " Default source: get snippets based on runtimepath
line 28:   let g:snipMateSources['default'] = funcref#Function('snipMate#DefaultPool')
calling function funcref#Function('snipMate#DefaultPool')

line 1:   let d = a:0 > 0 ? a:1 : {}
line 2:   let d['faked_function_reference'] = a:name
line 3:   return d
function funcref#Function returning {'faked_function_reference': 'snipMate#DefaultPool'}

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/plugin/snipMate.vim

line 29: endif
line 30: 
line 31: augroup SnipMateDetect
line 32: ^Iau BufRead,BufNewFile *.snippet,*.snippets setlocal filetype=snippets
line 37: ^Iau FileType snippets if expand('<afile>:e') =~# 'snippet$' | setlocal syntax=snippet | else | setlocal syntax=snippets | endif
line 38: augroup END
line 39: 
line 40: inoremap <silent> <Plug>snipMateNextOrTrigger  <C-R>=snipMate#TriggerSnippet()<CR>
line 41: snoremap <silent> <Plug>snipMateNextOrTrigger  <Esc>a<C-R>=snipMate#TriggerSnippet()<CR>
line 42: inoremap <silent> <Plug>snipMateTrigger        <C-R>=snipMate#TriggerSnippet(1)<CR>
line 43: inoremap <silent> <Plug>snipMateBack           <C-R>=snipMate#BackwardsSnippet()<CR>
line 44: snoremap <silent> <Plug>snipMateBack           <Esc>a<C-R>=snipMate#BackwardsSnippet()<CR>
line 45: inoremap <silent> <Plug>snipMateShow           <C-R>=snipMate#ShowAvailableSnips()<CR>
line 46: xnoremap <silent> <Plug>snipMateVisual         :<C-U>call <SID>grab_visual()<CR>gv"_c
line 47: 
line 48: " config variables
line 49: if !exists('g:snips_author')
line 50: ^Ilet g:snips_author = 'Me'
line 51: endif
line 52: if !exists('g:snipMate')
line 53: ^Ilet g:snipMate = {}
line 54: endif
line 55: 
line 56: " SnipMate inserts this string when no snippet expansion can be done
line 58: let g:snipMate['no_match_completion_feedkeys_chars'] = get(g:snipMate, 'no_match_completion_feedkeys_chars', "\t")
line 59: 
line 60: " Add default scope aliases, without overriding user settings
line 61: let g:snipMate.scope_aliases = get(g:snipMate, 'scope_aliases', {})
line 62: if exists('g:snipMate_no_default_aliases')
line 64: ^Iechom 'The g:snipMate_no_default_aliases option has been renamed.' 'See :h snipMate-options.'
line 65: endif
line 68: if (!exists('g:snipMate_no_default_aliases') || !g:snipMate_no_default_aliases) && (!exists('g:snipMate.no_default_aliases') || !g:snipMate.no_default_aliases)
line 70: ^Ilet g:snipMate.scope_aliases.objc = get(g:snipMate.scope_aliases, 'objc', 'c')
line 72: ^Ilet g:snipMate.scope_aliases.cpp = get(g:snipMate.scope_aliases, 'cpp', 'c')
line 74: ^Ilet g:snipMate.scope_aliases.cu = get(g:snipMate.scope_aliases, 'cu', 'c')
line 76: ^Ilet g:snipMate.scope_aliases.xhtml = get(g:snipMate.scope_aliases, 'xhtml', 'html')
line 78: ^Ilet g:snipMate.scope_aliases.html = get(g:snipMate.scope_aliases, 'html', 'javascript')
line 80: ^Ilet g:snipMate.scope_aliases.php = get(g:snipMate.scope_aliases, 'php', 'php,html,javascript')
line 82: ^Ilet g:snipMate.scope_aliases.ur = get(g:snipMate.scope_aliases, 'ur', 'html,javascript')
line 84: ^Ilet g:snipMate.scope_aliases.mxml = get(g:snipMate.scope_aliases, 'mxml', 'actionscript')
line 86: ^Ilet g:snipMate.scope_aliases.eruby = get(g:snipMate.scope_aliases, 'eruby', 'eruby-rails,html')
line 88: ^Ilet g:snipMate.scope_aliases.scss = get(g:snipMate.scope_aliases, 'scss', 'css')
line 90: ^Ilet g:snipMate.scope_aliases.less = get(g:snipMate.scope_aliases, 'less', 'css')
line 91: endif
line 92: 
line 93: let g:snipMate['get_snippets'] = get(g:snipMate, 'get_snippets', funcref#Function("snipMate#GetSnippets"))
calling function funcref#Function('snipMate#GetSnippets')

line 1:   let d = a:0 > 0 ? a:1 : {}
line 2:   let d['faked_function_reference'] = a:name
line 3:   return d
function funcref#Function returning {'faked_function_reference': 'snipMate#GetSnippets'}

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/plugin/snipMate.vim

line 94: 
line 95: " List of paths where snippets/ dirs are located
line 96: let g:snipMate['snippet_dirs'] = get(g:snipMate, 'snippet_dirs', split(&rtp, ','))
line 97: if type(g:snipMate['snippet_dirs']) != type([])
line 98: ^Iechohl WarningMsg
line 99: ^Iechom "g:snipMate['snippet_dirs'] must be a List"
line 100: ^Iechohl None
line 101: endif
line 102: 
line 103: " _ is default scope added always
line 104: "
line 105: " &ft honors multiple filetypes and syntax such as in set ft=html.javascript syntax=FOO
line 106: let g:snipMate['get_scopes'] = get(g:snipMate, 'get_scopes', funcref#Function('return split(&ft,"\\.")+[&syntax, "_"]'))
calling function funcref#Function('return split(&ft,"\\.")+[&syntax, "_"]')

line 1:   let d = a:0 > 0 ? a:1 : {}
line 2:   let d['faked_function_reference'] = a:name
line 3:   return d
function funcref#Function returning {'faked_function_reference': 'return split(&ft,"\\.")+[&syntax, "_"]'}

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/plugin/snipMate.vim

line 107: 
line 108: " Modified from Luc Hermitte's function on StackOverflow
line 109: " <http://stackoverflow.com/a/1534347>
line 110: function! s:grab_visual() abort
line 119: 
line 120: " TODO: Allow specifying an arbitrary snippets file
line 121: function! s:load_scopes(bang, ...) abort
line 127: 
line 129: command! -bang -bar -nargs=+ SnipMateLoadScope call s:load_scopes(<bang>0, <f-args>)
line 130: 
line 131: " Edit snippet files
line 132: command! SnipMateOpenSnippetFiles call snipMate#OpenSnippetFiles()
line 133: 
line 134: " restore 'cpo'
line 135: let &cpo = s:save_cpo
line 136: 
line 137: " vim:noet:sw=4:ts=4:ft=vim
finished sourcing /Users/jmoussa/.vim/bundle/vim-snipmate/plugin/snipMate.vim
Searching for "/Users/jmoussa/.vim/bundle/vim-snippets/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/vim-snippets/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/vim-snippets/plugin/vimsnippets.vim"
line 1: if exists("b:done_vimsnippets")
line 2:    finish
line 3: endif
line 4: let b:done_vimsnippets = 1
line 5: 
line 6: " Some variables need default value
line 7: if !exists("g:snips_author")
line 8:     let g:snips_author = "yourname"
line 9: endif
line 10: 
line 11: if !exists("g:snips_email")
line 12:     let g:snips_email = "yourname@email.com"
line 13: endif
line 14: 
line 15: if !exists("g:snips_github")
line 16:     let g:snips_github = "https://github.com/yourname"
line 17: endif
line 18: 
line 19: " Expanding the path is not needed on Vim 7.4
line 20: if &cp || version >= 704
line 21:     finish
finished sourcing /Users/jmoussa/.vim/bundle/vim-snippets/plugin/vimsnippets.vim
Searching for "/Users/jmoussa/.vim/bundle/youcompleteme/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/youcompleteme/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/youcompleteme/plugin/youcompleteme.vim"
line 1: " Copyright (C) 2011, 2012  Google Inc.
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17: 
line 18: " This is basic vim plugin boilerplate
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21: 
line 22: function! s:restore_cpo()
line 26: 
line 27: if exists( "g:loaded_youcompleteme" )
line 28:   call s:restore_cpo()
line 29:   finish
line 30: elseif v:version < 704 || (v:version == 704 && !has('patch143'))
line 33:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim 7.4.143+" | echohl None
line 33:  echomsg "YouCompleteMe unavailable: requires Vim 7.4.143+" | echohl None
line 33:  echohl None
line 34:   call s:restore_cpo()
line 35:   finish
line 36: elseif !has( 'python' ) && !has( 'python3' )
line 40:   echohl WarningMsg | echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "Python (2.6+ or 3.3+) support" | echohl None
line 40:  echomsg "YouCompleteMe unavailable: requires Vim compiled with " . "Python (2.6+ or 3.3+) support" | echohl None
line 40:  echohl None
line 41:   call s:restore_cpo()
line 42:   finish
line 43: endif
line 44: 
line 45: let g:loaded_youcompleteme = 1
line 46: 
line 47: " NOTE: Most defaults are in third_party/ycmd/ycmd/default_settings.json. They
line 48: " are loaded into Vim globals with the 'ycm_' prefix if such a key does not
line 49: " already exist; thus, the user can override the defaults.
line 50: " The only defaults that are here are the ones that are only relevant to the YCM
line 51: " Vim client and not the ycmd server.
line 52: 
line 54: let g:ycm_allow_changing_updatetime = get( g:, 'ycm_allow_changing_updatetime', 1 )
line 55: 
line 57: let g:ycm_open_loclist_on_ycm_diags = get( g:, 'ycm_open_loclist_on_ycm_diags', 1 )
line 58: 
line 60: let g:ycm_add_preview_to_completeopt = get( g:, 'ycm_add_preview_to_completeopt', 0 )
line 61: 
line 63: let g:ycm_autoclose_preview_window_after_completion = get( g:, 'ycm_autoclose_preview_window_after_completion', 0 )
line 64: 
line 66: let g:ycm_autoclose_preview_window_after_insertion = get( g:, 'ycm_autoclose_preview_window_after_insertion', 0 )
line 67: 
line 69: let g:ycm_key_list_select_completion = get( g:, 'ycm_key_list_select_completion', ['<TAB>', '<Down>'] )
line 70: 
line 72: let g:ycm_key_list_previous_completion = get( g:, 'ycm_key_list_previous_completion', ['<S-TAB>', '<Up>'] )
line 73: 
line 75: let g:ycm_key_invoke_completion = get( g:, 'ycm_key_invoke_completion', '<C-Space>' )
line 76: 
line 78: let g:ycm_key_detailed_diagnostics = get( g:, 'ycm_key_detailed_diagnostics', '<leader>d' )
line 79: 
line 81: let g:ycm_cache_omnifunc = get( g:, 'ycm_cache_omnifunc', 1 )
line 82: 
line 85: let g:ycm_log_level = get( g:, 'ycm_log_level', get( g:, 'ycm_server_log_level', 'info' ) )
line 86: 
line 89: let g:ycm_keep_logfiles = get( g:, 'ycm_keep_logfiles', get( g:, 'ycm_server_keep_logfiles', 0 ) )
line 90: 
line 92: let g:ycm_extra_conf_vim_data = get( g:, 'ycm_extra_conf_vim_data', [] )
line 93: 
line 96: let g:ycm_server_python_interpreter = get( g:, 'ycm_server_python_interpreter', get( g:, 'ycm_path_to_python_interpreter', '' ) )
line 97: 
line 99: let g:ycm_show_diagnostics_ui = get( g:, 'ycm_show_diagnostics_ui', 1 )
line 100: 
line 103: let g:ycm_enable_diagnostic_signs = get( g:, 'ycm_enable_diagnostic_signs', get( g:, 'syntastic_enable_signs', 1 ) )
line 104: 
line 107: let g:ycm_enable_diagnostic_highlighting = get( g:, 'ycm_enable_diagnostic_highlighting', get( g:, 'syntastic_enable_highlighting', 1 ) )
line 108: 
line 111: let g:ycm_echo_current_diagnostic = get( g:, 'ycm_echo_current_diagnostic', get( g:, 'syntastic_echo_current_error', 1 ) )
line 112: 
line 115: let g:ycm_always_populate_location_list = get( g:, 'ycm_always_populate_location_list', get( g:, 'syntastic_always_populate_loc_list', 0 ) )
line 116: 
line 119: let g:ycm_error_symbol = get( g:, 'ycm_error_symbol', get( g:, 'syntastic_error_symbol', '>>' ) )
line 120: 
line 123: let g:ycm_warning_symbol = get( g:, 'ycm_warning_symbol', get( g:, 'syntastic_warning_symbol', '>>' ) )
line 124: 
line 126: let g:ycm_goto_buffer_command = get( g:, 'ycm_goto_buffer_command', 'same-buffer' )
line 127: 
line 129: let g:ycm_disable_for_files_larger_than_kb = get( g:, 'ycm_disable_for_files_larger_than_kb', 1000 )
line 130: 
line 131: " On-demand loading. Let's use the autoload folder and not slow down vim's
line 132: " startup procedure.
line 133: if has( 'vim_starting' ) " loading at startup
line 134:   augroup youcompletemeStart
line 135:     autocmd!
line 136:     autocmd VimEnter * call youcompleteme#Enable()
line 137:   augroup END
line 138: else " manual loading with :packadd
line 139:   call youcompleteme#Enable()
line 140: endif
line 141: 
line 142: " This is basic vim plugin boilerplate
line 143: call s:restore_cpo()
calling function <SNR>51_restore_cpo()

line 1:   let &cpo = s:save_cpo
line 2:   unlet s:save_cpo
function <SNR>51_restore_cpo returning #0

continuing in /Users/jmoussa/.vim/bundle/youcompleteme/plugin/youcompleteme.vim

finished sourcing /Users/jmoussa/.vim/bundle/youcompleteme/plugin/youcompleteme.vim
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/plugin/**/*.vim"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/**/*.vim"
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
line 17:  finish
line 18: endif
line 19: if &cp
line 20:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
line 23:  finish
line 24: endif
line 25: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
line 27: set cpo&vim
line 28: 
line 29: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
line 35: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/getscriptPlugin.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2016 Oct 30
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of compressed files
line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 10:   finish
line 11: endif
line 12: let loaded_gzip = 1
line 13: 
line 14: augroup gzip
line 15:   " Remove all gzip autocommands
line 16:   au!
line 17: 
line 18:   " Enable editing of gzipped files.
line 19:   " The functions are defined in autoload/gzip.vim.
line 20:   "
line 21:   " Set binary mode before reading the file.
line 22:   " Use "gzip -d", gunzip isn't always available.
line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst setlocal bin
line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 31:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 32:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 33:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 34:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 35:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 36:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 37:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 38:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 39:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 40:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 41:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 42:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 43:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 44:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 45:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 46:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 47:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 48:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 49:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 50:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 51:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 52: augroup END
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/gzip.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/logiPat.vim"
line 1: " LogiPat: Boolean logical pattern matcher
line 2: "   Author:  Charles E. Campbell
line 3: "   Date:    Apr 04, 2016
line 4: "   Version: 4
line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like most anything else that's free,
line 10: "               LogiPat.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: "   Usage: {{{1
line 17: "       :LogiPat ...
line 18: "
line 19: "         Boolean logic supported:
line 20: "            () grouping operators
line 21: "            !  not the following pattern
line 22: "            |  logical or
line 23: "            &  logical and
line 24: "            "..pattern.."
line 25: "^IExample: {{{1
line 26: "^I^I:LogiPat !("january"|"february")
line 27: "^I^I  would match all strings not containing the strings january
line 28: "^I^I  or february
line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 30: "
line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 32: "  and will call his name Jesus. He will be great, and will be
line 33: "  called the Son of the Most High. The Lord God will give him the
line 34: "  throne of his father, David, and he will reign over the house of
line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 36: 
line 37: " ---------------------------------------------------------------------
line 38: " Load Once: {{{1
line 39: if &cp || exists("loaded_logiPat")
line 40:  finish
line 41: endif
line 42: let g:loaded_logiPat = "v4"
line 43: let s:keepcpo        = &cpo
line 44: set cpo&vim
line 45: "DechoRemOn
line 46: 
line 47: " ---------------------------------------------------------------------
line 48: " Public Interface: {{{1
line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 55: 
line 56: " =====================================================================
line 57: " Functions: {{{1
line 58: 
line 59: " ---------------------------------------------------------------------
line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 61: fun! LogiPat(pat,...)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:String: Vim6.4 doesn't have string() {{{2
line 149: func! s:String(str)
line 152: 
line 153: " ---------------------------------------------------------------------
line 154: " LP_PatPush: {{{2
line 155: fun! s:LP_PatPush(pat)
line 162: 
line 163: " ---------------------------------------------------------------------
line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 165: fun! s:LP_PatPop(lookup)
line 178: 
line 179: " ---------------------------------------------------------------------
line 180: " LP_OpPush: {{{2
line 181: fun! s:LP_OpPush(op)
line 232: 
line 233: " ---------------------------------------------------------------------
line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 235: fun! s:LP_Execute(preclvl)
line 265: 
line 266: " ---------------------------------------------------------------------
line 267: " LP_Not: writes a logical-not for a pattern {{{2
line 268: fun! s:LP_Not(pat)
line 279: 
line 280: " ---------------------------------------------------------------------
line 281: " LP_Or: writes a logical-or branch using two patterns {{{2
line 282: fun! s:LP_Or(pat1,pat2)
line 288: 
line 289: " ---------------------------------------------------------------------
line 290: " LP_And: writes a logical-and concat using two patterns {{{2
line 291: fun! s:LP_And(pat1,pat2)
line 297: 
line 298: " ---------------------------------------------------------------------
line 299: " StackLook: {{{2
line 300: fun! s:StackLook(description)
line 334: 
line 335: " ---------------------------------------------------------------------
line 336: "  Cleanup And Modeline: {{{1
line 337: let &cpo= s:keepcpo
line 338: unlet s:keepcpo
line 339: " vim: ts=4 fdm=marker
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/logiPat.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/manpager.vim"
line 1: " Vim plugin for using Vim as manpager.
line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
line 3: " Last Change: 2016 May 20
line 4: 
line 5: " $MAN_PN is supposed to be set by MANPAGER, see ":help manpager.vim".
line 6: if empty($MAN_PN)
line 7:   finish
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/manpager.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2016 Feb 16
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded (or disabled)
line 7: " - when 'compatible' is set
line 8: " - the "CursorMoved" autocmd event is not available.
line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: augroup matchparen
line 22:   " Replace all matchparen autocommands
line 23:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
line 24:   if exists('##TextChanged')
line 25:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 26:   endif
line 27: augroup END
line 28: 
line 29: " Skip the rest if it was already done.
line 30: if exists("*s:Highlight_Matching_Pair")
line 31:   finish
line 32: endif
line 33: 
line 34: let s:cpo_save = &cpo
line 35: set cpo-=C
line 36: 
line 37: " The function that is invoked (very often) to define a ":match" highlighting
line 38: " for any matching paren.
line 39: function! s:Highlight_Matching_Pair()
line 187: 
line 188: " Define commands that will disable and enable the plugin.
line 190: command! NoMatchParen windo silent! call matchdelete(3) | unlet! g:loaded_matchparen | au! matchparen
line 191: command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
line 192: 
line 193: let &cpo = s:cpo_save
line 194: unlet s:cpo_save
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 08, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2013 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v156"
line 24: let s:keepcpo = &cpo
line 25: set cpo&vim
line 26: "DechoRemOn
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
line 30: 
line 31: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
line 33:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
line 40: augroup END
line 41: 
line 42: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
line 44:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlRead(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try                                                       
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/                            
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
line 55: augroup END
line 56: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(<q-args>)
line 63: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
line 74: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
line 78: " Maps:
line 79: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())<cr>
line 85:  endif
line 86:  if maparg('gx','v') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    vmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
line 90:   vno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
line 92: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
line 99: 
line 100: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
line 148: 
line 149: " ---------------------------------------------------------------------
line 150: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 151: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 152: "             them, which checks if they're directories and will create a directory
line 153: "             listing when appropriate.
line 154: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 155: "             has already been called.
line 156: fun! s:VimEnter(dirname)
line 164: 
line 165: " ---------------------------------------------------------------------
line 166: " NetrwStatusLine: {{{1
line 167: fun! NetrwStatusLine()
line 178: 
line 179: " ------------------------------------------------------------------------
line 180: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 181: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 182: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 183: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 184: fun! NetUserPass(...)
line 208: 
line 209: " ------------------------------------------------------------------------
line 210: " Modelines And Restoration: {{{1
line 211: let &cpo= s:keepcpo
line 212: unlet s:keepcpo
line 213: " vim:ts=8 fdm=marker
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/netrwPlugin.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
line 8: endif
line 9: let loaded_rrhelper = 1
line 10: 
line 11: " Setup answers for a --remote-wait client who will assume
line 12: " a SetupRemoteReplies() function in the command server
line 13: 
line 14: function SetupRemoteReplies()
line 41: 
line 42: function DoRemoteReply(id, cnt, group, file)
line 47: 
line 48: " vim: set sw=2 sts=2 :
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/rrhelper.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>
line 3: " Last Change: 2006 Feb 01
line 4: 
line 5: " Exit quickly when:
line 6: " - this plugin was already loaded
line 7: " - when 'compatible' is set
line 8: " - some autocommands are already taking care of spell files
line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 10:   finish
line 11: endif
line 12: let loaded_spellfile_plugin = 1
line 13: 
line 14: " The function is in the autoload directory.
line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/spellfile.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v29"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47: augroup END
line 48: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 49: 
line 50: " ---------------------------------------------------------------------
line 51: " Restoration And Modelines: {{{1
line 52: " vim: fdm=marker
line 53: let &cpo= s:keepcpo
line 54: unlet s:keepcpo
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/tarPlugin.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2015 Sep 08
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: " TODO: {{{
line 9: "   * Options for generating the CSS in external style sheets. New :TOcss
line 10: "     command to convert the current color scheme into a (mostly) generic CSS
line 11: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 12: "     by Erik Falor
line 13: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 14: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 15: "     term) to use for the styling. Suggestion by "nacitar".
line 16: "   * Add way to override or specify which RGB colors map to the color numbers
line 17: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 18: "   * Disable filetype detection until after all processing is done.
line 19: "   * Add option for not generating the hyperlink on stuff that looks like a
line 20: "     URL? Or just color the link to fit with the colorscheme (and only special
line 21: "     when hovering)?
line 22: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 23: "     regions is turned on. Possible solution: Add normal text line numbers with
line 24: "     display:none, set to display:inline for print style sheets, and hide
line 25: "     <input> elements for print, to allow Opera printing multiple pages (and
line 26: "     other uncopyable areas?). May need to make the new text invisible to IE
line 27: "     with conditional comments to prevent copying it, IE for some reason likes
line 28: "     to copy hidden text. Other browsers too?
line 29: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 30: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 31: "     on Windows). Perhaps it is font related?
line 32: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 33: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 34: "     on diff lines though.
line 35: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 36: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 37: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 38: "     accepted to modify it.
line 39: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 40: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 41: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 42: "     does not show the whole diff filler as it is supposed to?
line 43: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 44: "     invalid content. Can/should anything be done about this? Maybe a separate
line 45: "     plugin to correct 'isprint' based on encoding?
line 46: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 47: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 48: "   * Font auto-detection similar to
line 49: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 50: "     platforms.
line 51: "   * Error thrown when sourcing 2html.vim directly when plugins are not loaded.
line 52: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 53: "^I- listchars support
line 54: "^I- full-line background highlight
line 55: "^I- other?
line 56: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 57: "     free with full-line background highlight above).
line 58: "   * Restore open/closed folds and cursor position after processing each file
line 59: "     with option not to restore for speed increase.
line 60: "   * Add extra meta info (generation time, etc.)?
line 61: "   * Tidy up so we can use strict doctype in even more situations
line 62: "   * Implementation detail: add threshold for writing the lines to the html
line 63: "     buffer before we're done (5000 or so lines should do it)
line 64: "   * TODO comments for code cleanup scattered throughout
line 65: "}}}
line 66: 
line 67: if exists('g:loaded_2html_plugin')
line 68:   finish
line 69: endif
line 70: let g:loaded_2html_plugin = 'vim7.4_v2'
line 71: 
line 72: "
line 73: " Changelog: {{{
line 74: "   7.4_v2  (this version): Fix error raised when converting a diff containing
line 75: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 76: "                           take a list so it is easier to specfiy fallback
line 77: "                           fonts in the generated CSS.
line 78: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 79: "^I^I^I    also for version-specific modelines like "vim>703:".
line 80: "
line 81: "   7.3 updates: {{{
line 82: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 83: "^I^I^I    g:html_line_ids=0. Allow customizing
line 84: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 85: "^I^I^I    g:html_id_expr evalutated when the buffer conversion
line 86: "^I^I^I    is started.
line 87: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 88: "^I^I^I    insert modeline to set it to manual.
line 89: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 90: "^I^I^I    duplicate of one buffer instead of including both.
line 91: "^I^I^I    Add anchors to each line so you can put '#L123'
line 92: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 93: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 94: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 95: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 96: "^I^I^I    Allow TOhtml to chain together with other commands
line 97: "^I^I^I    using |.
line 98: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 99: "^I^I^I    highlight groups make up the start-of-modeline text.
line 100: "^I^I^I    Improve render time of page with uncopyable regions
line 101: "^I^I^I    by not using one-input-per-char. Change name of
line 102: "^I^I^I    uncopyable option from html_unselectable to
line 103: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 104: "^I^I^I    default to inserting invalid markup for uncopyable
line 105: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 106: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 107: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 108: "^I^I^I    eliminate post-processing substitute commands in
line 109: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 110: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 111: "^I^I^I    speed improvements. Fix modeline mangling in
line 112: "^I^I^I    generated output so it works for text in the first
line 113: "^I^I^I    column. Fix missing line number and fold column in
line 114: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 115: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 116: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 117: "^I^I^I    the new default foldtext added in v11, as the patch
line 118: "^I^I^I    adding it has not yet been included in Vim.
line 119: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 120: "^I^I^I    Brabandt in
line 121: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 122: "^I^I^I    This patch has not yet been included in Vim, thus
line 123: "^I^I^I    these changes are removed in the next version.
line 124: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 125: "^I^I^I    multiple nested folds with dynamic folding on.
line 126: "^I^I^I    Also fix problem with foldtext in this situation.
line 127: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 128: "^I^I^I    and without html_no_pre, default value same as
line 129: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 130: "^I^I^I    'fileencoding' for converted document encoding if
line 131: "^I^I^I    'buftype' indicates a special buffer which isn't
line 132: "^I^I^I    written.
line 133: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 134: "^I^I^I    characters in generated output (Andy Spencer).
line 135: "^I^I^I    Escape text that looks like a modeline so Vim
line 136: "^I^I^I    doesn't use anything in the converted HTML as a
line 137: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 138: "^I^I^I    before the conversion range. Remove fold column when
line 139: "^I^I^I    there are no folds.
line 140: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 141: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 142: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 143: "^I^I^I    supported by all major browsers according to
line 144: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 145: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 146: "^I^I^I    HTML encoding to Vim encoding detection be
line 147: "^I^I^I    case-insensitive for built-in pairs.
line 148: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 149: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 150: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 151: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 152: "^I^I^I    file matches its indicated charset. Add charsets for
line 153: "^I^I^I    all of Vim's natively supported encodings.
line 154: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 155: "^I^I^I    user settings interfering with diff mode generation,
line 156: "^I^I^I    trailing whitespace (e.g. line number column) when
line 157: "^I^I^I    using html_no_pre, and bugs when using
line 158: "^I^I^I    html_hover_unfold.
line 159: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 160: "^I^I^I    folds in diff mode when first line was folded.
line 161: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 162: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 163: "^I^I^I    default to true when not set to anything. Use strict
line 164: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 165: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 166: "^I^I^I    when using this option. Add meta tag for settings.
line 167: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 168: "^I^I^I    diff colors and the normal syntax colors
line 169: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 170: "}}}
line 171: "}}}
line 172: 
line 173: " Define the :TOhtml command when:
line 174: " - 'compatible' is not set
line 175: " - this plugin was not already loaded
line 176: " - user commands are available. {{{
line 177: if !&cp && !exists(":TOhtml") && has("user_commands")
line 178:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 179: endif "}}}
line 180: 
line 181: " Make sure any patches will probably use consistent indent
line 182: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/tohtml.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell
line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v37"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: augroup Vimball
line 30:  au!
line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 32:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 33:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 34:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif
line 35:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 36:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 37: augroup END
line 38: 
line 39: " =====================================================================
line 40: " Restoration And Modelines: {{{1
line 41: " vim: fdm=marker
line 42: let &cpo= s:keepcpo
line 43: unlet s:keepcpo
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/vimballPlugin.vim
chdir(/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin)
fchdir() to previous dir
sourcing "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^ISep 13, 2016
line 4: " Maintainer:^ICharles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v28"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext='*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing /usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/plugin/zipPlugin.vim
Searching for "/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/**/*.vim"
chdir(/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin)
fchdir() to previous dir
sourcing "/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim"
line 1: if exists('g:powerline_loaded')
line 2:     finish
line 3: endif
line 4: let g:powerline_loaded = 1
line 5: 
line 6: if exists('g:powerline_pycmd')
line 7: ^Ilet s:pycmd = substitute(g:powerline_pycmd, '\v\C^(py)%[thon](3?)$', '\1\2', '')
line 8: ^Iif s:pycmd is# 'py'
line 9: ^I^Ilet s:has_python = has('python')
line 10: ^I^Ilet s:pyeval = get(g:, 'powerline_pyeval', 'pyeval')
line 11: ^Ielseif s:pycmd is# 'py3'
line 12: ^I^Ilet s:has_python = has('python3')
line 13: ^I^Ilet s:pyeval = 'py3eval'
line 14: ^I^Ilet s:pyeval = get(g:, 'powerline_pyeval', 'py3eval')
line 15: ^Ielse
line 16: ^I^Iif !exists('g:powerline_pyeval')
line 17: ^I^I^Iechohl ErrorMsg
line 18: ^I^I^I^Iechomsg 'g:powerline_pycmd was set to an unknown values, but g:powerline_pyeval'
line 19: ^I^I^I^Iechomsg 'was not set. You should either set g:powerline_pycmd to "py3" or "py",'
line 20: ^I^I^I^Iechomsg 'specify g:powerline_pyeval explicitly or unset both and let powerline'
line 21: ^I^I^I^Iechomsg 'figure them out.'
line 22: ^I^I^Iechohl None
line 23: ^I^I^Iunlet s:pycmd
line 24: ^I^I^Ifinish
line 25: ^I^Iendif
line 26: ^I^Ilet s:pyeval = g:powerline_pyeval
line 27: ^I^Ilet s:has_python = 1
line 28: ^Iendif
line 29: elseif has('python')
line 30: ^Ilet s:has_python = 1
line 31: ^Ilet s:pycmd = 'py'
line 32: ^Ilet s:pyeval = get(g:, 'powerline_pyeval', 'pyeval')
line 33: elseif has('python3')
line 34: ^Ilet s:has_python = 1
line 35: ^Ilet s:pycmd = 'py3'
line 36: ^Ilet s:pyeval = get(g:, 'powerline_pyeval', 'py3eval')
line 37: else
line 38: ^Ilet s:has_python = 0
line 39: endif
line 40: 
line 41: if !s:has_python
line 42: ^Iif !exists('g:powerline_no_python_error')
line 43: ^I^Iechohl ErrorMsg
line 44: ^I^I^Iechomsg 'You need vim compiled with Python 2.6, 2.7 or 3.2 and later support'
line 45: ^I^I^Iechomsg 'for Powerline to work. Please consult the documentation for more'
line 46: ^I^I^Iechomsg 'details.'
line 47: ^I^Iechohl None
line 48: ^Iendif
line 49: ^Iunlet s:has_python
line 50: ^Ifinish
line 51: endif
line 52: unlet s:has_python
line 53: 
line 54: let s:import_cmd = 'from powerline.vim import VimPowerline'
line 55: function s:rcmd(s)
line 62: try
line 63: ^Ilet s:can_replace_pyeval = !exists('g:powerline_pyeval')
line 64: ^Icall s:rcmd('try:')
calling function <SNR>64_rcmd('try:')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 65: ^Icall s:rcmd('^Ipowerline_appended_path = None')
calling function <SNR>64_rcmd('	powerline_appended_path = None')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 66: ^Icall s:rcmd('^Itry:')
calling function <SNR>64_rcmd('	try:')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 67: ^Icall s:rcmd('^I^I'.s:import_cmd.'')
calling function <SNR>64_rcmd('		from powerline.vim import VimPowerline')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 68: ^Icall s:rcmd('^Iexcept ImportError:')
calling function <SNR>64_rcmd('	except ImportError:')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 69: ^Icall s:rcmd('^I^Iimport sys, vim')
calling function <SNR>64_rcmd('		import sys, vim')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 70: ^Icall s:rcmd('^I^Ipowerline_appended_path = vim.eval("expand(\"<sfile>:h:h:h:h:h\")")')
calling function <SNR>64_rcmd('		powerline_appended_path = vim.eval("expand(\"<sfile>:h:h:h:h:h\")")')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 71: ^Icall s:rcmd('^I^Isys.path.append(powerline_appended_path)')
calling function <SNR>64_rcmd('		sys.path.append(powerline_appended_path)')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 72: ^Icall s:rcmd('^I^I'.s:import_cmd.'')
calling function <SNR>64_rcmd('		from powerline.vim import VimPowerline')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 73: ^Icall s:rcmd('^Iimport vim')
calling function <SNR>64_rcmd('	import vim')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 74: ^Icall s:rcmd('^Ipowerline_instance = VimPowerline()')
calling function <SNR>64_rcmd('	powerline_instance = VimPowerline()')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 75: ^Icall s:rcmd('^Ipowerline_instance.setup(pyeval=vim.eval("s:pyeval"), pycmd=vim.eval("s:pycmd"), can_replace_pyeval=int(vim.eval("s:can_replace_pyeval")))')
calling function <SNR>64_rcmd('	powerline_instance.setup(pyeval=vim...int(vim.eval("s:can_replace_pyeval")))')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 76: ^Icall s:rcmd('^Idel VimPowerline')
calling function <SNR>64_rcmd('	del VimPowerline')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 77: ^Icall s:rcmd('^Idel powerline_instance')
calling function <SNR>64_rcmd('	del powerline_instance')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 78: ^Icall s:rcmd('except Exception:')
calling function <SNR>64_rcmd('except Exception:')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 79: ^Icall s:rcmd('^Iimport traceback, sys')
calling function <SNR>64_rcmd('	import traceback, sys')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 80: ^Icall s:rcmd('^Itraceback.print_exc(file=sys.stdout)')
calling function <SNR>64_rcmd('	traceback.print_exc(file=sys.stdout)')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 81: ^Icall s:rcmd('^Iraise')
calling function <SNR>64_rcmd('	raise')

line 1: ^Iif !exists('s:pystr')
line 2: ^I^Ilet s:pystr = a:s . "\n"
line 3: ^Ielse
line 4: ^I^Ilet s:pystr = s:pystr . a:s . "\n"
line 5: ^Iendif
function <SNR>64_rcmd returning #0

continuing in /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim

line 82: ^Iexecute s:pycmd s:pystr
line 82: py try:^@^Ipowerline_appended_path = None^@^Itry:^@^I^Ifrom powerline.vim import VimPowerline^@^Iexcept ImportError:^@^I^Iimport sys, vim^@^I^Ipowerline_appended_path = vim.eval("expand(\"<sfile>:h:h:h:h:h\")")^@^I^Isys.path.append(powerline_appended_path)^@^I^Ifrom powerline.vim import VimPowerline^@^Iimport vim^@^Ipowerline_instance = VimPowerline()^@^Ipowerline_instance.setup(pyeval=vim.eval("s:pyeval"), pycmd=vim.eval("s:pycmd"), can_replace_pyeval=int(vim.eval("s:can_replace_pyeval")))^@^Idel VimPowerline^@^Idel powerline_instance^@except Exception:^@^Iimport traceback, sys^@^Itraceback.print_exc(file=sys.stdout)^@^Iraise^@
line 82: set statusline=%!pyeval('powerline.new_window()')
line 82: set tabline=%!pyeval('powerline.tabline()')
line 82: augroup Powerline
line 82: ^Iautocmd! ColorScheme * :py powerline.reset_highlight()
line 82: ^Iautocmd! VimLeavePre * :py powerline.shutdown()
line 82: augroup END
line 83: ^Iunlet s:pystr
line 84: ^Ilet s:launched = 1
line 85: finally
line 86: ^Iunlet s:can_replace_pyeval
line 87: ^Iunlet s:import_cmd
line 88: ^Iif !exists('s:launched')
line 89: ^I^Iunlet s:pystr
line 90: ^I^Iechohl ErrorMsg
line 91: ^I^I^Iechomsg 'An error occurred while importing powerline module.'
line 92: ^I^I^Iechomsg 'This could be caused by invalid sys.path setting,'
line 93: ^I^I^Iechomsg 'or by an incompatible Python version (powerline requires'
line 94: ^I^I^Iechomsg 'Python 2.6, 2.7 or 3.2 and later to work). Please consult'
line 95: ^I^I^Iechomsg 'the troubleshooting section in the documentation for'
line 96: ^I^I^Iechomsg 'possible solutions.'
line 97: ^I^I^Iif s:pycmd is# 'py' && has('python3')
line 98: ^I^I^I^Iechomsg 'If powerline on your system is installed for python 3 only you'
line 99: ^I^I^I^Iechomsg 'should set g:powerline_pycmd to "py3" to make it load correctly.'
line 100: ^I^I^Iendif
line 101: ^I^Iechohl None
line 102: ^I^Icall s:rcmd('def powerline_troubleshoot():')
line 103: ^I^Icall s:rcmd('^Iimport sys')
line 104: ^I^Icall s:rcmd('^Iimport vim')
line 105: ^I^Icall s:rcmd('^Iif sys.version_info < (2, 6):')
line 106: ^I^Icall s:rcmd('^I^Iprint("Too old python version: " + sys.version + " (first supported is 2.6)")')
line 107: ^I^Icall s:rcmd('^Ielif sys.version_info[0] == 3 and sys.version_info[1] < 2:')
line 108: ^I^Icall s:rcmd('^I^Iprint("Too old python 3 version: " + sys.version + " (first supported is 3.2)")')
line 109: ^I^Icall s:rcmd('^Itry:')
line 110: ^I^Icall s:rcmd('^I^Iimport powerline')
line 111: ^I^Icall s:rcmd('^Iexcept ImportError:')
line 112: ^I^Icall s:rcmd('^I^Iprint("Unable to import powerline, is it installed?")')
line 113: ^I^Icall s:rcmd('^Ielse:')
line 114: ^I^Icall s:rcmd('^I^Iif not vim.eval(''expand("<sfile>")'').startswith("/usr/"):')
line 115: ^I^Icall s:rcmd('^I^I^Iimport os')
line 116: ^I^Icall s:rcmd('^I^I^Ipowerline_dir = os.path.realpath(os.path.normpath(powerline.__file__))')
line 117: ^I^Icall s:rcmd('^I^I^Ipowerline_dir = os.path.dirname(powerline.__file__)')
line 118: ^I^Icall s:rcmd('^I^I^Ithis_dir = os.path.realpath(os.path.normpath(vim.eval(''expand("<sfile>:p")'')))')
line 119: ^I^Icall s:rcmd('^I^I^Ithis_dir = os.path.dirname(this_dir)')  " powerline/bindings/vim/plugin
line 120: ^I^Icall s:rcmd('^I^I^Ithis_dir = os.path.dirname(this_dir)')  " powerline/bindings/vim
line 121: ^I^Icall s:rcmd('^I^I^Ithis_dir = os.path.dirname(this_dir)')  " powerline/bindings
line 122: ^I^Icall s:rcmd('^I^I^Ithis_dir = os.path.dirname(this_dir)')  " powerline
line 123: ^I^Icall s:rcmd('^I^I^Iif os.path.basename(this_dir) != "powerline":')
line 124: ^I^Icall s:rcmd('^I^I^I^Iprint("Check your installation:")')
line 125: ^I^Icall s:rcmd('^I^I^I^Iprint("this script is not in powerline[/bindings/vim/plugin] directory,")')
line 126: ^I^Icall s:rcmd('^I^I^I^Iprint("neither it is installed system-wide")')
line 127: ^I^Icall s:rcmd('^I^I^Ireal_powerline_dir = os.path.realpath(powerline_dir)')
line 128: ^I^Icall s:rcmd('^I^I^Ireal_this_dir = os.path.realpath(this_dir)')
line 129: ^I^Icall s:rcmd('^I^I^Ithis_dir_par = os.path.dirname(real_this_dir)')
line 130: ^I^Icall s:rcmd('^I^I^Ipowerline_appended_path = globals().get("powerline_appended_path")')
line 131: ^I^Icall s:rcmd('^I^I^Iif powerline_appended_path is not None and this_dir_par != powerline_appended_path:')
line 132: ^I^Icall s:rcmd('^I^I^I^Iprint("Check your installation: this script is symlinked somewhere")')
line 133: ^I^Icall s:rcmd('^I^I^I^Iprint("where powerline is not present: {0!r} != {1!r}.".format(')
line 134: ^I^Icall s:rcmd('^I^I^I^I^Ireal_this_dir, powerline_appended_path))')
line 135: ^I^Icall s:rcmd('^I^I^Ielif real_powerline_dir != real_this_dir:')
line 136: ^I^Icall s:rcmd('^I^I^I^Iprint("It appears that you have two powerline versions installed:")')
line 137: ^I^Icall s:rcmd('^I^I^I^Iprint("one in " + real_powerline_dir + ", other in " + real_this_dir + ".")')
line 138: ^I^Icall s:rcmd('^I^I^I^Iprint("You should remove one of this. Check out troubleshooting section,")')
line 139: ^I^Icall s:rcmd('^I^I^I^Iprint("it contains some information about the alternatives.")')
line 140: ^I^Icall s:rcmd('^I^Itry:')
line 141: ^I^Icall s:rcmd('^I^I^Ifrom powerline.lint import check')
line 142: ^I^Icall s:rcmd('^I^Iexcept ImportError:')
line 143: ^I^Icall s:rcmd('^I^I^Iprint("Failed to import powerline.lint.check, cannot run powerline-lint")')
line 144: ^I^Icall s:rcmd('^I^Ielse:')
line 145: ^I^Icall s:rcmd('^I^I^Itry:')
line 146: ^I^Icall s:rcmd('^I^I^I^Ipaths = powerline_instance.get_config_paths()')
line 147: ^I^Icall s:rcmd('^I^I^Iexcept NameError:')
line 148: ^I^Icall s:rcmd('^I^I^I^Ipass')
line 149: ^I^Icall s:rcmd('^I^I^Ielse:')
line 150: ^I^Icall s:rcmd('^I^I^I^Ifrom powerline.lint.markedjson.error import echoerr')
line 151: ^I^Icall s:rcmd('^I^I^I^Iee = lambda *args, **kwargs: echoerr(*args, stream=sys.stdout, **kwargs)')
line 152: ^I^Icall s:rcmd('^I^I^I^Icheck(paths=paths, echoerr=ee, require_ext="vim")')
line 153: ^I^Icall s:rcmd('try:')
line 154: ^I^Icall s:rcmd('^Ipowerline_troubleshoot()')
line 155: ^I^Icall s:rcmd('finally:')
line 156: ^I^Icall s:rcmd('^Idel powerline_troubleshoot')
line 157: ^I^Iexecute s:pycmd s:pystr
line 158: ^I^Iunlet s:pystr
line 159: ^I^Iunlet s:pycmd
line 160: ^I^Iunlet s:pyeval
line 161: ^I^Idelfunction s:rcmd
line 162: ^I^Ifinish
line 163: ^Ielse
line 164: ^I^Iunlet s:launched
line 165: ^Iendif
line 166: ^Iunlet s:pycmd
line 167: ^Iunlet s:pyeval
line 168: ^Idelfunction s:rcmd
line 169: endtry
finished sourcing /usr/local/lib/python2.7/site-packages/powerline/bindings/vim/plugin/powerline.vim
Searching for "pack/*/start/*" in "/Users/jmoussa/.vim,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/after"
Searching for "/Users/jmoussa/.vim/pack/*/start/*"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/pack/*/start/*"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime/pack/*/start/*"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/pack/*/start/*"
Searching for "/Users/jmoussa/.vim/after/pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after/plugin/**/*.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/**/*.vim"
chdir(/Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin)
fchdir() to previous dir
sourcing "/Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/snipMate.vim"
line 1: " snipMate maps
line 2: " These maps are created here in order to make sure we can reliably create maps
line 3: " after SuperTab.
line 4: 
line 5: let s:save_cpo = &cpo
line 6: set cpo&vim
line 7: 
line 8: function! s:map_if_not_mapped(lhs, rhs, mode) abort
line 14: 
line 15: if !exists('g:snips_no_mappings') || !g:snips_no_mappings
line 16: ^Iif exists('g:snips_trigger_key')
line 17: ^I^Iechom 'g:snips_trigger_key is deprecated. See :h snipMate-mappings'
line 18: ^I^Iexec 'imap <unique>' g:snips_trigger_key '<Plug>snipMateTrigger'
line 19: ^I^Iexec 'smap <unique>' g:snips_trigger_key '<Plug>snipMateSNext'
line 20: ^I^Iexec 'xmap <unique>' g:snips_trigger_key '<Plug>snipMateVisual'
line 21: ^Ielse
line 22: ^I^I" Remove SuperTab map if it exists
line 23: ^I^Ilet s:overwrite = maparg('<Tab>', 'i') ==? '<Plug>SuperTabForward'
line 24: ^I^Icall s:map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 'i')
calling function <SNR>65_map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 'i')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'
line 2:     if !hasmapto(a:rhs, a:mode)
line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs
line 3: imap <unique> <Tab> <Plug>snipMateNextOrTrigger
line 4:     endif
function <SNR>65_map_if_not_mapped returning #0

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/snipMate.vim

line 25: ^I^Icall s:map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 's')
calling function <SNR>65_map_if_not_mapped('<Tab>', '<Plug>snipMateNextOrTrigger', 's')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'
line 2:     if !hasmapto(a:rhs, a:mode)
line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs
line 3: smap <unique> <Tab> <Plug>snipMateNextOrTrigger
line 4:     endif
function <SNR>65_map_if_not_mapped returning #0

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/snipMate.vim

line 26: ^I^Ilet s:overwrite = 0
line 27: ^I^Icall s:map_if_not_mapped('<Tab>', '<Plug>snipMateVisual', 'x')
calling function <SNR>65_map_if_not_mapped('<Tab>', '<Plug>snipMateVisual', 'x')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'
line 2:     if !hasmapto(a:rhs, a:mode)
line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs
line 3: xmap <unique> <Tab> <Plug>snipMateVisual
line 4:     endif
function <SNR>65_map_if_not_mapped returning #0

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/snipMate.vim

line 28: ^Iendif
line 29: 
line 30: ^Iif exists('g:snips_trigger_key_backwards')
line 31: ^I^Iechom 'g:snips_trigger_key_backwards is deprecated. See :h snipMate-mappings'
line 32: ^I^Iexec 'imap <unique>' g:snips_trigger_key_backwards '<Plug>snipMateIBack'
line 33: ^I^Iexec 'smap <unique>' g:snips_trigger_key_backwards '<Plug>snipMateSBack'
line 34: ^Ielse
line 35: ^I^Ilet s:overwrite = maparg('<S-Tab>', 'i') ==? '<Plug>SuperTabBackward'
line 36: ^I^Icall s:map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 'i')
calling function <SNR>65_map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 'i')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'
line 2:     if !hasmapto(a:rhs, a:mode)
line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs
line 3: imap <unique> <S-Tab> <Plug>snipMateBack
line 4:     endif
function <SNR>65_map_if_not_mapped returning #0

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/snipMate.vim

line 37: ^I^Icall s:map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 's')
calling function <SNR>65_map_if_not_mapped('<S-Tab>', '<Plug>snipMateBack', 's')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'
line 2:     if !hasmapto(a:rhs, a:mode)
line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs
line 3: smap <unique> <S-Tab> <Plug>snipMateBack
line 4:     endif
function <SNR>65_map_if_not_mapped returning #0

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/snipMate.vim

line 38: ^I^Ilet s:overwrite = 0
line 39: ^Iendif
line 40: 
line 41: ^Icall s:map_if_not_mapped('<C-R><Tab>', '<Plug>snipMateShow', 'i')
calling function <SNR>65_map_if_not_mapped('<C-R><Tab>', '<Plug>snipMateShow', 'i')

line 1:     let l:unique = s:overwrite ? '' : ' <unique>'
line 2:     if !hasmapto(a:rhs, a:mode)
line 3: ^Isilent! exe a:mode . 'map' . l:unique a:lhs a:rhs
line 3: imap <unique> <C-R><Tab> <Plug>snipMateShow
line 4:     endif
function <SNR>65_map_if_not_mapped returning #0

continuing in /Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/snipMate.vim

line 42: endif
line 43: 
line 44: let &cpo = s:save_cpo
line 45: 
line 46: " vim:noet:
finished sourcing /Users/jmoussa/.vim/bundle/vim-snipmate/after/plugin/snipMate.vim
Searching for "/Users/jmoussa/.vim/after/plugin/**/*.vim"
Reading viminfo file "/Users/jmoussa/.viminfo" info oldfiles
Executing BufWinEnter Auto commands for "*"
autocommand cal s:record(expand('<abuf>', 1))

line 0: cal s:record(expand('<abuf>', 1))
calling function <SNR>14_record('1')

line 1: ^Iif s:locked | retu | en
line 1:  retu | en
line 1:  en
line 2: ^Ilet bufnr = a:bufnr + 0
line 3: ^Ilet bufname = bufname(bufnr)
line 4: ^Iif bufnr > 0 && !empty(bufname)
line 5: ^I^Ical filter(s:mrbs, 'v:val != bufnr')
line 6: ^I^Ical insert(s:mrbs, bufnr)
line 7: ^I^Ical s:addtomrufs(bufname)
line 8: ^Ien
function <SNR>14_record returning #0

continuing in BufWinEnter Auto commands for "*"

Executing BufWinEnter Auto commands for "*"
autocommand call s:BufWinEnterHook(expand('<afile>', 1))

line 0: call s:BufWinEnterHook(expand('<afile>', 1))
calling function <SNR>45_BufWinEnterHook('')

line 1:     let buf = syntastic#util#fname2buf(a:fname)
calling function <SNR>45_BufWinEnterHook[1]..syntastic#util#fname2buf('')

line 1:     if exists('+shellslash')
line 2:         " bufnr() can't cope with backslashes
line 3:         let old_shellslash = &shellslash
line 4:         let &shellslash = 1
line 5:     endif
line 6: 
line 7:     " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
line 8:     " XXX it fails for filenames containing something like \{2,3}
line 9:     for md in [':~:.', ':~', ':p']
line 10:         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
line 11:         if buf != -1
line 12:             break
line 13:         endif
line 14:     endfor
line 9:     for md in [':~:.', ':~', ':p']
line 10:         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
chdir(^~)
fchdir() to previous dir
line 11:         if buf != -1
line 12:             break
line 13:         endif
line 14:     endfor
line 9:     for md in [':~:.', ':~', ':p']
line 10:         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
chdir(^/Users/jmoussa)
fchdir() to previous dir
line 11:         if buf != -1
line 12:             break
line 13:         endif
line 14:     endfor
line 9:     for md in [':~:.', ':~', ':p']
line 10:         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
line 11:         if buf != -1
line 12:             break
line 13:         endif
line 14:     endfor
line 15:     if buf == -1
line 16:         " XXX definitely wrong, but hope is the last thing to die :)
line 17:         let buf = bufnr(fnamemodify(a:fname, ':p'))
chdir(/Users/jmoussa)
fchdir() to previous dir
line 18:     endif
line 19: 
line 20:     if exists('+shellslash')
line 21:         let &shellslash = old_shellslash
line 22:     endif
line 23: 
line 24:     return buf
function <SNR>45_BufWinEnterHook[1]..syntastic#util#fname2buf returning #-1

continuing in function <SNR>45_BufWinEnterHook

line 2:     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
Searching for "autoload/syntastic/log.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/autoload/syntastic/log.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/autoload/syntastic/log.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/syntastic/log.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/autoload/syntastic/log.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/autoload/syntastic/log.vim"
Searching for "/Users/jmoussa/.vim/bundle/syntastic/autoload/syntastic/log.vim"
chdir(/Users/jmoussa/.vim/bundle/syntastic/autoload/syntastic)
fchdir() to previous dir
line 2: sourcing "/Users/jmoussa/.vim/bundle/syntastic/autoload/syntastic/log.vim"
line 1: if exists('g:loaded_syntastic_log_autoload') || !exists('g:loaded_syntastic_plugin')
line 2:     finish
line 3: endif
line 4: let g:loaded_syntastic_log_autoload = 1
line 5: 
line 6: let s:save_cpo = &cpo
line 7: set cpo&vim
line 8: 
line 9: let s:one_time_notices_issued = []
line 10: 
line 11: " Public functions {{{1
line 12: 
line 13: function! syntastic#log#info(msg) abort " {{{2
line 16: 
line 17: function! syntastic#log#warn(msg) abort " {{{2
line 22: 
line 23: function! syntastic#log#error(msg) abort " {{{2
line 29: 
line 30: function! syntastic#log#oneTimeWarn(msg) abort " {{{2
line 38: 
line 39: " @vimlint(EVL102, 1, l:OLD_VAR)
line 40: function! syntastic#log#deprecationWarn(old, new, ...) abort " {{{2
line 61: " @vimlint(EVL102, 0, l:OLD_VAR)
line 62: 
line 63: function! syntastic#log#debug(level, msg, ...) abort " {{{2
line 82: 
line 83: function! syntastic#log#debugShowOptions(level, names) abort " {{{2
line 102: 
line 103: function! syntastic#log#debugShowVariables(level, names) abort " {{{2
line 121: 
line 122: function! syntastic#log#debugDump(level) abort " {{{2
line 129: 
line 130: function! syntastic#log#ndebug(level, title, messages) abort " {{{2
line 144: 
line 145: " }}}1
line 146: 
line 147: " Private functions {{{1
line 148: 
line 149: function! s:_isDebugEnabled_smart(level) abort " {{{2
line 152: 
line 153: function! s:_isDebugEnabled_dumb(level) abort " {{{2
line 157: 
line 158: let s:_isDebugEnabled = function(exists('*and') ? 's:_isDebugEnabled_smart' : 's:_isDebugEnabled_dumb')
line 159: lockvar s:_isDebugEnabled
line 160: 
line 161: function! s:_logRedirect(on) abort " {{{2
line 175: 
line 176: " }}}1
line 177: 
line 178: " Utilities {{{1
line 179: 
line 180: function! s:_log_timestamp_smart() abort " {{{2
line 183: 
line 184: function! s:_log_timestamp_dumb() abort " {{{2
line 187: 
line 188: let s:_log_timestamp = function(has('float') && exists('*reltimefloat') ? 's:_log_timestamp_smart' : 's:_log_timestamp_dumb')
line 189: lockvar s:_log_timestamp
line 190: 
line 191: function! s:_format_variable(name) abort " {{{2
line 202: 
line 203: function! s:_is_modified(name) abort " {{{2
line 216: 
line 217: " }}}1
line 218: 
line 219: let &cpo = s:save_cpo
line 220: unlet s:save_cpo
line 221: 
line 222: " vim: set sw=4 sts=4 et fdm=marker:
finished sourcing /Users/jmoussa/.vim/bundle/syntastic/autoload/syntastic/log.vim
continuing in function <SNR>45_BufWinEnterHook
calling function <SNR>45_BufWinEnterHook[2]..syntastic#log#debug(8, 'autocmd: BufWinEnter, buffer -1 = '''', &buftype = ''''')

line 1:     if !s:_isDebugEnabled(a:level)
calling function <SNR>45_BufWinEnterHook[2]..syntastic#log#debug[1]..<SNR>66__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>45_BufWinEnterHook[2]..syntastic#log#debug[1]..<SNR>66__isDebugEnabled_smart returning #0

continuing in function <SNR>45_BufWinEnterHook[2]..syntastic#log#debug

line 2:         return
function <SNR>45_BufWinEnterHook[2]..syntastic#log#debug returning #0

continuing in function <SNR>45_BufWinEnterHook

line 4:     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
line 5:         let idx = index(reverse(copy(s:_check_stack)), buf)
line 6:         if idx >= 0 && !has('vim_starting')
line 7:             call remove(s:_check_stack, -idx - 1)
line 8:             call s:UpdateErrors(buf, 1, [])
line 9:         endif
line 10:     endif
function <SNR>45_BufWinEnterHook returning #0

continuing in BufWinEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand :call AutoPairsTryInit()

line 0: :call AutoPairsTryInit()
calling function AutoPairsTryInit()

line 1:   if exists('b:autopairs_loaded')
line 2:     return
line 3:   end
line 4: 
line 5:   " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
line 6:   "
line 7:   " vim-endwise doesn't support <Plug>AutoPairsReturn
line 8:   " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
line 9:   "
line 10:   " supertab doesn't support <SID>AutoPairsReturn
line 11:   " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
line 12:   "
line 13:   " and when load after vim-endwise will cause unexpected endwise inserted.
line 14:   " so always load AutoPairs at last
line 15: 
line 16:   " Buffer level keys mapping
line 17:   " comptible with other plugin
line 18:   if g:AutoPairsMapCR
line 19:     if v:version == 703 && has('patch32') || v:version > 703
line 20:       " VIM 7.3 supports advancer maparg which could get <expr> info
line 21:       " then auto-pairs could remap <CR> in any case.
line 22:       let info = maparg('<CR>', 'i', 0, 1)
line 23:       if empty(info)
line 24:         let old_cr = '<CR>'
line 25:         let is_expr = 0
line 26:       else
line 27:         let old_cr = info['rhs']
line 28:         let old_cr = s:ExpandMap(old_cr)
line 29:         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
line 30:         let is_expr = info['expr']
line 31:         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
line 32:       endif
line 33:     else
line 34:       " VIM version less than 7.3
line 35:       " the mapping's <expr> info is lost, so guess it is expr or not, it's
line 36:       " not accurate.
line 37:       let old_cr = maparg('<CR>', 'i')
line 38:       if old_cr == ''
line 39:         let old_cr = '<CR>'
line 40:         let is_expr = 0
line 41:       else
line 42:         let old_cr = s:ExpandMap(old_cr)
line 43:         " old_cr contain (, I guess the old cr is in expr mode
line 44:         let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
line 45: 
line 46:         " The old_cr start with " it must be in expr mode
line 47:         let is_expr = is_expr || old_cr =~ '\v^"'
line 48:         let wrapper_name = '<SID>AutoPairsOldCRWrapper'
line 49:       end
line 50:     end
line 51: 
line 52:     if old_cr !~ 'AutoPairsReturn'
line 53:       if is_expr
line 54:         " remap <expr> to `name` to avoid mix expr and non-expr mode
line 55:         execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
line 56:         let old_cr = wrapper_name
line 57:       end
line 58:       " Always silent mapping
line 59:       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
line 59: inoremap <script> <buffer> <silent> <CR> <CR><SID>AutoPairsReturn
line 60:     end
line 61:   endif
line 62:   call AutoPairsInit()
calling function AutoPairsTryInit[62]..AutoPairsInit()

line 1:   let b:autopairs_loaded  = 1
line 2:   let b:autopairs_enabled = 1
line 3:   let b:AutoPairsClosedPairs = {}
line 4: 
line 5:   if !exists('b:AutoPairs')
line 6:     let b:AutoPairs = g:AutoPairs
line 7:   end
line 8: 
line 9:   " buffer level map pairs keys
line 10:   for [open, close] in items(b:AutoPairs)
line 11:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap('`')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ` <C-R>=AutoPairsInsert('`')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 12:     if open != close
line 13:       call AutoPairsMap(close)
line 14:     end
line 15:     let b:AutoPairsClosedPairs[close] = open
line 16:   endfor
line 10:   for [open, close] in items(b:AutoPairs)
line 11:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap('"')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> " <C-R>=AutoPairsInsert('"')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 12:     if open != close
line 13:       call AutoPairsMap(close)
line 14:     end
line 15:     let b:AutoPairsClosedPairs[close] = open
line 16:   endfor
line 10:   for [open, close] in items(b:AutoPairs)
line 11:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap('{')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> { <C-R>=AutoPairsInsert('{')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 12:     if open != close
line 13:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[13]..AutoPairsMap('}')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> } <C-R>=AutoPairsInsert('}')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[13]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 14:     end
line 15:     let b:AutoPairsClosedPairs[close] = open
line 16:   endfor
line 10:   for [open, close] in items(b:AutoPairs)
line 11:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap('''')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ' <C-R>=AutoPairsInsert('''')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 12:     if open != close
line 13:       call AutoPairsMap(close)
line 14:     end
line 15:     let b:AutoPairsClosedPairs[close] = open
line 16:   endfor
line 10:   for [open, close] in items(b:AutoPairs)
line 11:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap('(')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ( <C-R>=AutoPairsInsert('(')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 12:     if open != close
line 13:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[13]..AutoPairsMap(')')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ) <C-R>=AutoPairsInsert(')')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[13]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 14:     end
line 15:     let b:AutoPairsClosedPairs[close] = open
line 16:   endfor
line 10:   for [open, close] in items(b:AutoPairs)
line 11:     call AutoPairsMap(open)
calling function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap('[')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> [ <C-R>=AutoPairsInsert('[')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[11]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 12:     if open != close
line 13:       call AutoPairsMap(close)
calling function AutoPairsTryInit[62]..AutoPairsInit[13]..AutoPairsMap(']')

line 1:   " | is special key which separate map command from text
line 2:   let key = a:key
line 3:   if key == '|'
line 4:     let key = '<BAR>'
line 5:   end
line 6:   let escaped_key = substitute(key, "'", "''", 'g')
line 7:   " use expr will cause search() doesn't work
line 8:   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"
line 8: inoremap <buffer> <silent> ] <C-R>=AutoPairsInsert(']')<CR>
function AutoPairsTryInit[62]..AutoPairsInit[13]..AutoPairsMap returning #0

continuing in function AutoPairsTryInit[62]..AutoPairsInit

line 14:     end
line 15:     let b:AutoPairsClosedPairs[close] = open
line 16:   endfor
line 10:   for [open, close] in items(b:AutoPairs)
line 11:     call AutoPairsMap(open)
line 12:     if open != close
line 13:       call AutoPairsMap(close)
line 14:     end
line 15:     let b:AutoPairsClosedPairs[close] = open
line 16:   endfor
line 17: 
line 18:   " Still use <buffer> level mapping for <BS> <SPACE>
line 19:   if g:AutoPairsMapBS
line 20:     " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
line 21:     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
line 21: inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>
line 22:   end
line 23: 
line 24:   if g:AutoPairsMapCh
line 25:     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
line 25: inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>
line 26:   endif
line 27: 
line 28:   if g:AutoPairsMapSpace
line 29:     " Try to respect abbreviations on a <SPACE>
line 30:     let do_abbrev = ""
line 31:     if v:version == 703 && has("patch489") || v:version > 703
line 32:       let do_abbrev = "<C-]>"
line 33:     endif
line 34:     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
line 34: inoremap <buffer> <silent> <SPACE> <C-]><C-R>=AutoPairsSpace()<CR>
line 35:   end
line 36: 
line 37:   if g:AutoPairsShortcutFastWrap != ''
line 38:     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
line 38: inoremap <buffer> <silent> <M-e> <C-R>=AutoPairsFastWrap()<CR>
line 39:   end
line 40: 
line 41:   if g:AutoPairsShortcutBackInsert != ''
line 42:     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
line 42: inoremap <buffer> <silent> <M-b> <C-R>=AutoPairsBackInsert()<CR>
line 43:   end
line 44: 
line 45:   if g:AutoPairsShortcutToggle != ''
line 46:     " use <expr> to ensure showing the status when toggle
line 47:     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
line 47: inoremap <buffer> <silent> <expr> <M-p> AutoPairsToggle()
line 48:     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
line 48: noremap <buffer> <silent> <M-p> :call AutoPairsToggle()<CR>
line 49:   end
line 50: 
line 51:   if g:AutoPairsShortcutJump != ''
line 52:     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
line 52: inoremap <buffer> <silent> <M-n> <ESC>:call AutoPairsJump()<CR>a
line 53:     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
line 53: noremap <buffer> <silent> <M-n> :call AutoPairsJump()<CR>
line 54:   end
line 55: 
function AutoPairsTryInit[62]..AutoPairsInit returning #0

continuing in function AutoPairsTryInit

function AutoPairsTryInit returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand call s:BufEnterHook(expand('<afile>', 1))

line 0: call s:BufEnterHook(expand('<afile>', 1))
calling function <SNR>45_BufEnterHook('')

line 1:     let buf = syntastic#util#fname2buf(a:fname)
calling function <SNR>45_BufEnterHook[1]..syntastic#util#fname2buf('')

line 1:     if exists('+shellslash')
line 2:         " bufnr() can't cope with backslashes
line 3:         let old_shellslash = &shellslash
line 4:         let &shellslash = 1
line 5:     endif
line 6: 
line 7:     " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
line 8:     " XXX it fails for filenames containing something like \{2,3}
line 9:     for md in [':~:.', ':~', ':p']
line 10:         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
line 11:         if buf != -1
line 12:             break
line 13:         endif
line 14:     endfor
line 9:     for md in [':~:.', ':~', ':p']
line 10:         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
chdir(^~)
fchdir() to previous dir
line 11:         if buf != -1
line 12:             break
line 13:         endif
line 14:     endfor
line 9:     for md in [':~:.', ':~', ':p']
line 10:         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
chdir(^/Users/jmoussa)
fchdir() to previous dir
line 11:         if buf != -1
line 12:             break
line 13:         endif
line 14:     endfor
line 9:     for md in [':~:.', ':~', ':p']
line 10:         let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
line 11:         if buf != -1
line 12:             break
line 13:         endif
line 14:     endfor
line 15:     if buf == -1
line 16:         " XXX definitely wrong, but hope is the last thing to die :)
line 17:         let buf = bufnr(fnamemodify(a:fname, ':p'))
chdir(/Users/jmoussa)
fchdir() to previous dir
line 18:     endif
line 19: 
line 20:     if exists('+shellslash')
line 21:         let &shellslash = old_shellslash
line 22:     endif
line 23: 
line 24:     return buf
function <SNR>45_BufEnterHook[1]..syntastic#util#fname2buf returning #-1

continuing in function <SNR>45_BufEnterHook

line 2:     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
calling function <SNR>45_BufEnterHook[2]..syntastic#log#debug(8, 'autocmd: BufEnter, buffer -1 = '''', &buftype = ''''')

line 1:     if !s:_isDebugEnabled(a:level)
calling function <SNR>45_BufEnterHook[2]..syntastic#log#debug[1]..<SNR>66__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>45_BufEnterHook[2]..syntastic#log#debug[1]..<SNR>66__isDebugEnabled_smart returning #0

continuing in function <SNR>45_BufEnterHook[2]..syntastic#log#debug

line 2:         return
function <SNR>45_BufEnterHook[2]..syntastic#log#debug returning #0

continuing in function <SNR>45_BufEnterHook

line 4:     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
line 5:         let idx = index(reverse(copy(s:_check_stack)), buf)
line 6:         if idx >= 0
line 7:             if !has('vim_starting')
line 8:                 call remove(s:_check_stack, -idx - 1)
line 9:                 call s:UpdateErrors(buf, 1, [])
line 10:             endif
line 11:         elseif &buftype ==# ''
line 12:             call s:notifiers.refresh(g:SyntasticLoclist.current())
line 13:         endif
line 14:     elseif &buftype ==# 'quickfix'
line 15:         " TODO: this is needed because in recent versions of Vim lclose
line 16:         " can no longer be called from BufWinLeave
line 17:         " TODO: at this point there is no b:syntastic_loclist
line 18:         let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
line 19:         let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
line 20:         let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
line 21:         if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
line 22:             call SyntasticLoclistHide()
line 23:         endif
line 24:     endif
function <SNR>45_BufEnterHook returning #0

continuing in BufEnter Auto commands for "*"

Executing BufEnter Auto commands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

line 0: sil call s:LocalBrowse(expand("<amatch>"))
calling function <SNR>57_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4:   
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
function <SNR>57_LocalBrowse returning #0

continuing in BufEnter Auto commands for "*"

Executing VimEnter Auto commands for "*"
autocommand silent! autocmd! FileExplorer

line 0: silent! autocmd! FileExplorer
autocommand call nerdtree#checkForBrowse(expand("<amatch>"))

line 0: call nerdtree#checkForBrowse(expand("<amatch>"))
calling function nerdtree#checkForBrowse('')

line 1:     if !isdirectory(a:dir)
line 2:         return
function nerdtree#checkForBrowse returning #0

continuing in VimEnter Auto commands for "*"

Executing VimEnter Auto commands for "*"
autocommand call s:VimEnterHook()

line 0: call s:VimEnterHook()
calling function <SNR>45_VimEnterHook()

line 1:     let g:syntastic_version = g:_SYNTASTIC_VERSION . ' (Vim ' . v:version . (has('nvim') ? ', Neovim' : '') . ', ' . g:_SYNTASTIC_UNAME . (has('gui') ? ', GUI' : '') . ')'
line 6:     lockvar g:syntastic_version
line 7: 
line 8:     let buf = bufnr('')
line 9:     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: VimEnter, buffer ' . buf . ' = ' . string(bufname(buf)) . ', &buftype = ' . string(&buftype))
calling function <SNR>45_VimEnterHook[9]..syntastic#log#debug(8, 'autocmd: VimEnter, buffer 1 = '''', &buftype = ''''')

line 1:     if !s:_isDebugEnabled(a:level)
calling function <SNR>45_VimEnterHook[9]..syntastic#log#debug[1]..<SNR>66__isDebugEnabled_smart(8)

line 1:     return and(g:syntastic_debug, a:level)
function <SNR>45_VimEnterHook[9]..syntastic#log#debug[1]..<SNR>66__isDebugEnabled_smart returning #0

continuing in function <SNR>45_VimEnterHook[9]..syntastic#log#debug

line 2:         return
function <SNR>45_VimEnterHook[9]..syntastic#log#debug returning #0

continuing in function <SNR>45_VimEnterHook

line 11:     let idx = index(reverse(copy(s:_check_stack)), buf)
line 12:     if idx >= 0 && getbufvar(buf, '&buftype') ==# ''
line 13:         call remove(s:_check_stack, -idx - 1)
line 14:         call s:UpdateErrors(buf, 1, [])
line 15:     endif
function <SNR>45_VimEnterHook returning #0

continuing in VimEnter Auto commands for "*"

Executing VimEnter Auto commands for "*"
autocommand call youcompleteme#Enable()

line 0: call youcompleteme#Enable()
Searching for "autoload/youcompleteme.vim" in "/Users/jmoussa/.vim,/Users/jmoussa/.vim/bundle/auto-pairs,/Users/jmoussa/.vim/bundle/ctrlp.vim,/Users/jmoussa/.vim/bundle/emmet-vim,/Users/jmoussa/.vim/bundle/nerdtree,/Users/jmoussa/.vim/bundle/syntastic,/Users/jmoussa/.vim/bundle/tlib_vim,/Users/jmoussa/.vim/bundle/vim-addon-mw-utils,/Users/jmoussa/.vim/bundle/vim-snipmate,/Users/jmoussa/.vim/bundle/vim-snippets,/Users/jmoussa/.vim/bundle/youcompleteme,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/runtime,/usr/local/Cellar/macvim/8.0-140/MacVim.app/Contents/Resources/vim/vimfiles/after,/Users/jmoussa/.vim/bundle/vim-snipmate/after,/Users/jmoussa/.vim/after,/usr/local/lib/python2.7/site-packages/powerline/bindings/vim/"
Searching for "/Users/jmoussa/.vim/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/auto-pairs/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/ctrlp.vim/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/emmet-vim/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/nerdtree/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/syntastic/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/tlib_vim/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-addon-mw-utils/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snipmate/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/vim-snippets/autoload/youcompleteme.vim"
Searching for "/Users/jmoussa/.vim/bundle/youcompleteme/autoload/youcompleteme.vim"
chdir(/Users/jmoussa/.vim/bundle/youcompleteme/autoload)
fchdir() to previous dir
line 0: sourcing "/Users/jmoussa/.vim/bundle/youcompleteme/autoload/youcompleteme.vim"
line 1: " Copyright (C) 2011, 2012  Google Inc.
line 2: "
line 3: " This file is part of YouCompleteMe.
line 4: "
line 5: " YouCompleteMe is free software: you can redistribute it and/or modify
line 6: " it under the terms of the GNU General Public License as published by
line 7: " the Free Software Foundation, either version 3 of the License, or
line 8: " (at your option) any later version.
line 9: "
line 10: " YouCompleteMe is distributed in the hope that it will be useful,
line 11: " but WITHOUT ANY WARRANTY; without even the implied warranty of
line 12: " MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
line 13: " GNU General Public License for more details.
line 14: "
line 15: " You should have received a copy of the GNU General Public License
line 16: " along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
line 17: 
line 18: " This is basic vim plugin boilerplate
line 19: let s:save_cpo = &cpo
line 20: set cpo&vim
line 21: 
line 22: " This needs to be called outside of a function
line 23: let s:script_folder_path = escape( expand( '<sfile>:p:h' ), '\' )
line 24: let s:omnifunc_mode = 0
line 25: let s:defer_omnifunc = 1
line 26: 
line 27: let s:old_cursor_position = []
line 28: let s:cursor_moved = 0
line 29: let s:previous_allowed_buffer_number = 0
line 30: 
line 31: 
line 32: function! s:UsingPython2()
line 40: 
line 41: 
line 42: let s:using_python2 = s:UsingPython2()
calling function <SNR>67_UsingPython2()

line 1:   " I'm willing to bet quite a bit that sooner or later, somebody will ask us to
line 2:   " make it configurable which version of Python we use.
line 3:   if has('python')
line 4:     return 1
function <SNR>67_UsingPython2 returning #1

continuing in /Users/jmoussa/.vim/bundle/youcompleteme/autoload/youcompleteme.vim

line 43: let s:python_until_eof = s:using_python2 ? "python << EOF" : "python3 << EOF"
line 44: let s:python_command = s:using_python2 ? "py " : "py3 "
line 45: 
line 46: 
line 47: function! s:Pyeval( eval_string )
line 53: 
line 54: 
line 55: function! youcompleteme#Enable()
line 119: 
line 120: 
line 121: function s:DeferredUntilInsertEnter()
line 129: 
line 130: 
line 131: function! youcompleteme#EnableCursorMovedAutocommands()
line 138: 
line 139: 
line 140: function! youcompleteme#DisableCursorMovedAutocommands()
line 143: 
line 144: 
line 145: function! youcompleteme#GetErrorCount()
line 148: 
line 149: 
line 150: function! youcompleteme#GetWarningCount()
line 153: 
line 154: 
line 155: function! s:SetUpPython() abort
line 196: 
line 197: 
line 198: function! s:SetUpKeyMappings()
line 248: 
line 249: 
line 250: function! s:SetUpSigns()
line 283: 
line 284: 
line 285: function! s:SetUpSyntaxHighlighting()
line 305: 
line 306: 
line 307: function! s:SetUpBackwardsCompatibility()
line 321: 
line 322: 
line 323: " Needed so that YCM is used instead of Syntastic
line 324: function! s:TurnOffSyntasticForCFamily()
line 330: 
line 331: 
line 332: function! s:AllowedToCompleteInBuffer( buffer )
line 351: 
line 352: 
line 353: function! s:AllowedToCompleteInCurrentBuffer()
line 356: 
line 357: 
line 358: function! s:VisitedBufferRequiresReparse()
line 369: 
line 370: 
line 371: function! s:SetUpCommands()
line 382: 
line 383: 
line 384: function! s:SetUpCpoptions()
line 395: 
line 396: 
line 397: function! s:SetUpCompleteopt()
line 419: 
line 420: 
line 421: " For various functions/use-cases, we want to keep track of whether the buffer
line 422: " has changed since the last time they were invoked. We keep the state of
line 423: " b:changedtick of the last time the specific function was called in
line 424: " b:ycm_changedtick.
line 425: function! s:SetUpYcmChangedTick()
line 431: 
line 432: 
line 433: function! s:DisableOnLargeFile( filename )
line 444: 
line 445: 
line 446: function! s:OnVimLeave()
line 449: 
line 450: 
line 451: function! s:OnCompleteDone()
line 454: 
line 455: 
line 456: function! s:OnBufferRead()
line 478: 
line 479: 
line 480: function! s:OnBufferEnter()
line 488: 
line 489: 
line 490: function! s:OnBufferUnload()
line 501: 
line 502: 
line 503: function! s:OnCursorHold()
line 511: 
line 512: 
line 513: function! s:OnFileReadyToParse()
line 530: 
line 531: 
line 532: function! s:SetCompleteFunc()
line 536: 
line 537: 
line 538: function! s:SetOmnicompleteFunc()
line 551: 
line 552: 
line 553: function! s:OnTextChangedInsertMode()
line 577: 
line 578: 
line 579: function! s:OnCursorMovedNormalMode()
line 587: 
line 588: 
line 589: function! s:OnInsertLeave()
line 602: 
line 603: 
line 604: function! s:OnInsertEnter()
line 611: 
line 612: 
line 613: function! s:UpdateCursorMoved()
line 618: 
line 619: 
line 620: function! s:ClosePreviewWindowIfNeeded()
line 634: 
line 635: 
line 636: function! s:IdentifierFinishedOperations()
line 643: 
line 644: 
line 645: " Returns 1 when inside comment and 2 when inside string
line 646: function! s:InsideCommentOrString()
line 662: 
line 663: 
line 664: function! s:InsideCommentOrStringAndShouldStop()
line 676: 
line 677: 
line 678: function! s:OnBlankLine()
line 681: 
line 682: 
line 683: function! s:InvokeCompletion()
line 713: 
line 714: 
line 715: function! s:GetCompletions()
line 718: 
line 719: 
line 720: " This is our main entry point. This is what vim calls to get completions.
line 721: function! youcompleteme#Complete( findstart, base )
line 749: 
line 750: 
line 751: function! youcompleteme#OmniComplete( findstart, base )
line 764: 
line 765: 
line 766: function! youcompleteme#ServerPid()
line 769: 
line 770: 
line 771: function! s:RestartServer()
line 774: 
line 775: 
line 776: function! s:ShowDetailedDiagnostic()
line 779: 
line 780: 
line 781: function! s:DebugInfo()
line 788: 
line 789: 
line 790: function! s:ToggleLogs(...)
line 793: 
line 794: 
line 795: function! s:CompleterCommand(...)
line 816: 
line 817: 
line 818: function! youcompleteme#OpenGoToList()
line 824: 
line 825: 
line 826: function! youcompleteme#LogsComplete( arglead, cmdline, cursorpos )
line 829: 
line 830: 
line 831: function! youcompleteme#SubCommandsComplete( arglead, cmdline, cursorpos )
line 834: 
line 835: 
line 836: function! s:ForceCompile()
line 849: 
line 850: 
line 851: function! s:ForceCompileAndDiagnostics()
line 858: 
line 859: 
line 860: function! s:ShowDiagnostics()
line 874: 
line 875: 
line 876: " This is basic vim plugin boilerplate
line 877: let &cpo = s:save_cpo
line 878: unlet s:save_cpo
finished sourcing /Users/jmoussa/.vim/bundle/youcompleteme/autoload/youcompleteme.vim
continuing in VimEnter Auto commands for "*"
calling function youcompleteme#Enable()

line 1:   call s:SetUpBackwardsCompatibility()
calling function youcompleteme#Enable[1]..<SNR>67_SetUpBackwardsCompatibility()

line 1:   let complete_in_comments_and_strings = get( g:, 'ycm_complete_in_comments_and_strings', 0 )
line 3: 
line 4:   if complete_in_comments_and_strings
line 5:     let g:ycm_complete_in_strings = 1
line 6:     let g:ycm_complete_in_comments = 1
line 7:   endif
line 8: 
line 9:   " ycm_filetypes_to_completely_ignore is the old name for fileype_blacklist
line 10:   if has_key( g:, 'ycm_filetypes_to_completely_ignore' )
line 11:     let g:filetype_blacklist =  g:ycm_filetypes_to_completely_ignore
line 12:   endif
function youcompleteme#Enable[1]..<SNR>67_SetUpBackwardsCompatibility returning #0

continuing in function youcompleteme#Enable

line 2: 
line 3:   " This can be 0 if YCM libs are old or -1 if an exception occured while
line
